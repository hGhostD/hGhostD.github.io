<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/hGhostD.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/hGhostD.github.io/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/hGhostD.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/hGhostD.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/hGhostD.github.io/css/main.css">


<link rel="stylesheet" href="/hGhostD.github.io/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hghostd.top","root":"/hGhostD.github.io/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="心有猛虎，嗷嗷待哺！嗷呜~">
<meta property="og:type" content="website">
<meta property="og:title" content="咱俩谁跟谁啊~">
<meta property="og:url" content="https://hghostd.top/page/2/index.html">
<meta property="og:site_name" content="咱俩谁跟谁啊~">
<meta property="og:description" content="心有猛虎，嗷嗷待哺！嗷呜~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="你谁啊~">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hghostd.top/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>咱俩谁跟谁啊~</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/hGhostD.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">咱俩谁跟谁啊~</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">跟谁俩呢啊~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/hGhostD.github.io/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/hGhostD.github.io/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hghostd.top/2018/01/26/RxSwift%20%E5%AE%9E%E7%8E%B0%20UITableview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hGhostD.github.io/images/avatar.gif">
      <meta itemprop="name" content="你谁啊~">
      <meta itemprop="description" content="心有猛虎，嗷嗷待哺！嗷呜~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咱俩谁跟谁啊~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hGhostD.github.io/2018/01/26/RxSwift%20%E5%AE%9E%E7%8E%B0%20UITableview/" class="post-title-link" itemprop="url">RxSwift 实现 UITableview</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2018-01-26 13:48:02 / 修改时间：18:03:57" itemprop="dateCreated datePublished" datetime="2018-01-26T13:48:02+08:00">2018-01-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hGhostD.github.io/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>UITableView 在开发中是最常使用的控件，由于 UITableview 相对来说功能比较多，所以对应的方法也很多，实现操作起来比较繁琐。通过 RxSwift 可以简化实现 UITableview 的方法，让开发者更注重业务逻辑。</p>
<!----more----> 
<h4 id="简单的实现方式"><a href="#简单的实现方式" class="headerlink" title="简单的实现方式"></a>简单的实现方式</h4><p>创建一个没有额外 Section 的 Tableview 可以很容易的实现。思路就是通过 Observable 将数据逐个绑定到相应的 Cell 上。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var dataArray = Variable&lt;[model]&gt;([])</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="type">Model</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">title</span>: <span class="keyword">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是创建一个将 Model 绑定到 Cell 上的闭包</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> setCell = &#123;(i: Int, e: Model, c: TableViewCell) <span class="keyword">in</span></span><br><span class="line">	c.setup<span class="constructor">WithModel(<span class="params">e</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备工作都已经做完了，接下来就是最关键的绑定部分，通过 Observeable 的 bind 方法来实现：<br><code>dataArray.asObservable().bind(to: self.tableView.rx.items(cellIdentifier: &quot;Cell&quot;, cellType: TableViewCell.self))(setCell).disposed(by: bag)</code><br>注意其中的 cellType 一定要和刚才创建的闭包中的对应，否则就会报错。</p>
<h4 id="带-Section-的实现方法"><a href="#带-Section-的实现方法" class="headerlink" title="带 Section 的实现方法"></a>带 Section 的实现方法</h4><p>刚才的实现方式仅仅创建了一个 Section，很多时候是无法满足需求的。想创建带 Section 的 UITableview 就需要引入 <code>import RxDataSources</code> 来实现了。</p>
<p>首先，创建一个 dataSource 用来处理 UITableview 中的代理方法</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;<span class="built_in">String</span>, Model&gt;&gt;<span class="function"><span class="params">(configureCell:&#123; (source, tableview, index, model) -&gt; UITableViewCell <span class="keyword">in</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">let</span> cell = tableview.dequeueReusableCell(withIdentifier: <span class="string">&quot;Cell&quot;</span>, <span class="keyword">for</span>: index) <span class="keyword">as</span>! TableViewCell</span></span></span><br><span class="line"><span class="params"><span class="function">	cell.setupWithModel(model)</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">return</span> cell</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>由于需要使用 Section，所以我们的数据源也要进行一些修改：<br><code>var dataArray = Variable&lt;[SectionModel&lt;String, Model&gt;]&gt;([])</code>。<br>接下来的绑定和上边的方式差不多，我们可以直接将 dataSource 绑定到 dataArray 上。</p>
<p><code>dataArray.asObservable().bind(to: self.tableView.rx.items(dataSource: dataSource)).disposed(by: bag)</code></p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>RxSwift 已经提供了很多代理方法以供我们使用，但是有的时候我们还是需要创建自己的代理方法。<br>创建一个新文件来处理 Proxy ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泊学网的方法还是 Swift 2.0 的版本 新版的 RxSwift 已经做了一些修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDelegateProxy</span>: <span class="title">DelegateProxy</span>&lt;<span class="title">UITableView</span>, <span class="title">UITableViewDelegate</span>&gt; ,<span class="title">UITableViewDelegate</span> ,<span class="title">DelegateProxyType</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">weak</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> tableView: <span class="type">UITableView</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">init</span>(<span class="params">tableView</span>: <span class="type">ParentObject</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.tableView <span class="operator">=</span> tableView</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(parentObject: tableView, delegateProxy: <span class="type">MyDelegateProxy</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">	 <span class="comment">// 如果没有实现这个方法 下面两个方法也不会实现 就会报错！参考了 Rx 中的实现方式实现的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">registerKnownImplementations</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.register &#123; <span class="type">MyDelegateProxy</span>(tableView: <span class="variable">$0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setCurrentDelegate</span>(<span class="keyword">_</span> <span class="params">delegate</span>: <span class="type">UITableViewDelegate</span>?, <span class="params">to</span> <span class="params">object</span>: <span class="type">UITableView</span>)</span> &#123;</span><br><span class="line">        object.delegate <span class="operator">=</span> delegate</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">currentDelegate</span>(<span class="params">for</span> <span class="params">object</span>: <span class="type">UITableView</span>)</span> -&gt; <span class="type">UITableViewDelegate</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> object.delegate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来需要对 UITableview 进行拓展</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对 Selector 进行处理可以优雅的调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">extension</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> didSelectRowAtIndexPath <span class="operator">=</span> <span class="keyword">#selector</span>(<span class="type">UITableViewDelegate</span>.tableView(<span class="keyword">_</span>:didSelectRowAt:))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rxDelegate: <span class="type">MyDelegateProxy</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MyDelegateProxy</span>.proxy(for: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// RxSwift 中对 Selector 绑定的方法已经修改 这里需要使用 methodInvoked 方法实现。</span></span><br><span class="line">    <span class="keyword">var</span> rxDidSelectRowAtIndexPath: <span class="type">Observable</span>&lt;(<span class="type">UITableView</span>, <span class="type">IndexPath</span>)&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> rxDelegate.methodInvoked(.didSelectRowAtIndexPath).map &#123; a <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> (a[<span class="number">0</span>] <span class="keyword">as!</span> <span class="type">UITableView</span>, a[<span class="number">1</span>] <span class="keyword">as!</span> <span class="type">IndexPath</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等以上准备步骤完成以后，接下来的调用就很容易了：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tableView</span><span class="selector-class">.rxDidSelectRowAtIndexPath</span><span class="selector-class">.subscribe</span>(<span class="attribute">onNext</span>: &#123; <span class="selector-tag">a</span>, <span class="selector-tag">b</span> <span class="selector-tag">in</span></span><br><span class="line">	<span class="selector-tag">print</span>(b)			<span class="comment">// [0,1]</span></span><br><span class="line">&#125;)<span class="selector-class">.disposed</span>(<span class="attribute">by</span>: bag)   </span><br></pre></td></tr></table></figure>
<p>有的时候我们同样需要原生的代理方法，RxSwift 也对此进行了支持。不过不能简单的使用 <code>tableView.delegate = self</code> 来实现了。需要调用 <code>tableView.rx.setDelegate(self).disposed(by: bag)</code> 来设置代理人。<strong>注意:委托代理一定要在绑定数据前执行，否则会造成崩溃！</strong><br>直接对 ViewController 进行拓展就能够实现原生代理方法了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span>(<span class="keyword">_</span> <span class="params">tableView</span>: <span class="type">UITableView</span>, <span class="params">didSelectRowAt</span> <span class="params">indexPath</span>: <span class="type">IndexPath</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 视频中说 会先走 Proxy 中的方法，但是实践的时候我发现情况相反。先走原生代理方法，然后再执行 Proxy 中的订阅方法。</span></span><br><span class="line">        <span class="built_in">print</span>(indexPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关于下拉刷新"><a href="#关于下拉刷新" class="headerlink" title="关于下拉刷新"></a>关于下拉刷新</h4><p>下拉刷新这个功能很常见，这里就简单记录一下我的实现方法吧。这里使用三方框架 <code>MJRefresh</code>。<br>首先创建下拉和上拉对象</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶部刷新</span></span><br><span class="line"><span class="keyword">let</span> header = <span class="constructor">MJRefreshNormalHeader()</span></span><br><span class="line"><span class="comment">// 底部刷新</span></span><br><span class="line"><span class="keyword">let</span> footer = <span class="constructor">MJRefreshAutoNormalFooter()</span>    </span><br></pre></td></tr></table></figure>
<p>然后绑定好处理事件</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span><span class="selector-class">.setRefreshingTarget</span>(self, refreshingAction: <span class="selector-id">#selector</span>(upRefresh))</span><br><span class="line"><span class="selector-tag">footer</span><span class="selector-class">.setRefreshingTarget</span>(self, refreshingAction: <span class="selector-id">#selector</span>(downRefresh))</span><br><span class="line">self<span class="selector-class">.tableView</span><span class="selector-class">.mj_header</span> = <span class="selector-tag">header</span></span><br><span class="line">self<span class="selector-class">.tableView</span><span class="selector-class">.mj_footer</span> = footer</span><br></pre></td></tr></table></figure>
<p>最后实现刷新事件即可</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@objc func upRefresh() &#123;</span><br><span class="line">    dataArray<span class="selector-class">.value</span><span class="selector-class">.removeAll</span>()</span><br><span class="line">    page = <span class="number">1</span></span><br><span class="line">    Network<span class="selector-class">.default</span><span class="selector-class">.searchDouBan</span>(start: String(page), count: <span class="string">&quot;10&quot;</span>)<span class="selector-class">.subscribe</span>(onNext:&#123;</span><br><span class="line">        self<span class="selector-class">.tableView</span><span class="selector-class">.mj_header</span><span class="selector-class">.endRefreshing</span>()</span><br><span class="line">        <span class="comment">// 封装成 SectionModel 数据绑定</span></span><br><span class="line">		 let sec = SectionModel(model: <span class="string">&quot;header&quot;</span>, items: $<span class="number">0</span>)</span><br><span class="line">        self<span class="selector-class">.dataArray</span><span class="selector-class">.value</span><span class="selector-class">.append</span>(sec)    </span><br><span class="line">    &#125;)<span class="selector-class">.disposed</span>(by: bag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@objc func downRefresh() &#123;</span><br><span class="line">    page += <span class="number">1</span></span><br><span class="line">    Network<span class="selector-class">.default</span><span class="selector-class">.searchDouBan</span>(start: String(page), count: <span class="string">&quot;10&quot;</span>)<span class="selector-class">.subscribe</span>(onNext:&#123;</span><br><span class="line">        self<span class="selector-class">.tableView</span><span class="selector-class">.mj_footer</span><span class="selector-class">.endRefreshing</span>()</span><br><span class="line">        let sec = SectionModel(model: <span class="string">&quot;header&quot;</span>, items: $<span class="number">0</span>)</span><br><span class="line">        self<span class="selector-class">.dataArray</span><span class="selector-class">.value</span><span class="selector-class">.append</span>(sec)  </span><br><span class="line">    &#125;)<span class="selector-class">.disposed</span>(by: bag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hghostd.top/2018/01/10/%E3%80%8A%E5%87%BD%E6%95%B0%E5%BC%8FSwift%E3%80%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hGhostD.github.io/images/avatar.gif">
      <meta itemprop="name" content="你谁啊~">
      <meta itemprop="description" content="心有猛虎，嗷嗷待哺！嗷呜~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咱俩谁跟谁啊~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hGhostD.github.io/2018/01/10/%E3%80%8A%E5%87%BD%E6%95%B0%E5%BC%8FSwift%E3%80%8B%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">《函数式 Swift》读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-10 16:03:21" itemprop="dateCreated datePublished" datetime="2018-01-10T16:03:21+08:00">2018-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-01-16 17:43:29" itemprop="dateModified" datetime="2018-01-16T17:43:29+08:00">2018-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hGhostD.github.io/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>    函数在 Swift 中是一等公民，换句话说，函数可以作为参数被传递到其他函数，
    也可以作为其他函数的返回值。函数式编程的核心理念就是函数是值。
</code></pre>
<!---more--->
<h4 id="函数式思想"><a href="#函数式思想" class="headerlink" title="函数式思想"></a>函数式思想</h4><p>在 Swift 中计算和传递函数的方式与整形或布尔型没有任何不同。<br>假设有一个 struct 包含 x 和 y 坐标:</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Position &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，定义一个 typealias，表示把 Position 转化为 bool 的函数。<br><code>typealias Region = (Position) -&gt; Bool</code>。</p>
<p>接下来创建函数的返回值就可以是一个函数(Region) </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circle</span>(<span class="params">radius</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Region</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; loc <span class="keyword">in</span> <span class="keyword">return</span> loc.x <span class="operator">&lt;</span> radius &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 </p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; (参数) -&gt; (返回值) in </span><br><span class="line">	(函数具体的操作)</span><br><span class="line">	return (返回值)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大括号内就是表示一个函数。</p>
<h4 id="案例研究：封装-Core-Image"><a href="#案例研究：封装-Core-Image" class="headerlink" title="案例研究：封装 Core Image"></a>案例研究：封装 Core Image</h4><p>书中的用例是对 CIImage 进行封装。为了让自己更明白本章所讲的内容，我把 CIImage 换成了 Int 类型来实现，两者的本质并无太大的区别，重点是对函数化这一概念要有清晰的认识。<br>我们首先将 Filter 定义为一个函数，该函数接受 Int 型作为参数，并且返回一个新的 Int 型。<code>typealias Filter = (Int) -&gt; Int</code>。<br>首先，我们定义一个简单的 +1 的方法，返回值是 Filter(<strong>是一个函数</strong>)。 </p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(describe: String)</span> -&gt; <span class="title">Filter</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in">number</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">number</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样调用起来就是： <code>addOne(describe: &quot;简单的 10+1&quot;)(10) // 11</code><br>接下来在的定义一个 +2 的方法，同上</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwo</span><span class="params">(describe: String)</span> -&gt; <span class="title">Filter</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="built_in">number</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">number</span> + <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里都挺简单的，现在如果我们要再实现一个 +3 的方法，再复制就显得太蠢了，所以转换一下思路，通过 +1 和 +2 的方法实现：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func add<span class="constructor">Three(<span class="params">describe</span>: String)</span> -&gt; Filter &#123;</span><br><span class="line">    return &#123; number <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> one = add<span class="constructor">One(<span class="params">describe</span>: <span class="string">&quot;+ 1:&quot;</span>)</span>(number)</span><br><span class="line">        return add<span class="constructor">Two(<span class="params">describe</span>: <span class="string">&quot;+ 2:&quot;</span>)</span>(one)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">add<span class="constructor">Three(<span class="params">describe</span>: <span class="string">&quot;+ 3:&quot;</span>)</span>(<span class="number">100</span>) <span class="comment">// 103</span></span><br></pre></td></tr></table></figure>
<h5 id="复合函数"><a href="#复合函数" class="headerlink" title="复合函数"></a>复合函数</h5><p>现在，如果我们想要实现 0 + 1 + 2 + 3 的功能，就可以这么调用：<br><code>addThree(describe: &quot;3&quot;)(addTwo(describe: &quot;2&quot;)(addOne(describe: &quot;1&quot;)(0))) // 6</code>。<br>感觉这么调用并不友好，我们需要优化一下实现方式。书中给了一种方案是使用<strong>复合函数</strong>。<br>首先定义一个用于组合的函数：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">compose</span>(<span class="attribute">filter1</span>: <span class="variable">@escaping</span> Filter, <span class="attribute">fileter2</span>: <span class="variable">@escaping</span> Filter) <span class="selector-tag">-</span>&gt; <span class="selector-tag">Filter</span> &#123;</span><br><span class="line">    <span class="selector-tag">return</span> &#123; <span class="selector-tag">num</span> <span class="selector-tag">in</span> <span class="selector-tag">fileter2</span>(filter1(num)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以使用复合函数来定义：<br><code>compose(compose(addOne(describe: &quot;1&quot;), addTwo(describe: &quot;2&quot;)), addThree(describe: &quot;3&quot;))(100) // 106</code></p>
<h5 id="自定义运算符"><a href="#自定义运算符" class="headerlink" title="自定义运算符"></a>自定义运算符</h5><p>但是看起来也很不容易理解。为了让代码更具可读性，我们可以再进一步，为组合引入运算符。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">infix</span> <span class="selector-tag">operator</span> &gt;&gt;&gt;: <span class="selector-tag">pro</span></span><br><span class="line"><span class="selector-tag">precedencegroup</span> <span class="selector-tag">pro</span> &#123;</span><br><span class="line">    associativity: <span class="attribute">left</span></span><br><span class="line"><span class="attribute">&#125;</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">func &gt;&gt;&gt;(filter1</span>: <span class="variable">@escaping</span> Filter, <span class="attribute">fileter2</span>: <span class="variable">@escaping</span> Filter) -&gt; Filter &#123;</span><br><span class="line">    return &#123; num in fileter2(filter1(num)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以用运算符来实现了，</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = add<span class="constructor">One(<span class="params">describe</span>: <span class="string">&quot;1&quot;</span>)</span> &gt;&gt;&gt; add<span class="constructor">Two(<span class="params">describe</span>: <span class="string">&quot;2&quot;</span>)</span> &gt;&gt;&gt; add<span class="constructor">Three(<span class="params">describe</span>: <span class="string">&quot;3&quot;</span>)</span></span><br><span class="line">result(<span class="number">0</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<h5 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h5><p>函数接受参数之后，返回一个<strong>闭包</strong>，然后等待第二个参数。<code>add(1)(2)</code>。函数中的箭头 -&gt; 向右结合。这也就是说没你可以将 A -&gt; B -&gt; C 理解为 A -&gt; (B -&gt; C)。</p>
<h4 id="Map、Filter-和-Reduce"><a href="#Map、Filter-和-Reduce" class="headerlink" title="Map、Filter 和 Reduce"></a>Map、Filter 和 Reduce</h4><h5 id="Map-和-Filter"><a href="#Map-和-Filter" class="headerlink" title="Map 和 Filter"></a>Map 和 Filter</h5><p>关于 Map 官网的描述是:</p>
<blockquote>
<p>Returns an array containing the results of mapping the given closure over the sequence’s elements.</p>
</blockquote>
<p>翻译过来就是: 返回一个数组，数组中的元素是由闭包提供的映射序列产生的。</p>
<p><code>func map&lt;T&gt;(_ transform: (Element) throws -&gt; T) rethrows -&gt; [T]</code><br>其中关于参数的描述是:</p>
<blockquote>
<p>A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.</p>
</blockquote>
<p>一个映射的闭包，以一个序列的<strong>每个元素</strong>作为参数，返回一个相同或不同的类型<strong>新值</strong>。可以知道我们需要提供的参数是<strong>一个闭包</strong>。这个闭包中的参数和返回值可以是任意类型的（由泛型定义）。</p>
<p>Map的定义是这样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;<span class="type">T</span>&gt;(<span class="params">transform</span>: <span class="type">Element</span> -&gt; <span class="type">T</span>)</span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">		<span class="keyword">var</span> result: [<span class="type">T</span>] <span class="operator">=</span> []</span><br><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">			result.append(transform(x))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在调用的时候，我们就需要提供一个变换方法的闭包。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.map &#123; <span class="variable">$0</span>.lowercaseString &#125; <span class="regexp">//</span> [<span class="string">&quot;vivien&quot;</span>, <span class="string">&quot;marlon&quot;</span>, <span class="string">&quot;kim&quot;</span>]</span><br></pre></td></tr></table></figure>

<h5 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h5><p>关于 Reduce 官网的描述是：</p>
<blockquote>
<p>Returns the result of combining the elements of the sequence using the given closure.</p>
</blockquote>
<p>翻译过来是：返回组合运算的结果，组合运算是由提供的序列经过闭包处理每个元素产生的。</p>
<p><code>func reduce&lt;Result&gt;(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -&gt; Result) rethrows -&gt; Result</code></p>
<h5 id="泛型和-Any-类型"><a href="#泛型和-Any-类型" class="headerlink" title="泛型和 Any 类型"></a>泛型和 Any 类型</h5><p>除了泛型，Swift 还支持 Any 类型，它能代表任何类型的值。泛型可以用于定义灵活的函数，类型检查仍然由编译器负责；而 Any 类型则可以避开 Swift 的类型系统（<strong>所以应该尽可能避免使用</strong>）。</p>
<p>泛型函数的类型十分丰富，这里我们可以考虑一下上一章对自定义函数组合运算符 &gt;&gt;&gt; 的泛型实现:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">infix operator &gt;&gt;|: pro</span><br><span class="line">precedencegroup pro &#123;</span><br><span class="line">    associativity: left</span><br><span class="line">&#125;</span><br><span class="line">func &gt;&gt;|&lt;A, B, C&gt;<span class="function"><span class="params">(f: @escaping (A) -&gt; (B), g: @escaping (B) -&gt; (C))</span> -&gt;</span> <span class="function"><span class="params">(A)</span> -&gt;</span> (C) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; x <span class="keyword">in</span> g(f(x))&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = addOne(describe: <span class="string">&quot;1&quot;</span>) &gt;&gt;| addTwo(describe: <span class="string">&quot;2&quot;</span>) &gt;&gt;| addThree(describe: <span class="string">&quot;3&quot;</span>)</span><br><span class="line">result(<span class="number">10</span>) <span class="regexp">// 16</span></span><br></pre></td></tr></table></figure>

<h4 id="可选值"><a href="#可选值" class="headerlink" title="可选值"></a>可选值</h4><p><code>??</code> 运算符的简易定义是这样的：</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">infix operator ??</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> ??&lt;T&gt;(lhs: T?, rhs: T) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">result</span> = lhs &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rhs</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="literal">result</span>: <span class="type">Int</span>? = &#123; <span class="keyword">return</span> <span class="keyword">nil</span> &#125;()</span><br><span class="line"><span class="literal">result</span> ?? <span class="number">100</span>		// <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p><code>??</code> 运算符提供了一个相比于强制可选解包更安全的替代，并且不像可选绑定一样繁琐。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hghostd.top/2018/01/01/2017%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hGhostD.github.io/images/avatar.gif">
      <meta itemprop="name" content="你谁啊~">
      <meta itemprop="description" content="心有猛虎，嗷嗷待哺！嗷呜~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咱俩谁跟谁啊~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hGhostD.github.io/2018/01/01/2017%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">2017年末总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-01 22:34:53" itemprop="dateCreated datePublished" datetime="2018-01-01T22:34:53+08:00">2018-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-01 22:49:21" itemprop="dateModified" datetime="2021-01-01T22:49:21+08:00">2021-01-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hGhostD.github.io/categories/%E6%97%A5%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">日记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>忽然之间 2017 年就已经一去不复返了，这一年应该是从毕业以来感觉过的最快的一年了,虽然也才毕业没多久。这一年感觉发生了很多的事情，忽然就已经到了年末。开始试着总结一下今年的事情吧。</p>
<!---more---->
<p>17年初，由于上家公司的裁员，便早早休了春节，也算是之前加了那么久的班给我发了一个很长的假，可惜没有工资（笑）。过年后也在成都找了一段时间的工作，不过还是没遇到合适的啊，看来 iOS 的行情还是很严峻啊。一个人在外地还是辛苦些，便有了想回家工作的想法，3月份就从成都回到了沈阳。和一起在成都租住的大学同学们也算正式告别了，再相聚可能就要等谁结婚了吧。</p>
<p>回到沈阳了还是感觉亲切些，毕竟这是我生活了20多年的地方。找工作倒也还算是顺利，虽然沈阳的公司确实挺少的，面试机会并不多，但好在还算找到了一个比较满意的公司。新公司并不是很忙碌，工作量也并不是很大，这正是我希望的。因为这样我就有时间去学习去思考新的技术，今年的收获还是蛮大的，公司因开发的项目可以使用 Swift，正好也学习了一下苹果新推出的开发语言。之前还是对 Swift 比较抵触的，觉得用好了 Objective-C 就可以了，完全没有必要去学习使用 Swift。不过了解了 Swift 之后才发现，这一定是将来的趋势，Objective-C 被淘汰的时间可能会比想象中的要快，反正现在要我去重新写 Objective-C 的项目，我应该会十分抗拒吧，哈哈。
<p>今年学习到的新内容真的挺多的，也幸好在这家公司。让我有精力去学习去思考新技术，不光学习了 Swift，还让我学习到了响应式编程、函数式编程，了解使用 RxSwift 这个牛逼的框架。也去仔细思考了在开发时使用更合理的设计模式，重新复习了一下 C 语言，现在一想在学校的时候还是太偷懒了，如果当时很认真的去学习的话，可能现在的水平会更上一层。对了还学习了一下汇编，不过今年只学习了异步，2018还是要把下半本书继续啃完，也不知道自己能消化多少。哦对了，还有自己搭建了自己的VPS，自已一直想用VPS赚一些外快，可惜一直没找到什么门路，来年在学习看看吧。今年给我最大的收获应该就是知道自己还有很多不足，需要不断地学习，之前实在是浪费了大把的时间，没有在学校的时候把基础打牢，到用的时候明显不够用了。</p>
<p>2017年还是蛮充实的一年的，算是指引了我以后想走的路。2018年我会去哪里呢？我想应该不再是家里了吧，2017年就当是休息充电的一年，在家里还是太过安逸了，我还是想去外边的城市看看，去了解最新的技术，去接触更加优秀的人。想让自己变得优秀，最简单的方法就是多和优秀的人接触，对此，我是深信不疑的。2018年我想应该还是做 iOS 开发吧，不过我还是希望能做 iOS 安全逆向的一些工作，虽然在这方面我没有什么经验，不过总要向着自己希望的方向走吧。2018 年我也希望能够做一些 MAC 软件的开发，听说苹果公司决定以后手机和电脑的开发平台整合到一起，也就是说手机开发也能够直接进行系统软件的开发了。这可能在 2018 年不会实现，但是以后肯定是会实现的，早些了解总没有什么坏处。</p>
<p>最后，就这样吧。2018年了，我也27岁了。听起来有些可怕啊。怎么突然20多岁就快要过完了呢？身边的同事也都比我小2岁以上了，时间好快啊。</p>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hghostd.top/2017/12/18/%E3%80%8ASwift%20%E8%BF%9B%E9%98%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hGhostD.github.io/images/avatar.gif">
      <meta itemprop="name" content="你谁啊~">
      <meta itemprop="description" content="心有猛虎，嗷嗷待哺！嗷呜~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咱俩谁跟谁啊~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hGhostD.github.io/2017/12/18/%E3%80%8ASwift%20%E8%BF%9B%E9%98%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">《Swift 进阶》读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-18 17:26:04" itemprop="dateCreated datePublished" datetime="2017-12-18T17:26:04+08:00">2017-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-01-15 17:19:37" itemprop="dateModified" datetime="2018-01-15T17:19:37+08:00">2018-01-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hGhostD.github.io/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>Swift 既是一门高层级语言，又是一门低层级语言。Swift 是一门多范式语言。 
</code></pre>
<p>使用 Swift 也有一段时间了，这本书作为一门进阶用书写的十分优秀，翻译也十分浅显易懂。把学到内容作为笔记记录下来，也方便以后查看。</p>
<!---more--->
<h5 id="第一章-介绍"><a href="#第一章-介绍" class="headerlink" title="第一章 介绍"></a>第一章 介绍</h5><p>这一章倒是并没有介绍太过深奥的内容，知识介绍了一些对 Swift 语言的整体印象，以及在使用过程中经常会遇到的术语，这些和其他编程语言都是通用的，就不一一列举出来了。就列出一些平常自己不知道的内容了。</p>
<blockquote>
<p>在程序语言的论文里，<code>==</code> 有时候被称为结构相等，而 <code>===</code> 则被称为<strong>指针相等</strong>或者<strong>引用相等</strong>。</p>
</blockquote>
<p>高阶函数：</p>
<blockquote>
<p>如果一个函数接受别的函数作为参数，或者一个函数的返回值是函数，那么这样的函数就叫作<strong>高阶函数</strong>。</p>
</blockquote>
<h5 id="第二章-内建集合类型"><a href="#第二章-内建集合类型" class="headerlink" title="第二章 内建集合类型"></a>第二章 内建集合类型</h5><h6 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h6><p><strong>运算符也是函数</strong><br>所以:<br><code>let sum = fibs.reduce(0) &#123; totle, num in totle + num&#125;</code><br>完全等价于<br><code>let sum = fibs.reduce(0, +)</code><br>reduce 的具体实现是:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;<span class="type">Result</span>&gt;(<span class="keyword">_</span> <span class="params">initialResult</span>: <span class="type">Result</span>, <span class="keyword">_</span> <span class="params">nextPartialResult</span>: (<span class="type">Result</span>, <span class="type">Element</span>) -&gt; <span class="type">Result</span>)</span> -&gt; <span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="operator">=</span> initialResult</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            result <span class="operator">=</span> <span class="keyword">try</span> nextPartialResult(result, x)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h6><p>flatMap 和 map 类似，但是它们直接的区别是 faltMap 返回的是另一个数组，而不是单独的元素。<br>flatMap 的具体实现是:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;<span class="type">SegmentOfResult</span> : <span class="type">Sequence</span>&gt;(</span></span><br><span class="line"><span class="function">        <span class="keyword">_</span> <span class="params">transform</span>: (<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">SegmentOfResult</span></span></span><br><span class="line"><span class="function">        )</span> <span class="keyword">rethrows</span> -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> result: [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            result.append(contentsOf: <span class="keyword">try</span> transform(element))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="常用的函数参数"><a href="#常用的函数参数" class="headerlink" title="常用的函数参数"></a>常用的函数参数</h6><ul>
<li>map 和 flatMap 对元素进行变换。</li>
<li>filter 元素是否应该被包含在结果中。</li>
<li>reduce 将元素河滨到一个总和的值中。</li>
<li>sequence 序列中下一个元素。</li>
<li>forEach 对每一个元素进行操作。</li>
<li>sort 对元素进行排序。</li>
<li>index, contains 元素符合某个条件。</li>
<li>min max 元素中最小值和最大值。</li>
<li>starts 元素是否相等。</li>
<li>split 切割元素。</li>
</ul>
<h5 id="第三章-集合类型协议"><a href="#第三章-集合类型协议" class="headerlink" title="第三章 集合类型协议"></a>第三章 集合类型协议</h5><h6 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h6><p>Sequence 协议是集合类型结构中的基础。一个序列（Sequence）代表的是一系列具有相同类型的值，你可以对这些值进行迭代。遍历一个序列最简单的方式是使用 for 循环。<br>这个函数有两个版本：<br>第一种方法：<code>sequence(first: next:)</code>。将使用第一个参数的值作为序列的首个元素，并使用 <code>next</code> 参数传入的闭包生成序列的后续元素。这里先定义一个 next 的闭包，用来生成一个随机数且要比前一个数小，到零为止:</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let calculte = &#123; (previouse: <span class="type">UInt32</span>) -&gt; UInt32? <span class="keyword">in</span></span><br><span class="line">    let <span class="keyword">new</span><span class="type">Value</span> = arc4random_uniform(previouse)</span><br><span class="line">    guard <span class="keyword">new</span><span class="type">Value</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;<span class="keyword">return</span> nil&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好这个 next 闭包，就能够直接构建好一个 Sequence。<code>let randomNumbsers = sequence(first: 100, next: calculte)</code>。其中定义好初始化数据 first 为 100。<br><code>Array(randomNumbsers) // [100, 56, 9, 6, 3, 2]</code><br>第二个方法：<code>sequence(state: next:)</code>。因为它可以在两次 next 闭包被调用之间保存任意的可变状态，所以它更强大一些。这里我们通过它来创建一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波那契序列</a>:</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let calculte2 = &#123; (<span class="keyword">state</span>: inout (Int, Int)) -&gt; Int? <span class="keyword">in</span></span><br><span class="line">    let result = <span class="keyword">state</span>.<span class="number">0</span></span><br><span class="line">    <span class="keyword">state</span> = (<span class="keyword">state</span>.<span class="number">1</span>, <span class="keyword">state</span>.<span class="number">0</span> + <span class="keyword">state</span>.<span class="number">1</span>)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义初始数据为一个元组 (0, 1)，再将这个元素传递给 next，然后取出元组中第一个数据，并修改元组数据:第一个数据 -&gt; 第二个数据，第二个数据 -&gt; 第一个与第二个数据的和。<br><code>fibs = sequence(state: (0, 1), next: calculte2)</code>。<br><code>Array(fibs.prefix(10)) // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</code></p>
<blockquote>
<p><code>sequence(first:next:)</code> 和 <code>sequence(state:next:)</code> 的返回值类型是 <code>UnfoldSequence</code>。这个术语来自函数式编程，在函数式编程中，这种操作为成为展开(unfold)。sequence 是和 reduce 对应的(在函数式编程中 reduce 有常被叫做 fold)。reduce 将一个序列缩减(或者说折叠)为一个单一的返回值，而 sequence 则将一个单一的值展开形成一个序列。</p>
</blockquote>
<h5 id="第四章-可选值"><a href="#第四章-可选值" class="headerlink" title="第四章 可选值"></a>第四章 可选值</h5><h6 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h6><p>使用 <code>if let</code> 来进行可选绑定(optional binding)要比使用 <code>switch</code> 语句稍好一些。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> urlString = <span class="string">&quot;http://www.objc.io/logo.png&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> url = <span class="constructor">URL(<span class="params">string</span>: <span class="params">urlString</span>)</span>,</span><br><span class="line">	<span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="constructor">Data(<span class="params">contentsOf</span>: <span class="params">url</span>)</span>,</span><br><span class="line">	<span class="keyword">let</span> image = <span class="constructor">UIImage(<span class="params">data</span>: <span class="params">data</span>)</span> </span><br><span class="line">&#123;	</span><br><span class="line">	<span class="keyword">let</span> view = <span class="constructor">UIImageView(<span class="params">image</span>: <span class="params">image</span>)</span></span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">PlaygroundPage</span>.</span></span>current.liveView = view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="while-let"><a href="#while-let" class="headerlink" title="while let"></a>while let</h6><p><code>while let </code> 和 <code>if let</code> 非常相似，它代表一个当遇到 nil 时终止的循环。注意，一旦条件为 false，循环就会停止(也许你错误地认为 where 条件会像 filter 那样工作，其实不然)。</p>
<h6 id="nil-合并运算"><a href="#nil-合并运算" class="headerlink" title="nil 合并运算"></a>nil 合并运算</h6><p><code>??</code> 和 Objective-C 中的 <code>?:</code> 十分相似，但是它们还是有不同的地方，那就是 Swift 中的可选值<strong>不是指针</strong>。<br>我们可以对 Array 进行扩展来包含检查索引值是否在数组边界内:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">safe</span> <span class="params">idx</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> idx <span class="operator">&lt;</span> endIndex <span class="operator">?</span> <span class="keyword">self</span>[idx] : <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在就可以这样写</span></span><br><span class="line">array[safe: <span class="number">5</span>] <span class="operator">??</span> <span class="number">0</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>合并操作也能够进行链接—-如果有多个可能的可选值，并且想要选择第一个非 nil 的值，则可以将他们按顺序合并:</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i: <span class="built_in">Int</span>? = nil</span><br><span class="line"><span class="keyword">let</span> j: <span class="built_in">Int</span>? = nil</span><br><span class="line"><span class="keyword">let</span> k: <span class="built_in">Int</span>? = <span class="number">42</span></span><br><span class="line">i ?? j ?? k <span class="comment">// Optional(42)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="第五章-结构体和类"><a href="#第五章-结构体和类" class="headerlink" title="第五章 结构体和类"></a>第五章 结构体和类</h5><h6 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h6><p>结构体(和枚举)是<strong>值类型</strong>，而类是<strong>引用类型</strong>。因为结构体只有一个持有者，所以它不可能造成引用循环。而对于类和函数这样的引用类型，我们需要特别小心，避免造成引用循环的问题。<br>如果想要将两个 Point 相加，则可以对 + 操作符进行重载。在方法中，我们可以将成员相加，并返回新的 Point:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func +(lhs: Point, rhs: Point) -&gt; Point &#123;</span><br><span class="line">	return <span class="constructor">Point(<span class="params">x</span>: <span class="params">lhs</span>.<span class="params">x</span> + <span class="params">rhs</span>.<span class="params">x</span>, <span class="params">y</span>: <span class="params">lhs</span>.<span class="params">y</span> + <span class="params">rhs</span>.<span class="params">y</span>)</span></span><br><span class="line">&#125;</span><br><span class="line">screen.origin + <span class="constructor">Point(<span class="params">x</span>: 10, <span class="params">y</span>: 10)</span> <span class="comment">// (x: 20, y: 20)</span></span><br></pre></td></tr></table></figure>
<p>如果想要改变 self，或者嵌套的(比如 self.origin.x)任何属性，就需要将方法标记为 <code>mutating</code>。只有使用了这个关键字，我们才能在方法内部进行改变。<br>Swift 的结构体一般被存储在栈上，而非堆上。如果结构体太大，它也会被存储在堆上。</p>
<h6 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h6><p>为了打破循环引用，需要保证闭包不去引用视图。通过使用<strong>捕获列表</strong>并将捕获变量 view 标记为 weak 或者 unowned 来达到这个目的。</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">window</span>?onRotate = &#123; [weak <span class="meta">view</span>] <span class="meta">in</span></span><br><span class="line">	p<span class="meta">rint(</span><span class="string">&quot;We now also need to update the view: \(view)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h5><ol>
<li>函数可以像 Int 或者 String 那样被赋值给变量，也可以作为另一个函数的输入参数，或者另一个函数的返回值来使用。</li>
<li>函数能够<strong>捕获</strong>存在于其作用域之外的变量。</li>
<li>有两种方法可以创建函数，一种是使用 func 关键字，另一种是 { }。在 Swift 中，后一种被称为闭包表达式。</li>
</ol>
<h5 id="第七章-字符串"><a href="#第七章-字符串" class="headerlink" title="第七章 字符串"></a>第七章 字符串</h5><p>这一章主要介绍了 String，但是书中还是介绍 Swift3.0 的版本，而最新的 Swift4.0 对此更改了很多。我就直接记录一些 String 的变化吧。<br>String 现在已经更改为一个集合类型了，所以现在直接废除了 <code>.characters</code> 这个属性了。其他的操作也都遵循了 Collection 协议了。</p>
<h5 id="第八章-错误处理"><a href="#第八章-错误处理" class="headerlink" title="第八章 错误处理"></a>第八章 错误处理</h5><h6 id="抛出和捕获"><a href="#抛出和捕获" class="headerlink" title="抛出和捕获"></a>抛出和捕获</h6><p>Swift 没有使用返回 Result 的方法来表示失败，而是将方法标记为 throws。Result 是作用于类型上的，而 throw 是作用于函数的。</p>
<p>如果我们想要在错误中给出更多的信息，则可以使用带有关联值的枚举。(任何遵循 Error 协议的类型都可以被抛出函数作为错误抛出。)</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> LoginError: <span class="built_in">Error</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> wrongUser</span><br><span class="line">    <span class="keyword">case</span> passwordError(user: <span class="built_in">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>你可以指定你的函数可能抛出的具体错误类型，但这并不是必须的。因为现在 Swift 中的<strong>错误类型是无类型的</strong>，所以通过文档来说明你的函数会抛出怎样的错误是非常重要的。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span>(<span class="params">user</span>: <span class="type">String</span>, <span class="params">passWord</span>: <span class="type">String</span>)</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user.isEmpty &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">LoginError</span>.wrongUser</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> passWord <span class="operator">!=</span> <span class="string">&quot;123&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">LoginError</span>.passwordError(user: user)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;登录成功！！！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> login(user: <span class="string">&quot;hu&quot;</span>, passWord: <span class="string">&quot;111&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span> <span class="type">LoginError</span>.wrongUser &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;用户不存在&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span> <span class="type">LoginError</span>.passwordError(<span class="keyword">let</span> id) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(id)</span>的密码输入错误！！！&quot;</span>) <span class="comment">// hu的密码输入错误！！！</span></span><br><span class="line">&#125;<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，在 Swift 中，我们虽然把这块内容叫做“异常”，但是实质上它更多的还是“错误”而非真正意义上的异常。</p>
<h6 id="使用-defer-进行清理"><a href="#使用-defer-进行清理" class="headerlink" title="使用 defer 进行清理"></a>使用 defer 进行清理</h6><p>Swift 中的 <code>defer</code> ，围绕的代码块一定会在函数返回时被执行（就是相当于在 return 之后再执行一些操作）。<br><code>defer</code> 类似于其他语言的 <code>finally</code>，但是 <code>defer</code> 不只是用于错误处理，可以将 <code>defer</code> 放在代码块的任意地方。<br>如果同一个作用域里使用多个 <code>defer</code>，那么它们会被逆序执行，可以把它想象成一个栈。用意在于，比如我们开启数据库然后连接，用 <code>defer</code> 就能自然的先关闭连接，再关闭数据库。</p>
<h6 id="高阶函数和错误"><a href="#高阶函数和错误" class="headerlink" title="高阶函数和错误"></a>高阶函数和错误</h6><p>刚才我们就已经看出来了，在实际使用 Swift 中，经常能遇到网络请求这种异步处理错误的情况，如果按照刚才的写法，就是使用 <code>throws</code> 来捕获异常进行处理，这并不是一个好的方法，通常也不建议这么使用，因为可选值和 <code>Result</code> 作用于类型，而 <code>throws</code> 只对函数类型起效。将一个函数标注为 throws 意味着这个函数可能会失败。所以为了解决异步处理产生的问题，默认的规则就是定义 <code>Result&lt;T&gt;</code>：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">enum</span> <span class="variable"><span class="class">Result</span></span>&lt;<span class="variable">T</span>&gt; &#123;</span><br><span class="line">    <span class="variable">case</span> <span class="function"><span class="title">success</span>(<span class="variable">T</span>)</span></span><br><span class="line">    <span class="variable">case</span> <span class="function"><span class="title">fail</span>(<span class="variable">LoginError</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result 是异步错误处理的正确道路。不好的地方在于，如果你已经在同步函数中使用 throws 了，那么再在异步函数中转为使用 Result 将会在两种接口之间导入差异。</p>
<h5 id="第九章-泛型"><a href="#第九章-泛型" class="headerlink" title="第九章 泛型"></a>第九章 泛型</h5><h6 id="使用闭包对行为进行参数化"><a href="#使用闭包对行为进行参数化" class="headerlink" title="使用闭包对行为进行参数化"></a>使用闭包对行为进行参数化</h6><p>对 Array 进行判断，标准库中提供的 <code>contains</code> 是这么做的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">	<span class="comment">/// 根据序列是否包含满足给定断言的元素，返回一个布尔值。</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">contains</span>(<span class="params">where</span> <span class="params">predicate</span>: (<span class="type">Iterator</span>.<span class="type">Element</span>) <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>)</span></span><br><span class="line">		<span class="keyword">return</span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，它接受一个函数，这个函数从序列中取出一个元素，并对他进行一些检查。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isEven = &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line">(<span class="number">0.</span>.<span class="number">.5</span>).contains(<span class="keyword">where</span>: isEven)  <span class="comment">// ture</span></span><br><span class="line">[<span class="meta">1,3,99</span>].contains(<span class="keyword">where</span>: isEven) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h6 id="使用泛型进行代码设计"><a href="#使用泛型进行代码设计" class="headerlink" title="使用泛型进行代码设计"></a>使用泛型进行代码设计</h6><p>让我们来写一些与网络服务交互的函数。比如获取用户列表的数据，并解析为 User 数据类型。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func load<span class="constructor">Users(<span class="params">callback</span>: ([User]?)</span> -&gt; <span class="literal">()</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> usersURL = webserviceURL.appending<span class="constructor">PathComponent(<span class="string">&quot;/users&quot;</span>)</span></span><br><span class="line">	<span class="keyword">let</span> data = <span class="keyword">try</span>? <span class="constructor">Data(<span class="params">contentsOf</span>: <span class="params">usersURL</span>)</span></span><br><span class="line">	<span class="keyword">let</span> json = data.flatMap &#123;</span><br><span class="line">		<span class="keyword">try</span>? <span class="module-access"><span class="module"><span class="identifier">JSONSerialization</span>.</span></span>json<span class="constructor">Object(<span class="params">with</span>: $0, <span class="params">options</span>: [])</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> users = (json <span class="keyword">as</span>? <span class="literal">[A<span class="identifier">ny</span>]</span>).flatMap &#123; jsonObject <span class="keyword">in</span></span><br><span class="line">		jsonObject.flat<span class="constructor">Map(User.<span class="params">init</span>)</span></span><br><span class="line">	&#125;</span><br><span class="line">	callback(users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数会发生三种错误情况：URL 加载可能失败，JOSN解析可能失败，通过 JSON 数组构建用户对象也可能失败。</p>
<p>现在，如果我们想要写一个相同的函数来加载其他资源。比如，我们需要一个加载博客文章的函数，它看起来是这样的：</p>
<p><code>func loadBlogPosts(callback: ([BlogPost])? -&gt; ())</code><br>此函数的实现和前面的用户函数几乎相同。相比于复制和粘贴，将函数中 User 相关的部分提取出来，将其他部分进行重用，会是更好的方式。</p>
<h5 id="第十章-协议"><a href="#第十章-协议" class="headerlink" title="第十章 协议"></a>第十章 协议</h5><h6 id="面向协议编程和协议拓展"><a href="#面向协议编程和协议拓展" class="headerlink" title="面向协议编程和协议拓展"></a>面向协议编程和协议拓展</h6><p>假设我们有一个只有 String 属性的 结构体 Obj</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value <span class="operator">=</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">str</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> num <span class="operator">=</span> <span class="type">Int</span>(value) <span class="operator">??</span> <span class="number">0</span> <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        value <span class="operator">=</span> <span class="type">String</span>(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们想通过协议的方式对一个 String 进行加一操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">transform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addOne</span>(<span class="params">str</span>: <span class="type">String</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要对结构体 Obj 进拓展并具体实现加一方法，来满足协议:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension Obj: transform &#123;</span><br><span class="line">    mutating func add<span class="constructor">One(<span class="params">str</span>: String)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> n1 = <span class="constructor">Int(<span class="params">str</span>)</span> ?? <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> n2 = <span class="constructor">Int(<span class="params">value</span>)</span> ?? <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> tmp = n1 + n2</span><br><span class="line">        value = <span class="constructor">String(<span class="params">tmp</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在只需要假设 content 是满足协议的，就可以实现独立的方法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="attribute">content</span>: transform = <span class="built_in">Obj</span>(value: <span class="string">&quot;1&quot;</span>)</span><br><span class="line">content.<span class="built_in">addOne</span>(str: <span class="string">&quot;2&quot;</span>) 		// <span class="built_in">Obj</span>(value: <span class="string">&quot;3&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>除此之外，同样可以通过协议拓展的方式。</p>
<h6 id="协议内幕"><a href="#协议内幕" class="headerlink" title="协议内幕"></a>协议内幕</h6><p>当我们通过协议类型创建一个变量时，这个变量会被包装到一个叫存在容器的盒子中。<br>使用泛型参数确实要比使用协议类型高效的多。通过使用泛型参数，可以避免隐式的泛型封装。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式打包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printProtocol</span>(<span class="params">array</span>: [<span class="type">CustomStringConvertible</span>])</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(array)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有打包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printGeneric</span>&lt;<span class="type">A</span>: <span class="type">CustomStringConvertible</span>&gt;(<span class="params">array</span>: [<span class="type">A</span>])</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hghostd.top/2017/11/20/Swift%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hGhostD.github.io/images/avatar.gif">
      <meta itemprop="name" content="你谁啊~">
      <meta itemprop="description" content="心有猛虎，嗷嗷待哺！嗷呜~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咱俩谁跟谁啊~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hGhostD.github.io/2017/11/20/Swift%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95/" class="post-title-link" itemprop="url">Swift协议拓展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-20 16:29:11" itemprop="dateCreated datePublished" datetime="2017-11-20T16:29:11+08:00">2017-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-11-21 15:04:07" itemprop="dateModified" datetime="2017-11-21T15:04:07+08:00">2017-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hGhostD.github.io/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>很多时候都会对 UI 进行自定义设置，之前使用 Objective-C 的时候都是用分类来自定义方法，而 Swift 提供了拓展可以更方便的来处理。看过一篇关于 UI 链式编程的博客，发现实现思路很棒，这里来学习一下。</p>
<!--- more --->
<h4 id="简单实现方式"><a href="#简单实现方式" class="headerlink" title="简单实现方式"></a>简单实现方式</h4><p>要对 UI 进行拓展可以直接使用 extension 添加自定的方法。但是这么做的话感觉不够帅气！</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span>: <span class="title">ViewChainable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">adhere</span>(<span class="keyword">_</span> <span class="params">toSupView</span>: <span class="type">UIView</span>)</span> -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        toSupView.addSubview(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 @discardableResult 关键字可以让 XCode 忽略返回值警告</span></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">layout</span>(<span class="params">snapKitMaker</span>: (<span class="type">ConstraintMaker</span>) -&gt; <span class="type">Void</span>)</span> -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.snp.makeConstraints &#123;</span><br><span class="line">            snapKitMaker(<span class="variable">$0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就给算给 UIView 添加了 <code>adhere()</code> 和 <code>layout()</code> 方法。虽然只是给父视图添加自身和 SnapKit 布局，但是简单的思路就是在 extension 中添加自定义方法。<br>假设我们现在需求如下：创建一个 UILabel，背景色为透明，字体为20，文字颜色为黑灰，默认文字为 Label。<br>如果我们用刚才的思路就是在 extension 中添加一个 <code>config()</code> 方法把我们刚才的设定都放进去，然后创建一个 UILabel 调用拓展方法。这么做当然可以，但是不够灵活也不够帅气！！！在 Swift 中可以使用闭包和协议，这些问题就能够很好的解决。<br>首先定义一个空的协议。然后对这个协议进行拓展，并且限定 UIView 遵循这个协议。最后就能够在拓展里添加方法，方法的参数是一个闭包，传递自身。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ViewChainable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewChainable</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">config</span>(<span class="keyword">_</span> <span class="params">config</span>: (<span class="keyword">Self</span>) -&gt; <span class="type">Void</span>)</span> -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        config(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些协议和拓展设置完成就算是能够对 UI 进行链式编程了。简单的实现如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let <span class="selector-tag">label</span> = UILabel()</span><br><span class="line">    <span class="selector-class">.adhere</span>(toSuperView: view)</span><br><span class="line">    <span class="selector-class">.layout</span> &#123; (make) <span class="keyword">in</span></span><br><span class="line">        make<span class="selector-class">.top</span><span class="selector-class">.equalToSuperview</span>()<span class="selector-class">.offset</span>(<span class="number">80</span>)</span><br><span class="line">        make<span class="selector-class">.centerX</span><span class="selector-class">.equalToSuperview</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.config</span> &#123; (label) <span class="keyword">in</span></span><br><span class="line">        <span class="selector-tag">label</span><span class="selector-class">.backgroundColor</span> = UIColor<span class="selector-class">.clear</span></span><br><span class="line">        <span class="selector-tag">label</span><span class="selector-class">.font</span> = UIFont<span class="selector-class">.systemFont</span>(ofSize: <span class="number">20</span>)</span><br><span class="line">        <span class="selector-tag">label</span><span class="selector-class">.textColor</span> = UIColor<span class="selector-class">.darkGray</span></span><br><span class="line">        <span class="selector-tag">label</span><span class="selector-class">.text</span> = <span class="string">&quot;Label&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>关于我们的需求，看起来好像没有更好的处理，也需要在每个 lable 中进行单独的设置。但是不要忘记了，我们的 <code>config()</code> 方法中传递的是一个<strong>闭包</strong>，也就是说可以抽象出设置方法作为参数传递给多个 label。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let labelConfiger = &#123; (<span class="selector-tag">label</span>: UILabel) <span class="keyword">in</span></span><br><span class="line">    <span class="selector-tag">label</span><span class="selector-class">.backgroundColor</span> = UIColor<span class="selector-class">.clear</span></span><br><span class="line">    <span class="selector-tag">label</span><span class="selector-class">.font</span> = UIFont<span class="selector-class">.systemFont</span>(ofSize: <span class="number">20</span>)</span><br><span class="line">    <span class="selector-tag">label</span><span class="selector-class">.textColor</span> = UIColor<span class="selector-class">.darkGray</span></span><br><span class="line">    <span class="selector-tag">label</span><span class="selector-class">.text</span> = <span class="string">&quot;Label&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">label</span><span class="selector-class">.config</span>(labelConfiger)</span><br></pre></td></tr></table></figure>
<p>这个时候如果还有一个 label2。我们就可以给 label2 直接传递定义好的闭包 <code>labelConfiger</code>。如果 label2 的 text 需要传递不同的内容，实现起来也很容易，只需要再次传递一个 <code>config()</code> 就可以了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">label</span><span class="selector-class">.config</span>(labelConfiger)</span><br><span class="line">    <span class="selector-class">.config</span> &#123; (label) <span class="keyword">in</span></span><br><span class="line">        <span class="selector-tag">label</span><span class="selector-class">.text</span> = <span class="string">&quot;Label1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">label2<span class="selector-class">.config</span>(labelConfiger)</span><br><span class="line">    <span class="selector-class">.config</span> &#123; (label) <span class="keyword">in</span></span><br><span class="line">        <span class="selector-tag">label</span><span class="selector-class">.text</span> = <span class="string">&quot;Label2&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其实做到这里，也会发现**链式函数的关键就在于<font color=#d13f28>返回值类型与自身相同</font>**。</p>
<h4 id="很帅气的实现方式"><a href="#很帅气的实现方式" class="headerlink" title="很帅气的实现方式"></a>很帅气的实现方式</h4><p>在使用 RxSwift 的时候就觉得自定义 .rx 的方式很帅，但是一直不知道如何实现的。知道看过了牛人的 blog 才发现实现起来蛮简单的，但是不那么好理解，接下来就按照他的思路一步步整理一下。<br>首先肯定是定义一个协议，这个协议的作用就是对需要封装的内容进行拓展，定义一个自定义参数。这里使用 <code>hu</code> 作为拓展属性的名称。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">HUNamespaceProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// - associatedtype 关键字 用来在协议中表达参数化类型</span></span><br><span class="line">    <span class="comment">/// - 定义 HUNameType 为协议中的参数类型</span></span><br><span class="line">    <span class="keyword">associatedtype</span> nameType</span><br><span class="line">    <span class="keyword">var</span> hu: nameType &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> hu: nameType.<span class="keyword">Type</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips: 协议中不能直接使用 <code>Element</code> 作为泛型关键字，需要时用 <code>associatedtype</code> 声明一个形参。<br>接下来就需要对这个协议进行拓展。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">HUNamespaceProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hu: <span class="type">HUNamespaceWrapper</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">HUNamespaceWrapper</span>(value: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> hu: <span class="type">HUNamespaceWrapper</span>&lt;<span class="keyword">Self</span>&gt;.<span class="keyword">Type</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">HUNamespaceWrapper</span>.<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">TypeWrapperProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> nameType</span><br><span class="line">    <span class="keyword">var</span> wrappedValue: nameType &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">value</span>: nameType)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 定义的泛型结构体 遵循 TypeWrapperProtocol 协议</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">HUNamespaceWrapper</span>&lt;<span class="title">T</span>&gt;: <span class="title">TypeWrapperProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> wrappedValue: <span class="type">T</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">init</span>(<span class="params">value</span>: <span class="type">T</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.wrappedValue <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对协议的属性 <code>hu</code> 进行了拓展，定义了一个泛型结构体来用来接收初始化的对象作为自身。这里有一点难懂。因为这是基于一个这个原理的。</p>
<blockquote>
<p>namespace 形式扩展的原理，就是对原类型进行一层封装。在 Swift 中，这个封装类型使用的是 Struct，然后，对这个 Struct 进行自定义的方法扩展。</p>
</blockquote>
<p>我的理解就是定义了一个泛型结构体，而这个泛型结构体遵循一个协议。这个协议规定了: 1.可以获取自身类型属性。2有一个使用自身属性初始化自身的方法。这样泛型结构体就可以通过 <code>wrappendVlaue</code> 属性来获取自身的 Type。这样当我们实现第一个协议的方法时候，规定属性 <code>hu</code> 必须继承我们定义的结构体，且通过规定好的初始化方法返回结构体对象。啊。。。还是很难懂。</p>
<p>接下来就是实现自定义的拓展方法了。这一步比较容易理解，只要让需要实现的类型遵循我们定义好的命名协议，然后在实现命名协议的扩展方法就可以了。例如下面分别给 UIView 和 String 添加了自定义方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span>: <span class="title">HUNamespaceProtocol</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">///如果对象是引用类型的(类) 如: UIView 等 就必须使用 :</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HUNamespaceWrapper</span> <span class="title">where</span> <span class="title">nameType</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">adhere</span>(<span class="keyword">_</span> <span class="params">toSuperView</span>: <span class="type">UIView</span>)</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        toSuperView.addSubview(wrappedValue)</span><br><span class="line">        <span class="keyword">return</span> wrappedValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span>(<span class="keyword">_</span> <span class="params">snapKitMaker</span>: (<span class="type">ConstraintMaker</span>) -&gt; <span class="type">Void</span>)</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        wrappedValue.snp.makeConstraints &#123;</span><br><span class="line">            snapKitMaker(<span class="variable">$0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wrappedValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">config</span>(<span class="keyword">_</span> <span class="params">config</span>: (<span class="type">T</span>) -&gt; <span class="type">Void</span>)</span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        config(wrappedValue)</span><br><span class="line">        <span class="keyword">return</span> wrappedValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>: <span class="title">HUNamespaceProtocol</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">/// 如果约束对象是值类型的 如: String, Date 等 就必须使用 ==</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HUNamespaceWrapper</span> <span class="title">where</span> <span class="title">nameType</span> == <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="keyword">_</span> <span class="params">string</span>: <span class="type">String</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hu:<span class="subst">\(string)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以很帅气的实现了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&quot;&quot;</span>.hu.test(<span class="string">&quot;123&quot;</span>)</span></span>)</span><br><span class="line">let <span class="selector-tag">button</span> = UIButton(type: .custom)</span><br><span class="line"><span class="selector-tag">button</span><span class="selector-class">.hu</span><span class="selector-class">.adhere</span>(self.view)</span><br><span class="line">    <span class="selector-class">.hu</span><span class="selector-class">.config</span>(buttonConfig)</span><br><span class="line">    <span class="selector-class">.hu</span><span class="selector-class">.layout</span> &#123;</span><br><span class="line">        $<span class="number">0</span><span class="selector-class">.center</span><span class="selector-class">.equalTo</span>(self.view)</span><br><span class="line">        $<span class="number">0</span><span class="selector-class">.width</span><span class="selector-class">.equalTo</span>(<span class="number">120</span>)</span><br><span class="line">        $<span class="number">0</span><span class="selector-class">.height</span><span class="selector-class">.equalTo</span>(<span class="number">40</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
> 参考资料
> [Swift 实践篇之链式 UI 代码](https://blog.nswebfrog.com/2017/10/20/swift-practice-ui-chaining-code/)
> [Swift 命名空间形式扩展的实现](https://blog.nswebfrog.com/2017/03/23/swift-namespace/)
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hghostd.top/2017/11/14/MVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hGhostD.github.io/images/avatar.gif">
      <meta itemprop="name" content="你谁啊~">
      <meta itemprop="description" content="心有猛虎，嗷嗷待哺！嗷呜~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咱俩谁跟谁啊~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hGhostD.github.io/2017/11/14/MVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">MVVM 设计模式笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2017-11-14 14:52:35 / 修改时间：17:20:30" itemprop="dateCreated datePublished" datetime="2017-11-14T14:52:35+08:00">2017-11-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hGhostD.github.io/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>很早就听说过 MVVM 系统模式，但是都是一知半解的。这次就借助泊学网视频重新搭建一个查看天气的项目，系统的研究一下 MVVM 设计模式。</p>
<!--- more --->
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>简易的画了一个 MVVM 设计图。整体流程如下，接下来将根据这个图进行设计。<br><img src="https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/MVVM%E6%A6%82%E8%BF%B0.jpg?raw=true" alt="MVVM"></p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>搭建好项目 Sky，并准备好图片。<img src="https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png?raw=true"><br>准备好需要的数据接口，这里使用了 <a target="_blank" rel="noopener" href="https://darksky.net/dev">DarkSky</a> 接口的。</p>
<h4 id="UI搭建-（View）"><a href="#UI搭建-（View）" class="headerlink" title="UI搭建 （View）"></a>UI搭建 （View）</h4><p>平时的项目很少都不会使用 StroyBoard，所以借着这个机会使用一下。文字不太好描述，这里直接贴图了。<img src="https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/StoryBoard.png?raw=true"><br>View 上的控件记得连接在 Controller 上！</p>
<h4 id="Model创建"><a href="#Model创建" class="headerlink" title="Model创建"></a>Model创建</h4><p>这里偷懒直接用 CuteBaby 生成了我们需要的 Model 格式。注意处理好 Model 中嵌套的 struct 名称，尽量不要重名，防止将自己弄混。</p>
<h4 id="ViewModel创建"><a href="#ViewModel创建" class="headerlink" title="ViewModel创建"></a>ViewModel创建</h4><p>ViewModel 更多的是让 Controller 从数据处理中解放出来，所以在 Controller 文件夹中单独创建 ViewModels 文件夹，并且将相关代码文件放入其中。<br>ViewModel 负责处理 Model 中传过来的数据。通过重写 set 方法将 Model 获取，并写好其他属性的 get 方法将数据向外传递。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> weather: <span class="type">WeatherData</span>! &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> weather <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.isWeatherReady <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.isWeatherReady <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> summary: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weather.currently.summary</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Controller搭建"><a href="#Controller搭建" class="headerlink" title="Controller搭建"></a>Controller搭建</h4><p>整体的业务逻辑就可以在 Controller 上进行了，最为重要的部分就是将各个部分的连通，确保能够进行数据的传递。以下几点是比较关键的部分，注意不要忘记实现。</p>
<ol>
<li>让 Controller 持有 ViewModel 对象，并重写 Set 方法来刷新 UI.</li>
<li>将 ViewModel 的数据传递给 View，保证 View 能够显示出 ViewModel 的内容。</li>
<li>让 Controller 持有 View 控件的点击方法，并能够通过代理将方法传递给其他对象。</li>
</ol>
<h4 id="处理数据逻辑、业务逻辑"><a href="#处理数据逻辑、业务逻辑" class="headerlink" title="处理数据逻辑、业务逻辑"></a>处理数据逻辑、业务逻辑</h4><p>现在四个基本的元素 M、V、VM 和 C 都已经准备完成。接下来就是关键的数据绑定了，像管道一样逐步将数据传递下去。开始调用方法请求数据就是管道的起点。在 Controller 中需要进行数据请求的地方实现下面的方法。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WeatherDataManager.shared.weatherDataAt(</span><br><span class="line">            latitude: lat,</span><br><span class="line">            longtitude: lon,</span><br><span class="line">            completion: &#123; <span class="built_in">response</span>, <span class="keyword">error</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">error</span> = <span class="keyword">error</span> &#123;</span><br><span class="line">                    dump(<span class="keyword">error</span>)</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="built_in">response</span> = <span class="built_in">response</span> &#123;</span><br><span class="line">                    self.currentWeatherViewController.viewModel?.weather = <span class="built_in">response</span></span><br><span class="line">                    self.weekWeatherViewController.viewModel = WeekWeatherViewModel(weatherData: <span class="built_in">response</span>.daily.data)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>整体的数据绑定思路如下:</p>
<ol>
<li>获取地理位置将参数传递给获取天气的方法，以此来获取数据 Model。</li>
<li>通过回调获取到 response， 就是获取到 Model 传递给 ViewModel。</li>
<li>让子页的 Controller 持有的 ViewModel 进行赋值。</li>
<li>通过重写子页 Controller 中 ViewModel 的 Set 方法，调用 <code>updateView()</code> 方法，对子页 Controller 持有的 View 进行刷新赋值。注意：关于 UI 的刷新需要在主线程中进行。</li>
</ol>
<p>至此，由 Controller -&gt; Model -&gt; ViewModel -&gt; View 的单向数据绑定已经完成。<br>接下来就是实现修改 View 上的的点击时间实现更新 Model。就是从 View -&gt; Controller -&gt; ViewModel -&gt; Model。<br>整体思路如下：</p>
<ol>
<li>由 View 控件获取点击事件，将点击方法传递(通过代理或者 Block )给 Controller。</li>
<li>修改后的数据通过 Controller 持有的 ViewModel传递。</li>
<li>修改 ViewModel 中保存的 Model。</li>
</ol>
<p>关于 MVVM 简单的双向数据绑定就算完成了，更多的使用可以借助一下三方框架，如 RxSwift。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hghostd.top/2017/11/13/Xcode%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hGhostD.github.io/images/avatar.gif">
      <meta itemprop="name" content="你谁啊~">
      <meta itemprop="description" content="心有猛虎，嗷嗷待哺！嗷呜~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咱俩谁跟谁啊~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hGhostD.github.io/2017/11/13/Xcode%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Xcode 单元测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-13 14:28:01" itemprop="dateCreated datePublished" datetime="2017-11-13T14:28:01+08:00">2017-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-01-06 10:57:32" itemprop="dateModified" datetime="2018-01-06T10:57:32+08:00">2018-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hGhostD.github.io/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有的时候很需要进行单元测试来节省开发时间。之前一直不太熟悉这一块的知识，正好整理学习一下。</p>
<!--- more --->
<h4 id="模拟网络请求"><a href="#模拟网络请求" class="headerlink" title="模拟网络请求"></a>模拟网络请求</h4><p>这里以 Sky 这个项目作为演示。模拟获取天气的网络请求方法。关键代码如下:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">enum DataManagerError: Error &#123;</span><br><span class="line">    case failedRequest</span><br><span class="line">    case invalidResponse</span><br><span class="line">    case unknown</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> WeatherData: Codable &#123;</span><br><span class="line">    <span class="keyword">let</span> latitude: Double</span><br><span class="line">    <span class="keyword">let</span> longitude: Double</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typealias CompletionHandler = (WeatherData?, DataManagerError?) -&gt; Void</span><br><span class="line">    </span><br><span class="line">func weather<span class="constructor">DataAt(<span class="params">latitude</span>: Double, <span class="params">longtitude</span>: Double, <span class="params">completion</span>: @<span class="params">escaping</span> CompletionHandler)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> url = baseURL.appending<span class="constructor">PathComponent(<span class="string">&quot;\(latitude), \(longtitude)&quot;</span>)</span></span><br><span class="line">        var request = <span class="constructor">URLRequest(<span class="params">url</span>: <span class="params">url</span>)</span></span><br><span class="line">        </span><br><span class="line">        request.set<span class="constructor">Value(<span class="string">&quot;application/json&quot;</span>, <span class="params">forHTTPHeaderField</span>: <span class="string">&quot;Content-Type&quot;</span>)</span></span><br><span class="line">        request.httpMethod = <span class="string">&quot;GET&quot;</span></span><br><span class="line">        </span><br><span class="line">        self.urlSession.data<span class="constructor">Task(<span class="params">with</span>: <span class="params">request</span>)</span> &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">            self.did<span class="constructor">FinishGettingWeatherData(<span class="params">data</span>: <span class="params">data</span>, <span class="params">response</span>: <span class="params">response</span>, <span class="params">error</span>: <span class="params">error</span>, <span class="params">completion</span>: <span class="params">completion</span>)</span></span><br><span class="line">        &#125;.resume<span class="literal">()</span></span><br><span class="line">    &#125;</span><br><span class="line">func did<span class="constructor">FinishGettingWeatherData(<span class="params">data</span>: Data?, <span class="params">response</span>: URLResponse?, <span class="params">error</span>: Error?, <span class="params">completion</span>: CompletionHandler)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> _ = error &#123;</span><br><span class="line">            completion(nil, .failedRequest)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> data = data, <span class="keyword">let</span> response = response <span class="keyword">as</span>? HTTPURLResponse &#123;</span><br><span class="line">            <span class="keyword">if</span> response.statusCode<span class="operator"> == </span><span class="number">200</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> weatherData = <span class="keyword">try</span> <span class="constructor">JSONDecoder()</span>.decode(<span class="module-access"><span class="module"><span class="identifier">WeatherData</span>.</span></span>self, from: data)</span><br><span class="line">                    completion(weatherData, nil)</span><br><span class="line">                &#125;catch &#123;</span><br><span class="line">                    completion(nil, .invalidResponse)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                completion(nil, .failedRequest)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            completion(nil, .unknown)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中包括 3 个关键的可变对象： self.urlSession、request 和  completion。我们就需要单独对这 3 个数据进行模拟。<br>模拟结果分为 3 种：</p>
<ol>
<li>是否能获取到网络数据。(success)</li>
<li>获取网络数据失败。 (failedRequest)</li>
<li>无效的网络响应。 (invalidResponse)</li>
</ol>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>创建好 Tests 文件。在此需要引入头文件来确保可以调用工程中的对象方法 <code>@testable import Sky</code>。在测试文件中，测试方法总是以 test 作为方法名的开头。</p>
<h4 id="测试能否获取网络数据"><a href="#测试能否获取网络数据" class="headerlink" title="测试能否获取网络数据"></a>测试能否获取网络数据</h4><p>想要测试能否获取数据，self.urlSession 就不需要特意模拟，request 可以任意给经纬度进行拼接。最后获取 completion 中的 WeatherData,查看是否拥有数据。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func test<span class="constructor">_weatherDataAt_gets_data()</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> expect = expectation(description: <span class="string">&quot;Loading data form \(API.authenticatedUrl)&quot;</span>)</span><br><span class="line">        var data: WeatherData? = nil</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">WeatherDataManager</span>.</span></span>shared.weather<span class="constructor">DataAt(<span class="params">latitude</span>: 52, <span class="params">longtitude</span>: 100)</span> &#123; (response, error) <span class="keyword">in</span></span><br><span class="line">            data = response</span><br><span class="line">            expect.fulfill<span class="literal">()</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        wait<span class="constructor">ForExpectations(<span class="params">timeout</span>: 5, <span class="params">handler</span>: <span class="params">nil</span>)</span></span><br><span class="line">        <span class="constructor">XCTAssertNotNil(<span class="params">data</span>)</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里使用 <code>expectation</code> 来进行异步测试，当网络回调结果时候调用 <code>expect.fulfill()</code> 表示异步完成。否则调用 <code>waitForExpectations(timeout: 5, handler: nil)</code> 表明最多等待5秒。最后 <code>XCTAssertNotNil(data)</code> 表明如果 data 为 nil，则测试失败，进入断言。</p>
<h4 id="测试failedRequest"><a href="#测试failedRequest" class="headerlink" title="测试failedRequest"></a>测试failedRequest</h4><p>为了节省异步获取网络资源花费的时间，需要我们自己构造一个无效的网络响应。为了不影响项目的代码，我们需要自己定一个测试用的 URLSession。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockURLSession</span>: <span class="title">URLSessionProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> responseData: <span class="type">Data</span>?</span><br><span class="line">    <span class="keyword">var</span> responseHeader: <span class="type">HTTPURLResponse</span>?</span><br><span class="line">    <span class="keyword">var</span> responseError: <span class="type">Error</span>?</span><br><span class="line">    <span class="keyword">var</span> sessionDataTask <span class="operator">=</span> <span class="type">MockURLSessionDataTask</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dataTask</span>(<span class="params">with</span> <span class="params">request</span>: <span class="type">URLRequest</span>, <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> <span class="type">URLSessionProtocol</span>.dataTaskHandler)</span> -&gt; <span class="type">URLSessionDataTaskProcol</span> &#123;</span><br><span class="line">        completionHandler(responseData, responseHeader, responseError)</span><br><span class="line">        <span class="keyword">return</span> sessionDataTask</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过构造 MockURLSession 中的请求 responseError 来进行模拟。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func test<span class="constructor">_weatherDataAt_handle_invalid_request()</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> session = <span class="constructor">MockURLSession()</span></span><br><span class="line">        session.responseError = <span class="constructor">NSError(<span class="params">domain</span>: <span class="string">&quot;Invalid Requset&quot;</span>, <span class="params">code</span>: 100, <span class="params">userInfo</span>: <span class="params">nil</span>)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> manager = <span class="constructor">WeatherDataManager(<span class="params">baseURL</span>: URL(<span class="params">string</span>: <span class="string">&quot;https://darksky.net&quot;</span>)</span>!, urlSession: session)</span><br><span class="line">        </span><br><span class="line">        var error: DataManagerError? = nil</span><br><span class="line">        manager.weather<span class="constructor">DataAt(<span class="params">latitude</span>: 52, <span class="params">longtitude</span>: 100)</span> &#123; (_, e) <span class="keyword">in</span></span><br><span class="line">            error = e</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="constructor">XCTAssertEqual(<span class="params">error</span>, DataManagerError.<span class="params">failedRequest</span>)</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试invalidResponse"><a href="#测试invalidResponse" class="headerlink" title="测试invalidResponse"></a>测试invalidResponse</h4><p>和测试 failedRequest 的思路一样，只不过这次我们构造的错误信息应该是状态码 200 而 data 数据错误的情况。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func test<span class="constructor">_weatherDataAt_handle_invalid_response()</span> &#123;</span><br><span class="line">        session.responseHeader = <span class="constructor">HTTPURLResponse(<span class="params">url</span>: URL(<span class="params">string</span>: <span class="string">&quot;https://darksky.net&quot;</span>)</span>!, statusCode: <span class="number">200</span>, httpVersion: nil, headerFields: nil)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&quot;&#123;&quot;</span>.data(using: .utf8)!</span><br><span class="line">        session.responseData = data</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> manager = <span class="constructor">WeatherDataManager(<span class="params">baseURL</span>: URL(<span class="params">string</span>: <span class="string">&quot;https://darksky.net&quot;</span>)</span>!, urlSession: session)</span><br><span class="line">        </span><br><span class="line">        var error: DataManagerError? = nil</span><br><span class="line">        </span><br><span class="line">        manager.weather<span class="constructor">DataAt(<span class="params">latitude</span>: 52, <span class="params">longtitude</span>: 100)</span> &#123; (_, e) <span class="keyword">in</span></span><br><span class="line">            error = e</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="constructor">XCTAssertEqual(<span class="params">error</span>, DataManagerError.<span class="params">invalidResponse</span>)</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>利用 XCTest 中的 <code>measure()</code> 方法进行性能测试。可以直观的观察出方法花费时间。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_performance</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.measure &#123;</span><br><span class="line">     	<span class="comment">// Time: 0.003 sec (100% better)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">100</span> &#123;</span><br><span class="line">           <span class="built_in">print</span>(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后记-——-2017年12月26日"><a href="#后记-——-2017年12月26日" class="headerlink" title="后记 —— 2017年12月26日"></a>后记 —— 2017年12月26日</h5><p>尝试在公司的项目上进行单元测试，没想到配置环境就遇到了好多问题，果然是对这个 XCode 工程的配置不是很熟悉啊。由于我的工程项目是以 Swift 为基础，加入 Objective-C 框架进行混编的，而且使用 CocoaPod 进行的配置，所以引入工程遇到了很多问题。幸好还是在网上找到了解决方案，这里就记录一下。</p>
<h6 id="导入-Pods"><a href="#导入-Pods" class="headerlink" title="导入 Pods"></a>导入 Pods</h6><p>由于新增测试模块，所以在进行测试的使用也会用到 CocoaPod 导入的三方库，所以在 Podfile 文件也需要对测试模块进行配置。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">platform <span class="symbol">:ios</span>, <span class="string">&#x27;8.0&#x27;</span></span><br><span class="line">use_frameworks!</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pods</span></span></span><br><span class="line">    pod <span class="string">&#x27;Alamofire&#x27;</span>, <span class="string">&#x27;~&gt; 4.5.1&#x27;</span></span><br><span class="line">    pod <span class="string">&#x27;SwiftyJSON&#x27;</span>, <span class="string">&#x27;~&gt; 4.0.0&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">target <span class="string">&#x27;HiDoc&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    pods</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;HiDocTests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    pods</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>重新 pod install 的时候回遇到某些文件找不到的情况。这是因为 Tests 其实也是一个工程，依旧需要重新配置 Build Settings 中的 Path。比对原来工程中的 Search Paths 添加到工程中。<img src="https://github.com/hGhostD/MarkDownPhotos/blob/master/XCode%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/SearchPaths.png?raw=true"><br>别忘了还要修改 <font color=#d13f28><strong>User Header Search Paths</strong></font> !!!<br>有的时候依旧会报找不到文件，还需要修改 Precompile Prefix Header 为 YES。<br>基本的配置已经完成了，在 Tests 文件中引入 <code>@testable import HiDoc</code> 就能够进行引用。但是在实际情况中，我的工程总会报 <code>&quot;CMPopTipView.h&quot; file not found</code>。我查看了一下发现这个文件是由 Pod 导入的第三方库，是在 Objective-C 的 .h 文件中引用的，并没有放入桥接文件中。后来就将这个文件引用放到 .m 文件中就解决了。</p>
<h6 id="进行登录接口单元测试"><a href="#进行登录接口单元测试" class="headerlink" title="进行登录接口单元测试"></a>进行登录接口单元测试</h6><p>使用测试账号进行登录，创建测试方法。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func test<span class="constructor">_login()</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> email = <span class="string">&quot;13600000002&quot;</span></span><br><span class="line">        <span class="keyword">let</span> password = <span class="string">&quot;123456&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> expect = expectation(description: <span class="string">&quot;login&quot;</span>)</span><br><span class="line">        var isSuccess = <span class="literal">false</span></span><br><span class="line">        var test = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">HYLoginTool</span>.</span></span>login<span class="constructor">WithPromise(<span class="params">email</span>: <span class="params">email</span>, <span class="params">password</span>: <span class="params">password</span>)</span>.<span class="keyword">then</span> &#123; (result) -&gt; (Void) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> (result<span class="literal">[&quot;<span class="identifier">ret</span>&quot;]</span>.stringValue<span class="operator"> == </span><span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">                isSuccess = <span class="literal">true</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                isSuccess = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            test = result<span class="literal">[&quot;<span class="identifier">error</span>&quot;]</span>.stringValue</span><br><span class="line">            expect.fulfill<span class="literal">()</span></span><br><span class="line">            &#125;.catch &#123; (error) <span class="keyword">in</span></span><br><span class="line">                isSuccess = <span class="literal">false</span></span><br><span class="line">                test = error.localizedDescription</span><br><span class="line">                expect.fulfill<span class="literal">()</span></span><br><span class="line">        &#125;</span><br><span class="line">        wait<span class="constructor">ForExpectations(<span class="params">timeout</span>: 10, <span class="params">handler</span>: <span class="params">nil</span>)</span></span><br><span class="line">        <span class="constructor">XCTAssert(<span class="params">isSuccess</span>, <span class="params">test</span>)</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用判断条件"><a href="#常用判断条件" class="headerlink" title="常用判断条件"></a>常用判断条件</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">XCTFail(<span class="params">format</span>…)</span> 生成一个失败的测试； </span><br><span class="line"><span class="constructor">XCTAssertNil(<span class="params">a1</span>, <span class="params">format</span><span class="operator">...</span>)</span>为空判断，a1为空时通过，反之不通过；</span><br><span class="line"><span class="constructor">XCTAssertNotNil(<span class="params">a1</span>, <span class="params">format</span>…)</span>不为空判断，a1不为空时通过，反之不通过；</span><br><span class="line"><span class="constructor">XCTAssert(<span class="params">expression</span>, <span class="params">format</span><span class="operator">...</span>)</span>当expression求值为TRUE时通过；</span><br><span class="line"><span class="constructor">XCTAssertTrue(<span class="params">expression</span>, <span class="params">format</span><span class="operator">...</span>)</span>当expression求值为TRUE时通过；</span><br><span class="line"><span class="constructor">XCTAssertFalse(<span class="params">expression</span>, <span class="params">format</span><span class="operator">...</span>)</span>当expression求值为False时通过；</span><br><span class="line"><span class="constructor">XCTAssertEqualObjects(<span class="params">a1</span>, <span class="params">a2</span>, <span class="params">format</span><span class="operator">...</span>)</span>判断相等，<span class="literal">[<span class="identifier">a1</span> <span class="identifier">isEqual</span>:<span class="identifier">a2</span>]</span>值为TRUE时通过，其中一个不为空时，不通过；</span><br><span class="line"><span class="constructor">XCTAssertNotEqualObjects(<span class="params">a1</span>, <span class="params">a2</span>, <span class="params">format</span><span class="operator">...</span>)</span>判断不等，<span class="literal">[<span class="identifier">a1</span> <span class="identifier">isEqual</span>:<span class="identifier">a2</span>]</span>值为False时通过；</span><br><span class="line"><span class="constructor">XCTAssertEqual(<span class="params">a1</span>, <span class="params">a2</span>, <span class="params">format</span><span class="operator">...</span>)</span>判断相等（当a1和a2是 C语言标量、结构体或联合体时使用, 判断的是变量的地址，如果地址相同则返回TRUE，否则返回NO）；</span><br><span class="line"><span class="constructor">XCTAssertNotEqual(<span class="params">a1</span>, <span class="params">a2</span>, <span class="params">format</span><span class="operator">...</span>)</span>判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</span><br><span class="line"><span class="constructor">XCTAssertEqualWithAccuracy(<span class="params">a1</span>, <span class="params">a2</span>, <span class="params">accuracy</span>, <span class="params">format</span><span class="operator">...</span>)</span>判断相等，（double或<span class="built_in">float</span>类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</span><br><span class="line"><span class="constructor">XCTAssertNotEqualWithAccuracy(<span class="params">a1</span>, <span class="params">a2</span>, <span class="params">accuracy</span>, <span class="params">format</span><span class="operator">...</span>)</span> 判断不等，（double或<span class="built_in">float</span>类型）提供一个误差范围，当在误差范围以内不等时通过测试；</span><br><span class="line"><span class="constructor">XCTAssertThrows(<span class="params">expression</span>, <span class="params">format</span><span class="operator">...</span>)</span>异常测试，当expression发生异常时通过；反之不通过；（很变态） <span class="constructor">XCTAssertThrowsSpecific(<span class="params">expression</span>, <span class="params">specificException</span>, <span class="params">format</span><span class="operator">...</span>)</span> 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</span><br><span class="line"><span class="constructor">XCTAssertThrowsSpecificNamed(<span class="params">expression</span>, <span class="params">specificException</span>, <span class="params">exception_name</span>, <span class="params">format</span><span class="operator">...</span>)</span>异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span><br><span class="line"><span class="constructor">XCTAssertNoThrow(<span class="params">expression</span>, <span class="params">format</span>…)</span>异常测试，当expression没有发生异常时通过测试；</span><br><span class="line"><span class="constructor">XCTAssertNoThrowSpecific(<span class="params">expression</span>, <span class="params">specificException</span>, <span class="params">format</span><span class="operator">...</span>)</span>异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span><br><span class="line"><span class="constructor">XCTAssertNoThrowSpecificNamed(<span class="params">expression</span>, <span class="params">specificException</span>, <span class="params">exception_name</span>, <span class="params">format</span><span class="operator">...</span>)</span>异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hghostd.top/2017/11/07/Vim%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hGhostD.github.io/images/avatar.gif">
      <meta itemprop="name" content="你谁啊~">
      <meta itemprop="description" content="心有猛虎，嗷嗷待哺！嗷呜~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咱俩谁跟谁啊~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hGhostD.github.io/2017/11/07/Vim%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Vim使用技巧笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-07 14:44:14" itemprop="dateCreated datePublished" datetime="2017-11-07T14:44:14+08:00">2017-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-06-08 16:46:33" itemprop="dateModified" datetime="2018-06-08T16:46:33+08:00">2018-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hGhostD.github.io/categories/%E6%97%A5%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">日记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>边学习 Vim 技巧 边做笔记 学到一点就记录一点</p>
<!--- more --->
<p>从今天开始练习使用Vim，从最开始开始。</p>
<ul>
<li><p>查询： 可以在 Vi 模式下直接使用 <code>:h ctrl-w</code> 查询 <code>&lt;C-w&gt;</code> 的用法。</p>
</li>
<li><p>输出： :echo 指令。</p>
<pre><code>  Vim中的printf。 :echo &quot;Hello,world!&quot; 
</code></pre>
</li>
<li><p>持久化消息， 使用 <code>:echom &quot;Hello again,World!&quot;</code> 指令，然后使用 <code>:messages</code> 。能够再次看到 echom打印 “Hello again,World!” 的指令</p>
</li>
<li><p>基本映射 <code>:map \ dd</code> 使用 ‘&#39; 指令代表 <code>dd</code> (删除行)  </p>
</li>
<li><p>缩写 可以快捷输入一些类内容</p>
<pre><code>  :iabbrev hu Copyright 2011 Steve Losh
</code></pre>
</li>
</ul>
<hr>
<ul>
<li>插入模式映射设置  <code>:inoremap jk &lt;esc&gt;</code>  在插入模式下按jk退出插入模式</li>
<li><code>J</code> (大写) 讲两行拼接成一行</li>
<li>多行注释 <code>Ctrl+v, 选中行，I（大写I）, #, ESC</code></li>
</ul>
<hr>
<ul>
<li><code>f</code> <code>F</code> 移动光标到当前行的字母 例如 <code>fc</code> 移动到光标后面第一个 c 字母上。<code>Fc</code> 移动到光标前第一个 c 字母。<br>  使用 <code>;</code> 查找本行下一个符合的字符 例如 <code>;</code> 跳转到下一个 c 字母上。使用 <code>,</code> 向前查找。</li>
<li><code>t</code> <code>T</code> 类似 <code>f</code> <code>F</code> 。差别是移动到字母前一个位置</li>
</ul>
<hr>
<ul>
<li><code>\</code> 或者 <code>?</code> 查找 例如 <code>\error</code> <code>?error</code> 查找全文的error<br>按 <code>n</code> 向后查找匹配项 按 <code>N</code> 向前查找匹配项</li>
<li><code>CTRL-O</code> 光标跳转到上一个查找对象处 <code>CTRL-I</code> 光标跳转到下一个查找处</li>
<li>通过 <code>:set ic</code> 来忽略大小写 通过 <code>:set noic</code> 来分辨大小写 如果仅在第一次搜索时忽略大小写 直接在 搜索内容后添加 <code>\c</code> 例如: <code>\error\c</code></li>
<li>设置搜索高亮 <code>:set hls is</code>  注: 取消搜索高亮 <code>:nohlsearch</code></li>
</ul>
<hr>
<p>今天终于在xcode 9 上安装了 <a target="_blank" rel="noopener" href="https://github.com/XVimProject/XVim2">XVim</a> 了！！！</p>
<ul>
<li><code>sp</code> 或 <code>Ctrl+w s</code> 水平分割窗口</li>
<li><code>vs</code> 或 <code>Ctrl+w v</code> 垂直分割窗口</li>
<li><code>Ctrl+w q</code> 关闭当前窗口</li>
<li><code>Ctrl+w o</code> 关闭除当前串口外的所有窗口</li>
<li><code>Ctrl+w w</code> 遍历切换窗口</li>
</ul>
<hr>
<ul>
<li><code>#</code> 匹配单词 寻找下一个相同的单词。</li>
<li><code>di&quot;</code> 删除 “ 之间的内容。</li>
</ul>
<hr>
<ul>
<li><code>&gt;G</code> 使当前行到文档末尾处增加一个缩进，可以使用 <code>.</code> 继续重复命令。</li>
<li><code>s</code> 替换当前单词 == <code>cl</code>。</li>
<li><code>S</code> == <code>C</code> 删除整行 并重新输入。</li>
</ul>
<hr>
<ul>
<li><code>:%s/\.o/\.c/g</code> 将 .o 替换为 .c。 <code>%</code> 表示所有行，<code>g</code> 表示全部替换<br><code>:s/aaa/bbb</code> 只替换第一行的第一个。<code>1,12s/aaa/bbb/g</code> 替换1到12行所有的。</li>
<li><code>daw</code> <code>diw</code> 可以更快向前删除一个单词 <code>aw</code> 比 <code>iw</code> 多删除空格。 </li>
<li><code>dab</code> <code>dib</code> 删除小括号内中的内容. <code>ab</code>  比 <code>ib</code> 多删除括号。等于 <code>da(</code> <code>di(</code>,类似还有 <code>daB</code> <code>diB</code> 等于 <code>da&#123;</code> <code>di&#123;</code> 删除大括号内容。</li>
<li><code>dit</code> <code>dat</code> 删除匹配标签栏中的内容。如 <a color=#00ff00>title</a>,输入 <code>dit</code> 会删除 title，删除掉标签中的内容。</li>
<li><code>&lt;C-a&gt;</code> <code>&lt;C-x&gt;</code> 把当前数字加一或减一。Tips: 如果是对 007 使用 <code>&lt;C-a&gt;</code> 将会得到结果为 010，是因为 vim 认为 007 是8进制，在 .vimrc 中设置 <code>set nrformats=</code> 会转为十进制。</li>
</ul>
<hr>
<ul>
<li><font color=#0089ff>蓝色代表插入模式下指令</font>。</li>
<li><font color=#0089ff>Ctrl+w</font> 删除一个单词。</li>
<li><font color=#0089ff>Ctrl+u</font> 删除至行首。</li>
<li><code>yt,</code> 复制光标到 “,” 之间所有的内容。<font color=#0089ff>Ctrl+r0</font> 在光标位置粘贴复制内容。yt 的意思是复制内容到专用寄存器中，所以 Ctrl+r0 表示取出第0个内容。</li>
<li><font color=#0089ff>Ctrl+r=</font> 使用运算功能。例如 计算 6 * 35:在插入模式输入 <code>&lt;C+r&gt;=6*35</code>。直接获得结果210。</li>
</ul>
<hr>
<ul>
<li><font color=#008900>绿色代表可视模式下指令</font>。</li>
<li><code>gv</code> 重选上次高亮选区。</li>
<li><font color=#008900><strong>o</strong></font> 切换高亮选区活动端。</li>
<li><font color=#008900><strong>u U</strong></font> 对选中单词进行小写/大写切换。</li>
</ul>
<hr>
<p><code>:[range] delete [x]</code> 删除指定范围内的行[到寄存器 x 中]。<br><code>&quot;[x]p</code> 粘贴寄存器 x 中的内容，例如粘贴寄存器 2 中的内容：<code>&quot;2p</code>。<br><code>:reg</code> 查看寄存器内容。<br><code>@:</code> 重复上一条命令。<br><code>:!</code> 执行 Shell 中的程序，例如：<code>:!ls</code>。</p>
<hr>
<p><code>&lt;C+o&gt;</code> 类似网页后退，后退到上一个打开的文本。对应的还有 <code>&lt;C+i&gt;</code> 前进。<br><code>:jumps</code> 打开历史文件列表。</p>
<hr>
<p><code>m&#123;a-zA-z&#125;</code> 把位置标记 {a-zA-Z} 设在当前光标位置 (不移动光标，这不是动作命令)。<br><code>&#39;&#123;mark&#125;</code> 跳转到标记行首。 `` 跳转到上次光标位置。<br>``{mark}` 跳转到标记处。 </p>
<hr>
<p><code>qa</code> (需要记录的指令) <code>q</code> 使用 <code>q</code> + 寄存器位置来记录宏操作，最后以 <code>q</code> 指令结尾。<br><code>@a</code> 执行寄存器(a)中指令。 <code>:reg</code> 查看寄存器中所有的内容。<br><code>~</code> 大小写转换，并使光标跳转到下一个字符。</p>
<hr>
<p><code>q/</code> 查看历史指令。</p>
<hr>
<p><code>&lt;C+]&gt;</code> 跳转光标到关键字的定义处。<br><code>&lt;C+n&gt;</code>  和 <code>&lt;C+p&gt;</code> 可以激活自动补全功能。<br><code>&lt;C+x&gt;</code> <code>&lt;C+l&gt;</code> 组合使用可以补全本行内容。<br><code>:set spell</code> 检查拼写错误。 通过 <code>[s</code> 和 <code>]s</code> 命令在拼写错误间进行跳转。还可以通过 <code>z=</code> 命令获取建议列表。</p>
<hr>
<p><code>ZZ</code> 快速退出并保存。<br><code>dfi</code> 从光标处删除至i(包括i), <code>dti</code> 从光标处删除至i(不包括i)。</p>
<hr>
<p>有的时候需要在单词左右添加引号括号之类的，需要在 .vimrc 中添加定义</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">surround</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">let</span> word = <span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> wrap= <span class="built_in">input</span>(<span class="string">&quot;wrap with: &quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">command</span> = <span class="string">&quot;s/&quot;</span>.word.<span class="string">&quot;/&quot;</span>.wrap.word.wrap.<span class="string">&quot;/&quot;</span></span><br><span class="line">    <span class="keyword">execute</span> <span class="keyword">command</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">nmap</span> cx :<span class="keyword">call</span> <span class="symbol">&lt;SID&gt;</span>surround()<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样在 nomal 模式下使用 <code>cx</code> + <code>&quot;</code> 就能在单词左右添加引号。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hghostd.top/2017/11/07/%E5%9B%9E%E9%A1%BESwift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hGhostD.github.io/images/avatar.gif">
      <meta itemprop="name" content="你谁啊~">
      <meta itemprop="description" content="心有猛虎，嗷嗷待哺！嗷呜~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咱俩谁跟谁啊~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hGhostD.github.io/2017/11/07/%E5%9B%9E%E9%A1%BESwift%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">回顾Swift设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-07 10:22:22" itemprop="dateCreated datePublished" datetime="2017-11-07T10:22:22+08:00">2017-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-01-17 17:36:11" itemprop="dateModified" datetime="2018-01-17T17:36:11+08:00">2018-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hGhostD.github.io/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>《Swift 设计模式》已经看过一遍了，不过大多时候也是看完就忘记了，这里重新再看一遍并记录一下。</p>
<!--- more --->
<h4 id="对象模板模式"><a href="#对象模板模式" class="headerlink" title="对象模板模式"></a>对象模板模式</h4><blockquote>
<p>其实这个设计模式就是我们通常概念的 <font color=#d13f28><strong>面向对象</strong></font> 编程。使用 <strong>类</strong> 或者 <strong>结构体</strong> 作为数据类型及其逻辑的规范。创建对象时使用 <strong>模板</strong>，并在初始化是完成数据赋值。赋值时，要么使用模板中的 <strong>默认值</strong>，要么使用类或者结构体的 <strong>构造器</strong> 提供数值。</p>
</blockquote>
<p>技巧：有时候可以通过添加计算属性来保护不希望被随意修改的属性</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> inValue = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> outValue: <span class="type">Int </span>&#123;</span><br><span class="line">      <span class="keyword">get</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> inValue</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">          inValue = max(<span class="number">0</span>, <span class="keyword">new</span><span class="type">Value</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">proClass.outValue = <span class="number">10</span>  <span class="comment">// 10</span></span><br><span class="line">proClass.outValue = <span class="number">-10</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><blockquote>
<p>原型模式通过克隆已有的对象来创建新的对象，已有的对象即为原型</p>
</blockquote>
<p>组件若想通过模板创建新的对象，必须掌握以下三个信息。</p>
<ul>
<li>与所需创建的对象相关的模板</li>
<li>必须调用的初始化器</li>
<li>初始化器的参数名称和类型</li>
</ul>
<blockquote>
<p>将一个值赋给变量时，Swift会自动使用原型模式。值类型是使用结构体定义，而且所有Swift内置类型的底层都是用结构图实现。</p>
</blockquote>
<p>换句话说: Swift 只会为 <font color=#d13f28><strong>值类型(结构体)</strong></font> 创建默认的<font color=#d13f28><strong>初始化器</strong></font>。而<strong>不会</strong>为 <font color=#d13f28><strong>引用类型(类)</strong></font> 创建<font color=#d13f28><strong>初始化器</strong></font>。这就会导致创建完原型对象后，之后再创建任意多个同类对象，使用 <strong>结构体</strong> 模板创建的对象不会带来内存开销问题，而使用 <strong>类</strong> 模板创建的对象会有内存指向的问题。(2个变量会指向同一个对象。)<br>为了解决这个问题可以实现 NSCopying 协议，来支持克隆对象，实现深复制。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Appointment</span>: <span class="title">NSObject</span>, <span class="title">NSCopying</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">	<span class="keyword">var</span> day: <span class="type">String</span></span><br><span class="line">	<span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">day</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">		<span class="keyword">self</span>.day  <span class="operator">=</span> day</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在实现</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">copy</span>(<span class="params">with</span> <span class="params">zone</span>: <span class="type">NSZone</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> -&gt; <span class="keyword">Any</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AppointmentClass</span>(name: <span class="keyword">self</span>.name, day: <span class="keyword">self</span>.day)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b1 <span class="operator">=</span> <span class="type">Appointment</span>(name: <span class="string">&quot;Bob&quot;</span>,day: <span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> w1 <span class="operator">=</span> b1.copy() <span class="keyword">as!</span> <span class="type">Appointment</span></span><br><span class="line">w1.name <span class="operator">=</span> <span class="string">&quot;Ali&quot;</span></span><br><span class="line">w1.day  <span class="operator">=</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="comment">// 此时使用 copy() 创建的 w1 此时就不会对 b1 产生印象</span></span><br></pre></td></tr></table></figure>
<p>Tips: 只有类才可以实现 NSCopying 协议，结构体不可以。因为结构体本身实现了深复制。</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><blockquote>
<p>单例模式能够确保某个类型的对象在应用中只存一个实例。</p>
</blockquote>
<p>创建单例模式可以像 Objective-C 一样创建一个单线程进行初始化。但是在 Swift 有更好的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> shared <span class="operator">=</span> <span class="type">Single</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">override</span> <span class="function"><span class="keyword">init</span>()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> number: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips:这里遇到一个问题，如果创建单例模式的类不引用 NSOject 继承的话，就会报错。<br>问题找到了，由于在 <code>init()</code> 方法引用了关键字 <code>override</code> 导致了单例类一定要继承 NSObject 才有 <code>init()</code> 方法，所以编译器报错，去掉 <code>override</code> 就可以了。</p>
<h5 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h5><p>如果在多线程应用中使用单例，那就需要仔细考虑一个问题：当有不同的组件同时操作单例对象时，会产生哪些后果。<br>Tips: Swift 数组并不是线程安全的。也就是说两个或更多线程同时调用数组的 <code>append</code> 方法，会同一个数组进行操作，会破坏数据的结构。</p>
<blockquote>
<p>注意：高效的并发编程需要谨慎的思考和丰富的经验。有时初衷也许是很好的，但是最终开发出来的应用可能会很慢，甚至出现卡死的现象。</p>
</blockquote>
<p>操作 Swift 数组的内容不是一个线程安全的操作，单例对象在使用数组时需要并发保护。为了解决这个问题，可以使用 <font color=d13f28><strong>串行访问</strong></font> 确保同一时刻只允许一个 block 调用数组的 <code>append</code> 方法。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final class Single: NSObject &#123;</span><br><span class="line">    // 创建出一个线程用来对数组进行操作</span><br><span class="line">    let<span class="built_in"> array </span>= [String]()</span><br><span class="line">   <span class="keyword"> private</span> let arrayQ = DispatchQueue(label: <span class="string">&quot;arrayQ&quot;</span>)</span><br><span class="line">    // 创建出一个方法专门对<span class="built_in"> array </span>进行操作</span><br><span class="line">    func backup(item: String) &#123;</span><br><span class="line">        arrayQ.sync &#123; self.array.append(item) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>Tips: Swift 3 以后使用这种方式调用 <code>dipatch_barrier</code></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wirte = <span class="constructor">DispatchWorkItem(<span class="params">flags</span>: .<span class="params">barrier</span>)</span> &#123; </span><br><span class="line">    <span class="comment">// write data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dataQueue = <span class="constructor">DispatchQueue(<span class="params">label</span>: <span class="string">&quot;data&quot;</span>, <span class="params">attributes</span>: .<span class="params">concurrent</span>)</span></span><br><span class="line">dataQueue.async(execute: wirte)</span><br></pre></td></tr></table></figure>
<h4 id="对象池模式"><a href="#对象池模式" class="headerlink" title="对象池模式"></a>对象池模式</h4><blockquote>
<p>对象池模式是单例模式的一种变体，它可以为组件提供多个完全相同的对象，而非单个对象。对象池模式一般来管理一组可重用的对象，</p>
</blockquote>
<p> 此模式解决的问题：需要限制某个类型对象的数量，但允许多个个对象的存在。例如图书管理系统，需要管理某本书，但是又是多本存在。常见情况:UITableviewCell 的重用</p>
<p>利用范式创造一个对象池</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> data <span class="operator">=</span> [<span class="type">T</span>]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> arrayQ <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;arrayQ&quot;</span>)</span><br><span class="line">    <span class="comment">///创建GCD信号源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> semaphore: <span class="type">DispatchSemaphore</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">items</span>:[<span class="type">T</span>])</span> &#123;</span><br><span class="line">        data.reserveCapacity(data.count)</span><br><span class="line">        semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>(value: items.count)</span><br><span class="line"></span><br><span class="line">        items.forEach&#123;</span><br><span class="line">            data.append(<span class="variable">$0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getFromPool</span>()</span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">var</span> result: <span class="type">T</span>?</span><br><span class="line">        <span class="keyword">if</span> semaphore.wait(timeout: .distantFuture) <span class="operator">==</span> .success &#123;</span><br><span class="line">            arrayQ.sync &#123;</span><br><span class="line">                result <span class="operator">=</span> <span class="keyword">self</span>.data.remove(at: <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">returnToPool</span>(<span class="params">item</span>: <span class="type">T</span>)</span> &#123;</span><br><span class="line">        arrayQ.sync &#123;</span><br><span class="line">            <span class="keyword">self</span>.data.append(item)</span><br><span class="line">            semaphore.signal()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注释: reserveCapacity 这个方法非常有趣。数组类型的元素并不一定需要是连续的（除非你使用 ContiguousArray），但是它们大部分都是连续的。正因如此，我们常常分配一段内存空间，用来存储我们的数组——特别是当我们知道数组的大致大小时。例如，<code>map()</code> 方法总是会返回和调用该方法的序列一样大小的一个数组。所以，<code>map()</code> 方法在填充数组之前，应该会使用 <code>reserveCapacity</code>。这一点可能不容易理解。<code>map()</code> 作用于 SequenceType 类型，不仅仅是 CollectionType 类型。Sequence 类型并没有 count 属性——那么如何才能得到序列的长度呢？即使它有 count 属性，CollectionType 类型的该属性，应该返回 Index.Distance，而对于 <code>reserveCapacity</code> 来说，需要一个 Int 类型。</p>
</blockquote>
<h5 id="使用信号量解决并发问题"><a href="#使用信号量解决并发问题" class="headerlink" title="使用信号量解决并发问题"></a>使用信号量解决并发问题</h5><p>创建一个信号量 <code>private let semaphore: DispatchSemaphore</code> 并且在初始化的时候初始化它。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">init</span>(<span class="params">items</span>: [<span class="type">T</span>])</span> &#123;</span><br><span class="line">		<span class="comment">// 为信号源创建一个计数器</span></span><br><span class="line">		semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>(value: items.count)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">getFromPool</span>()</span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">		<span class="comment">// 每次调用 semaphore.wait 都会使计数器的值减一 </span></span><br><span class="line">		<span class="keyword">if</span> semaphore.wait(timeout: .distantFuture) <span class="operator">==</span> .success &#123;</span><br><span class="line">			<span class="comment">//确保在分线程执行操作 如果再主线程操作 整个 APP 就会冻住</span></span><br><span class="line">			arrayQ.sync &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">returnToPool</span>(<span class="params">item</span>: <span class="type">T</span>)</span> &#123;</span><br><span class="line">		arrayQ.sync &#123;</span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			semaphore.singal()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><blockquote>
<p>工厂方法模式通过选取相关的实现类来满足调用组件的请求，调用组件无需了解这些实现类的细节以及它们之间的关系。当存在多个类共同实现一个协议或者共同继承一个基类时，就可以使用工厂方法模式。</p>
</blockquote>
<p>实现工厂方法模式最简单的方式是定义一个全局函数。由于全局函数可以在整个应用内调用，因此调用组件可以方便地定位和调用全局函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createRentalCar</span>(<span class="params">passengers</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">RentalCar</span>? &#123;</span><br><span class="line">    <span class="keyword">var</span> car: <span class="type">RentalCar</span>?</span><br><span class="line">    <span class="keyword">switch</span> passengers &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span><span class="operator">...</span><span class="number">1</span>:</span><br><span class="line">        car <span class="operator">=</span> <span class="type">Sports</span>()</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span><span class="operator">...</span><span class="number">3</span>:</span><br><span class="line">        car <span class="operator">=</span> <span class="type">Compact</span>()</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span><span class="operator">...</span><span class="number">8</span>:</span><br><span class="line">        car <span class="operator">=</span> <span class="type">SUV</span>()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        car <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> car</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建通用协议，使创建的工厂类遵循同一个协议。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protocol RentalCar &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> passengers: <span class="built_in">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> pricePerDay: <span class="built_in">Float</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compact</span>: <span class="type">RentalCar &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Golf&quot;</span></span><br><span class="line">    <span class="keyword">var</span> passengers = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> pricePerDay: <span class="built_in">Float</span> = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sports</span>: <span class="type">RentalCar &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Sport&quot;</span></span><br><span class="line">    <span class="keyword">var</span> passengers = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> pricePerDay: <span class="built_in">Float</span> = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SUV</span>: <span class="type">RentalCar &#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;SUV&quot;</span></span><br><span class="line">    <span class="keyword">var</span> passengers = <span class="number">8</span></span><br><span class="line">    <span class="keyword">var</span> pricePerDay: <span class="built_in">Float</span> = <span class="number">75</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，就能够在类中调用工厂方法创建对象，而不需要了解对象的详细情况。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CarSelector &#123;</span><br><span class="line">    <span class="keyword">class</span> func select<span class="constructor">Car(<span class="params">passengers</span>: Int)</span> -&gt; String? &#123;</span><br><span class="line">        return create<span class="constructor">RentalCar(<span class="params">passengers</span>: <span class="params">passengers</span>)</span>?.name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><blockquote>
<p>使用建造者模式可以将创建对象所需的逻辑和默认配置值放入一个建造者类中，这样调用组件只需了解少量配置数据即可创建对象，并且无需了解创建对象所需的默认数据值。</p>
</blockquote>
<p>建造者模式实际上在开发中很常用，是指很多时候都没有意识到自己已经使用了建造者模式。说白了就是在创建对象方法和创建对象之间添加了一个中间层。只需在创建对象的时候添加修改的参数，而中间层添加默认参数，从而创建出对象。Swift 中已经很好的能够通过给方法参数添加默认值来实现初始化方法。所以可以很轻松的使用建造者模式。例如：<code>init(name: String, age: Int = 24, sex: Bool = true)</code>。</p>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><blockquote>
<p>适配器模式通过引入适配器对两个组件进行适配的方式，可以让两个 API 不兼容的组件写作。</p>
</blockquote>
<p>适配器模式通过对不同类的 API 进行适配，将应用使用的 API 映射到组件提供的 API 方式，使得两个不兼容的类可以相互协作。</p>
<p>实现适配器模式最优雅的方式是使用 Swift extension。使用 extension 可以为无法修改源码的类增加功能。</p>
<p>其实适配模式的精髓就是让不同的类都<strong>遵循相同的协议</strong>。让不同的类实现好同一个方法</p>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><blockquote>
<p>桥接模式通过分离应用的抽象部分与实现部分，使得他们可以独立的变化。为了更高的解决层级爆炸的问题,分离应用的抽象部分与实现部分,使他们可以独立的变化.</p>
</blockquote>
<p>从表面上看,桥接模式与适配器模式甚是相似。毕竟桥接模式的功能就是充当依赖某个协议的类与另外协议之间的适配器。虽然桥接模式和适配器模式相似，但是它们的应用场景并不相同。当需要集成无法修改源码的组件时(比如第三方组件),可以使用适配器模式。当你能够修改组件源代码及其运行方式时，便可使用桥接模式。使用桥接模式不只是创建一个桥接类这么简单，还需要最组件代码进行重构，以分离通用的代码和平台相关代码。</p>
<p>假定现在有2个不同的协议，且协议拥有各自的实现方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ClearMessageChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span>(<span class="params">message</span>: <span class="type">String</span>)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SecureMessageChannel</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">sendEncryptedMessage</span>(<span class="params">encryptedText</span>: <span class="type">String</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在需要通过一个类来实现这2个协议的方法，就需要通过桥接的方式来实现。<br>创建一个桥接的类，类中属性遵守不同的协议，并为属性创建协议能够调用的方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Communicator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> clearChannel: <span class="type">ClearMessageChannel</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> secureChannel: <span class="type">SecureMessageChannel</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> priorityChannel: <span class="type">PriorityMessageChannel</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">clearChannel</span>: <span class="type">ClearMessageChannel</span>, <span class="params">secureChannel</span>: <span class="type">SecureMessageChannel</span> )</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.secureChannel <span class="operator">=</span> secureChannel</span><br><span class="line">        <span class="keyword">self</span>.clearChannel <span class="operator">=</span> clearChannel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sendCleartextMessage</span>(<span class="params">mesage</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.clearChannel.send(message: mesage)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sendSecureMessage</span>(<span class="params">message</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.secureChannel.sendEncryptedMessage(encryptedText: message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下里，需要创建出不同的类来遵循上述协议并实现协议方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Landline</span>: <span class="title">ClearMessageChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span>(<span class="params">message</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Landline&quot;</span>,message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecureLandLine</span>: <span class="title">SecureMessageChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sendEncryptedMessage</span>(<span class="params">encryptedText</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Secure&quot;</span>, encryptedText)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后,通过就能够通过创建桥接对象来实现协议方法。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var comms = <span class="constructor">Communicator(<span class="params">clearChannel</span>: Landline()</span>, secureChannel: <span class="constructor">SecureLandLine()</span>)</span><br><span class="line"></span><br><span class="line">comms.send<span class="constructor">CleartextMessage(<span class="params">mesage</span>: <span class="string">&quot;CLEAR&quot;</span>)</span></span><br><span class="line">comms.send<span class="constructor">SecureMessage(<span class="params">message</span>: <span class="string">&quot;Sercure&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><blockquote>
<p>此模式在处理无法修改的类时能发挥强大的功能。可以在不修改对象所属的类或对象的使用者情况下，修改单个对象的行为。</p>
</blockquote>
<p>为了实现装饰器模式，需要继承那个无法修改的类，以创建一个拥有该类所有方法和属性的类，这样才可以实现无缝替换原来的那个类。但是 <strong>Swift 不建议使用继承</strong>。尽量还是避免使用这种模式。</p>
<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><blockquote>
<p>组合模式能够将对象以树形结构组织起来，使得外界对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p>组合模式的实现主要是通过让不同的 类 都<strong>遵循统一的协议</strong>，这样就能够实现一个管理类统一处理不同对象。<br><img src="https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.jpg?raw=true"></p>
<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><blockquote>
<p>外观模式可以简化复杂的常见任务 API的使用</p>
</blockquote>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><blockquote>
<p>享元模式可以在多个调用组件之间共享数据</p>
</blockquote>
<p>享元模式不会修改外部数据，也不允许调用组件修改外部数据。这是享元模式非常重要的特征，允许对外部数据进行修改也是人们在实现享元模式时常犯的一个错误。</p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><blockquote>
<p>代理模式的核心是一个对象–代理对象，此对象可以用于代表其他资源，此对象可以用于代表其他资源。</p>
</blockquote>
<h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><blockquote>
<p>责任链模式负责组织管理一序列能够对调用组件的请求做出响应的对象。这里所说的对象序列被称为责任链，责任链中的每个对象都可能被用于处理某个请求。请求在这个链上传递，知道链上的某一个对象处理此请求，或者到达链的尾部。</p>
</blockquote>
<p>当多个对象可以响应一个请求，而又不想将这些对象的细节暴露给调用组件时，便可以使用责任链模式。下面举例说明一下责任链模式。<br>创建一种消息类型 Message，包括发送者、接收者和消息内容:</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">Message</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> from: <span class="keyword">String</span></span><br><span class="line">    <span class="keyword">let</span> to:   <span class="keyword">String</span></span><br><span class="line">    <span class="keyword">let</span> subject: <span class="keyword">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在需要创建一条责任链，作用是处理 Message，判断这条消息是内部消息(from 和 to 的邮箱是同一个)、外部消息(from 和 to 不是同一个邮箱)还是私密消息(subject 的内容是 Priority 开头)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nextLinke: <span class="type">Transmitter</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="function"><span class="keyword">init</span>()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sendMessage</span>(<span class="keyword">_</span> <span class="params">message</span>: <span class="type">Message</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextLinke <span class="operator">!=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">            nextLinke<span class="operator">?</span>.sendMessage(message)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;责任链到达底端，消息不再发送。&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">matchEmailSuffix</span>(<span class="title">message</span>: <span class="title">Message</span>) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断收和发的邮箱是否是同一个</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> index <span class="operator">=</span> message.from.index(of: <span class="string">&quot;@&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> sub <span class="operator">=</span> <span class="type">String</span>(message.from[index<span class="operator">...</span>])</span><br><span class="line">            <span class="keyword">return</span> message.to.hasSuffix(sub)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一条责任链</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">createChain</span>() -&gt; <span class="title">Transmitter</span>? </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> transmitterClasses: [<span class="type">Transmitter</span>.<span class="keyword">Type</span>] <span class="operator">=</span> [</span><br><span class="line">            <span class="type">PriorityTransmitter</span>.<span class="keyword">self</span>,</span><br><span class="line">            <span class="type">LocalTransmitter</span>.<span class="keyword">self</span>,</span><br><span class="line">            <span class="type">RemoteTransmitter</span>.<span class="keyword">self</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> link: <span class="type">Transmitter</span>?</span><br><span class="line">        </span><br><span class="line">        transmitterClasses.reversed().forEach &#123;</span><br><span class="line">            <span class="keyword">let</span> existingLink <span class="operator">=</span> link</span><br><span class="line">            link <span class="operator">=</span> <span class="variable">$0</span>.<span class="keyword">init</span>()</span><br><span class="line">            link<span class="operator">?</span>.nextLinke <span class="operator">=</span>  existingLink</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> link</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就需要将责任链中不同的责任类进行实现，他们都需要集成责任链的类，并重写 sendMessage 的方法，然后在 sendMessage 的方法中分别实现自己的需求。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LocalTransmitter: Transmitter &#123;</span><br><span class="line">    override func send<span class="constructor">Message(<span class="params">_</span> <span class="params">message</span>: Message)</span>  &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Transmitter</span>.</span></span><span class="keyword">match</span><span class="constructor">EmailSuffix(<span class="params">message</span>: <span class="params">message</span>)</span>) &#123;</span><br><span class="line">            print(<span class="string">&quot;\(message.from) 发送的内部消息&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            super.send<span class="constructor">Message(<span class="params">message</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> RemoteTransmitter: Transmitter &#123;</span><br><span class="line">    override func send<span class="constructor">Message(<span class="params">_</span> <span class="params">message</span>: Message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">Transmitter</span>.</span></span><span class="keyword">match</span><span class="constructor">EmailSuffix(<span class="params">message</span>: <span class="params">message</span>)</span>) &#123;</span><br><span class="line">            print(<span class="string">&quot;\(message.from) 发送外部消息&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            super.send<span class="constructor">Message(<span class="params">message</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> PriorityTransmitter: Transmitter &#123;</span><br><span class="line">    override func send<span class="constructor">Message(<span class="params">_</span> <span class="params">message</span>: Message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.subject.has<span class="constructor">Prefix(<span class="string">&quot;Priority&quot;</span>)</span>) &#123;</span><br><span class="line">            print(<span class="string">&quot;\(message.from) 发送 私人消息&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            super.send<span class="constructor">Message(<span class="params">message</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在创建的责任链中注意实现 sendMessage 方法:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let message = [Message(from: <span class="string">&quot;bob@163.com&quot;</span>, to: <span class="string">&quot;joe@qq.com&quot;</span>, subject: <span class="string">&quot;午饭吃啥？&quot;</span>),</span><br><span class="line">               Message(from: <span class="string">&quot;joe@qq.com&quot;</span>, to: <span class="string">&quot;ali@qq.com&quot;</span>, subject: <span class="string">&quot;你吃啥？&quot;</span>),</span><br><span class="line">               Message(from: <span class="string">&quot;pet@2&quot;</span>, to: <span class="string">&quot;all@2&quot;</span>, subject: <span class="string">&quot;Priority: 这是私密消息！&quot;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> let chain = Transmitter.createChain()  &#123;</span><br><span class="line">    message.forEach &#123;</span><br><span class="line">        chain.sendMessage($0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// bob@163.com 发送外部消息</span><br><span class="line">// joe@qq.com 发送的内部消息</span><br><span class="line">// pet@2 发送 私人消息</span><br></pre></td></tr></table></figure>

<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><blockquote>
<p>命令模式提供了一种封装方法调用的机制，基于这种机制我们可以实现延迟方法调用或替换调用该方法的组用。命令模式的核心是 <strong>命令对象</strong>。在其内部实现中，接受对象持有一个命令 <strong>接收者对象</strong> 的引用，并知道如何调用接收者的相关方法。接收者和调用指令是命令私有的，不应允许使用命令的调用组件去访问。命令对象唯一的可供公开访问的是 execution 方法。当调用组件需要执行相关命令时，直接调用 execution 即可。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hghostd.top/2017/11/04/%E4%BD%BF%E7%94%A8vps%E6%90%AD%E5%BB%BAss/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hGhostD.github.io/images/avatar.gif">
      <meta itemprop="name" content="你谁啊~">
      <meta itemprop="description" content="心有猛虎，嗷嗷待哺！嗷呜~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咱俩谁跟谁啊~">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hGhostD.github.io/2017/11/04/%E4%BD%BF%E7%94%A8vps%E6%90%AD%E5%BB%BAss/" class="post-title-link" itemprop="url">使用vps搭建ss</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-04 15:59:15" itemprop="dateCreated datePublished" datetime="2017-11-04T15:59:15+08:00">2017-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2017-11-06 14:10:28" itemprop="dateModified" datetime="2017-11-06T14:10:28+08:00">2017-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hGhostD.github.io/categories/%E5%BE%85%E7%BB%AD/" itemprop="url" rel="index"><span itemprop="name">待续</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="使用-VPS-搭建-SS"><a href="#使用-VPS-搭建-SS" class="headerlink" title="使用 VPS 搭建 SS"></a>使用 VPS 搭建 SS</h4><p>由于之前的 VPN 到期了，刚好想自己搞一个 VPS，初步搭建记录一下过程。</p>
<!--- more --->
<h4 id="购买-VPS-服务器"><a href="#购买-VPS-服务器" class="headerlink" title="购买 VPS 服务器"></a>购买 VPS 服务器</h4><p>登录 <a target="_blank" rel="noopener" href="https://my.vultr.com/">Vultr</a> 官网选择需要的服务器。我选择日本东京的服务器。服务器类型选择 CentOS 7 x64 <img src="https://raw.githubusercontent.com/hGhostD/MarkDownPhotos/master/VPS/ServerType.png" alt="CentOS 7 x64">等服务器启动后可以获取相关信息，查看 IP 地址和密码<img src="https://raw.githubusercontent.com/hGhostD/MarkDownPhotos/master/VPS/Account.jpeg"></p>
<h4 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h4><p>服务搭建完成后需要连接服务器，mac 用户可以直接在终端 使用 <code>ssh root@XX.XX.XX.XXX</code> 指令进行连接。windows 可以下载 <a target="_blank" rel="noopener" href="https://nofile.io/f/eb5dUzYMQK4/Xshell_setup_wm.exe">XShell</a> 提取密码: 666。<br>连接之后输入密码，遍进入服务器终端。</p>
<p>使用 root 用户登录，运行一下命令:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --<span class="keyword">no</span>-check-certificate -O shadowsocks.<span class="keyword">sh</span> http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/teddysun/shadowsocks_install/master/shadowsocks.<span class="keyword">sh</span></span><br><span class="line">chmod +<span class="keyword">x</span> shadowsocks.<span class="keyword">sh</span></span><br><span class="line">./shadowsocks.<span class="keyword">sh</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee shadowsocks.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>按照提示命令，输入密码、端口号、加密方式(aes-256-cfb)等信息</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Congratulations, Shadowsocks-python server install completed!</span><br><span class="line">Your Server IP        : <span class="comment">// 服务器 IP</span></span><br><span class="line">Your Server Port      : <span class="comment">// 刚才设置的端口号</span></span><br><span class="line">Your Password         : <span class="comment">// 刚才设置的密码</span></span><br><span class="line">Your Encryption <span class="function"><span class="keyword">Method</span>:</span>your_encryption_method</span><br><span class="line"></span><br><span class="line">Welcome <span class="keyword">to</span> visit:https:<span class="comment">//teddysun.com/342.html</span></span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure>
<p>到此初步配置已经结束，最后需要重启一下服务器。<br>以后可能还需要用 VPS 做一些更有难度的工作，不过第一步通过 VPS 翻墙总算是大功告成了！！！</p>
<br>
>参考资料
>[vultr](https://my.vultr.com/)
>[自建ss服务器教程](https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B)
>[Shadowsocks Python版一键安装脚本](https://teddysun.com/342.html)
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/hGhostD.github.io/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/hGhostD.github.io/">1</a><span class="page-number current">2</span><a class="page-number" href="/hGhostD.github.io/page/3/">3</a><a class="extend next" rel="next" href="/hGhostD.github.io/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">你谁啊~</p>
  <div class="site-description" itemprop="description">心有猛虎，嗷嗷待哺！嗷呜~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/hGhostD.github.io/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">你谁啊~</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/hGhostD.github.io/lib/anime.min.js"></script>
  <script src="/hGhostD.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/hGhostD.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/hGhostD.github.io/js/utils.js"></script>

<script src="/hGhostD.github.io/js/motion.js"></script>


<script src="/hGhostD.github.io/js/schemes/pisces.js"></script>


<script src="/hGhostD.github.io/js/next-boot.js"></script>




  















  

  

</body>
</html>
