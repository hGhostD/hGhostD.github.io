{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/img/1024.png","path":"img/1024.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/.swo","hash":"a713c7f6e09fabad247fb670659edbf0e704e883","modified":1512976298000},{"_id":"source/_posts/.DS_Store","hash":"a5bf5923f891ea4e42f8b2853e97df4475830cb5","modified":1551277518256},{"_id":"source/_posts/.swp","hash":"20eeef2d77ae10d1d12cdc609b79026b3570ff8d","modified":1510299301000},{"_id":"source/.DS_Store","hash":"1fae6f799b627ab8732781bcb6548e7c52c79ac9","modified":1609551919509},{"_id":"source/_posts/2017年末总结.md","hash":"abac444664196e20f0045f82f1aa587266fd898c","modified":1609512561000},{"_id":"source/_posts/2020年末总结.md","hash":"53562e205920124745dbbd681824642ff8d92ecb","modified":1630943297443},{"_id":"source/_posts/Moya 使用笔记.md","hash":"599cd336794c1027bfb992d11298984be384a76f","modified":1517910575000},{"_id":"source/_posts/RxSwift 实现 UITableview.md","hash":"60c92bdce50192e212f6e110c934d87e78d3417b","modified":1516961037000},{"_id":"source/_posts/MVVM设计模式笔记.md","hash":"c9fecfef15f6ac92ada00eb62cd219145cc6f2e3","modified":1510651230000},{"_id":"source/_posts/PopMenu提示框实现.md","hash":"39530cdde52e713aa446d4697571f954566eeee1","modified":1630943398020},{"_id":"source/_posts/Swift协议拓展.md","hash":"acbf645cf6f444e44a49971a60d2e72e3744e7de","modified":1511247847000},{"_id":"source/_posts/Swift实现可编辑标签页.md","hash":"834c3a55013df8e1b60a44a254f93b38716b035b","modified":1526461055000},{"_id":"source/_posts/Vim使用技巧笔记.md","hash":"cfc633e2979ec4805ea40abba6af1e6653f7e29c","modified":1528447593000},{"_id":"source/_posts/Swift的正则表达式.md","hash":"9ab4ae1a5e34f82a4b1611e0990e94fe502a6ad0","modified":1510133577000},{"_id":"source/_posts/Xcode 单元测试.md","hash":"3d250fbe3dc31222942241a6ac7dc80ac8141cab","modified":1515207452000},{"_id":"source/_posts/《Swift 进阶》读书笔记.md","hash":"7654fc576b192fa0e9673ce6d79a2f1f176eb383","modified":1516007977000},{"_id":"source/_posts/hexo 指令.md","hash":"017a0aeb14377a59bb49bb0fef138e4f2a87f77a","modified":1551277445051},{"_id":"source/_posts/fastlane自动打包脚本.md","hash":"868850108a3c99ff44ab75d07f51a9a11a6b5879","modified":1521536394000},{"_id":"source/_posts/《亲密关系》读书笔记.md","hash":"0e906ad4d289c49ff55d117b337fe4a163cd574d","modified":1630943349839},{"_id":"source/_posts/《函数式Swift》笔记.md","hash":"77b03ccdb358e093bf2647c93b2a4a53afc044f7","modified":1516095809000},{"_id":"source/_posts/什么能力很重要，但大多数人却没有.md","hash":"2e97fbc0927486c814216d1c2f187ee2215c0a42","modified":1630943388184},{"_id":"source/_posts/《批判性思维工具》笔记.md","hash":"fd7e0df6ee8eac31259466837177cc512414cfc7","modified":1513220722000},{"_id":"source/_posts/使用 UIPresentationController 实现底部弹出页面 .md","hash":"fe2d12fdd8fd77074776a8de0a621f2480573e14","modified":1521700421000},{"_id":"source/_posts/关于Restkit的使用.md","hash":"9569137d21feeeae4e2e1b7ffb7813eebb631057","modified":1596447348000},{"_id":"source/_posts/使用vps搭建ss.md","hash":"06e1593c7ef759f2a2e6d642077f337de2542372","modified":1509948628000},{"_id":"source/_posts/关于WKWevView和JS交互开发.md","hash":"72d8e64848d23f2b52c4ffd6422d44150abff9b5","modified":1510133711000},{"_id":"source/_posts/当当的书到了.md","hash":"65deb59a42e31a56b842cbe4e3b4dcfb4887408e","modified":1510108778000},{"_id":"source/_posts/回顾Swift设计模式.md","hash":"72284ecd1db29041d44e6989ef0f325153a546bc","modified":1516181771000},{"_id":"source/_posts/第一篇读书.md","hash":"80e1a6f70cf4cf2d08176fb6bdf9a7dd6f353a1e","modified":1510133829000},{"_id":"source/_posts/第一篇日记.md","hash":"ee47412b1bbad8d0ac8c41b63c11f0b86ed4de51","modified":1510133966000},{"_id":"source/_posts/第一篇Swift.md","hash":"254cc605c6ebd89e0b1558e5f3bb31bcd5e95aa2","modified":1509690823000},{"_id":"source/img/1024.png","hash":"9879eec7a11ae45d7055c7245524a62b61041269","modified":1609729054000},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1509946423000},{"_id":"source/_posts/这是一篇待续.md","hash":"7f9c0f691606331717430c2d4c2738073f1abd57","modified":1510190574000},{"_id":"source/Objective-C/index.md","hash":"e21b1abfd013ad03d65d62d4b1cc163ee771ed77","modified":1529747740072},{"_id":"source/待续/index.md","hash":"197e52d1c817cc11f0fdfd4fb7e426e5e61b57ca","modified":1509587011000},{"_id":"source/paddleOCR/index.md","hash":"18205ef5fd4ff8a4ca6bcd092f03c16faace5d4c","modified":1609728480000},{"_id":"source/日记/index.md","hash":"7ba6688d8bfd6ef132e0bad947aa2809588ab0be","modified":1509586959000},{"_id":"source/读书/index.md","hash":"604846416f813e93f8b37950cba8347e21941359","modified":1509587001000},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1630780033872},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1630780763446},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1630780033879},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1630780033879},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1630780033879},{"_id":"themes/next/_config.yml","hash":"3d21a818aa813998aaa027e74b83a007ed4268ac","modified":1630941675447},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1630780033872},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1630780033893},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1630780033880},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1630780033938},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1630780033879},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1630780033872},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1630780033873},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1630780033873},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1630780033875},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1630780033876},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1630780033876},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1630780033877},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1630780033877},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1630780033877},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1630780033877},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1630780033881},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1630780033881},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1630780033882},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1630780033881},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1630780033883},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1630780033884},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1630780033883},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1630780033884},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1630780033894},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1630780033896},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1630780033883},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1630780033895},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1630780033878},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1630780033878},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1630780033898},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1630780033897},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1630780033897},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1630780033898},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1630780033896},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1630780033899},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1630780033899},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1630780033896},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1630780033899},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1630780033900},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1630780033901},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1630780033901},{"_id":"themes/next/languages/tr.yml","hash":"2b041eeb8bd096f549464f191cfc1ea0181daca4","modified":1630780763448},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1630780033902},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1630780033903},{"_id":"themes/next/languages/zh-CN.yml","hash":"157c6d7b87c87cd2719eec254c2a2f9846368550","modified":1630941021783},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1630780033904},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1630780033904},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1630780033905},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1630780033935},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1630780033936},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1630780033936},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1630780033937},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1630780033937},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1630780033938},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1630780033947},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1630780033874},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1630780033874},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1630780033875},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1630780033875},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1630780033885},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1630780033885},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1630780033886},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1630780033886},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1630780033887},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1630780033887},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1630780033900},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1630780033888},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1630780033884},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1630780033890},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1630780033889},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1630780033890},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1630780033891},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1630780763449},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1630780763449},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1630780033906},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1630780763449},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1630780033907},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1630780033912},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1630780033888},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1630780033914},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1630780033918},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1630780033919},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1630780033920},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1630780033919},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1630780033922},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1630780033922},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1630780033929},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1630780033931},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1630780033931},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1630780763453},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1630780033944},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1630780033944},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1630780033945},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1630780763453},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1630780033945},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1630780763456},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1630780763456},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1630780033946},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1630780033947},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1630780033947},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1630780763457},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1630780033948},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1630780763458},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1630780033949},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1630780033949},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1630780033950},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1630780033950},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1630780033951},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1630780033951},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1630780763459},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1630780763469},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1630780033998},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1630780033999},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1630780033999},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1630780033999},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1630780034000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1630780034000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1630780034001},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1630780034002},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1630780034002},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1630780034002},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1630780034003},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1630780034003},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1630780034001},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1630780763473},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1630780034003},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1630780763474},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1630780763476},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1630780034005},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1630780763475},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1630780033909},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1630780763450},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1630780763478},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1630780763451},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1630780034010},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1630780033911},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1630780033912},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1630780763451},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1630780033910},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1630780033913},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1630780763451},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1630780033913},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1630780763452},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1630780033915},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1630780033916},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1630780033915},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1630780033916},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1630780033917},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1630780033917},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1630780033920},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1630780763452},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1630780033921},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1630780033921},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1630780033922},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1630780033921},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1630780033923},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1630780033924},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1630780033925},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1630780033924},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1630780033926},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1630780033926},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1630780033927},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1630780033927},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1630780033928},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1630780033928},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1630780033929},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1630780033927},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1630780033930},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1630780033930},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1630780033930},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1630780033931},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1630780033932},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1630780033932},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1630780763453},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1630780033933},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1630780033933},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1630780033934},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1630780033935},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1630780033933},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1630780033934},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1630780033940},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1630780033941},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1630780033940},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1630780763454},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1630780763454},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1630780763455},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1630780033943},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1630780033943},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1630780033943},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1630780763455},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1630780033942},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1630780033996},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1630780033996},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1630780763472},{"_id":"themes/next/source/css/_variables/base.styl","hash":"a958fa904eb80ad367bc1aa6d8f68d3e2afda30a","modified":1630942510586},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1630780763460},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1630780033996},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1630780763477},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1630780034016},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1630780033953},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1630780034015},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1630780033953},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1630780033954},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1630780033965},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1630780763466},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1630780033980},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1630780033983},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1630780033983},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1630780033984},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1630780763467},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1630780033987},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1630780033981},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1630780033976},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1630780033975},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1630780033989},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1630780033989},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1630780033990},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1630780033991},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1630780033991},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1630780033990},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1630780033994},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1630780033994},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1630780763471},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1630780763472},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1630780033995},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1630780763470},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1630780033992},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1630780033991},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1630780033992},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1630780033993},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1630780033993},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1630780763470},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1630780763479},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1630780033958},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1630780033958},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1630780763461},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1630780033958},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1630780763461},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1630780763462},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1630780033960},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1630780033961},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1630780033960},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1630780033961},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1630780033961},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1630780763463},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1630780763464},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1630780763464},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1630780033963},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1630780033963},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1630780033964},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1630780033964},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1630780033966},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1630780033967},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1630780033967},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1630780033967},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1630780033968},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1630780033981},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1630780033982},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1630780033982},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1630780033982},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1630780763468},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1630780033985},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1630780033985},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1630780763468},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1630780033987},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1630780033986},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1630780763484},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1630780033987},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1630780033968},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1630780763465},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1630780033972},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1630780033973},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1630780033974},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1630780763465},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1630780033974},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1630780033975},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1630780033976},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1630780033976},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1630780763466},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1630780763476},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1630780033977},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1630780033978},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1630780033979},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1630780033979},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1630780033978},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1630780033980},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1630780033977},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1630780763483},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1630780763488},{"_id":"public/content.json","hash":"4dcaa4f197e548c0625e0aba496ccc563e21a183","modified":1630942681562},{"_id":"public/paddleOCR/index.html","hash":"b99e7595769eebd0c6ce29061fc742e20f8c1c50","modified":1630942681562},{"_id":"public/待续/index.html","hash":"0b97f365a09a53131641230b57266b09b79fc613","modified":1630942681562},{"_id":"public/Objective-C/index.html","hash":"8dd8a89f0c751ce712816c81c6eba0102575a9b3","modified":1630942681562},{"_id":"public/读书/index.html","hash":"7122a08eeba582f1a738c0ade917a51d2287cd83","modified":1630942681562},{"_id":"public/日记/index.html","hash":"7e449b9647b3b9a25d75b0e50c447e37ff8dec5b","modified":1630942681562},{"_id":"public/2021/01/01/2020年末总结/index.html","hash":"96cd8aaaf4ca3565d9ad9d5dd19de2ddea8bd461","modified":1630943440663},{"_id":"public/2017/11/03/Swift的正则表达式/index.html","hash":"da6c75015956e0cc95cdbd2f24cbb13f8e0e05dd","modified":1630942681562},{"_id":"public/2017/11/03/当当的书到了/index.html","hash":"7d689f17deacf33765f04f7cd992f0e8cbe47f02","modified":1630942681562},{"_id":"public/2017/11/02/第一篇日记/index.html","hash":"61488dd9f0e38546369fb9f06281239a19a6c232","modified":1630942681562},{"_id":"public/2017/11/02/第一篇Swift/index.html","hash":"56a3b2d2df9af307cd4608da153bb334d403a589","modified":1630942681562},{"_id":"public/2017/11/02/第一篇读书/index.html","hash":"6a8a64f6678d1dbe3bb39c7738fa62f12ef0362e","modified":1630942681562},{"_id":"public/2017/11/02/这是一篇待续/index.html","hash":"612b06f8d3cc4ff6a038dcdba6f55e9016ab928a","modified":1630942681562},{"_id":"public/categories/日记/index.html","hash":"49b271615f85730f0beb1149544be198f6d6d3e8","modified":1630942681562},{"_id":"public/categories/Swift/index.html","hash":"8db3b4cc3b129362d2c5b2214e8240d5b020e105","modified":1630942681562},{"_id":"public/categories/Swift/page/2/index.html","hash":"870f95092cc6f0669e187ba976f520d85c379dca","modified":1630942681562},{"_id":"public/categories/待续/index.html","hash":"41ff70829256bd40c281b7cef67a4e47a6bbed07","modified":1630942681562},{"_id":"public/categories/读书/index.html","hash":"cc6c0af0cd5d8745f468564cbcf0c99d0b2daa27","modified":1630942681562},{"_id":"public/categories/Objective-C/index.html","hash":"59a9118ce8f0f469a9450555b6fde75fba3ccea1","modified":1630942681562},{"_id":"public/archives/index.html","hash":"52ab886bd185a30b954abb341612f14cca224f74","modified":1630942681562},{"_id":"public/archives/page/2/index.html","hash":"e237eaf28e00211902748143ef49a34d5c8c254f","modified":1630942681562},{"_id":"public/archives/page/3/index.html","hash":"5daaa5505e629030bc8af82c71f4f3278f59d3ef","modified":1630942681562},{"_id":"public/archives/2017/index.html","hash":"326ea7fa961bfe99c6a271d4e554c89ba2ac28ab","modified":1630942681562},{"_id":"public/archives/2017/page/2/index.html","hash":"f3b5c24354fef9c3fbb1ebd1a146d2867ef94620","modified":1630942681562},{"_id":"public/archives/2017/11/index.html","hash":"9114d26a8b3a255570f8dc42359eaea722fda346","modified":1630942681562},{"_id":"public/archives/2017/11/page/2/index.html","hash":"92032809b40b1c991bb9dac7cf2395b4732439ff","modified":1630942681562},{"_id":"public/archives/2017/12/index.html","hash":"6c60f68ccb2e9a8ee4f73a2bdfe8e074ad88f0ef","modified":1630942681562},{"_id":"public/archives/2018/index.html","hash":"f789c4e16ed3f64a3ef7424921d47dbdac721e90","modified":1630942681562},{"_id":"public/archives/2018/01/index.html","hash":"78e44129b973d6712fd4988014d6ca206d0e9cb4","modified":1630942681562},{"_id":"public/archives/2018/02/index.html","hash":"e0af9bbc405d83310309983d85ab0bd7c07a31de","modified":1630942681562},{"_id":"public/archives/2018/03/index.html","hash":"5ac7ed668cd675f84f3bc98582540a494ead4be0","modified":1630942681562},{"_id":"public/archives/2018/05/index.html","hash":"da020787e01163e2d7803d2d133a42bb21c7acbd","modified":1630942681562},{"_id":"public/archives/2018/06/index.html","hash":"35d5a463d666990947482bb0da81a04f73e5b60d","modified":1630942681562},{"_id":"public/archives/2019/index.html","hash":"3642966cd0134e9b13ce139a2e8726572f21575a","modified":1630942681562},{"_id":"public/archives/2019/02/index.html","hash":"def85d181b9c052aed189b919ee033d063fb8f66","modified":1630942681562},{"_id":"public/archives/2019/03/index.html","hash":"cd0719082398e8504801083367d5b6e8bdaf512b","modified":1630942681562},{"_id":"public/archives/2021/index.html","hash":"e2686ce12ab3df8e0723eac7fe3b41fd2b33b7ed","modified":1630942681562},{"_id":"public/archives/2021/01/index.html","hash":"677bf38280d6315301a9aeb86b7db4f627327c65","modified":1630942681562},{"_id":"public/tags/日记/index.html","hash":"2dab2c8329f5eefbf5a7838282d655c3ace18e13","modified":1630942681562},{"_id":"public/tags/随笔/index.html","hash":"76322b3b3648e844e3cbcdb2a3d40c5fba1c461e","modified":1630942681562},{"_id":"public/tags/Swift/index.html","hash":"5903203547dbf73ae678ac85d7da36f8240fa911","modified":1630942681562},{"_id":"public/tags/Swift/page/2/index.html","hash":"c7a4295792f2805cbcfbf3f598bae881f6814838","modified":1630942681562},{"_id":"public/tags/Vim/index.html","hash":"b72f19c8119e919c31262d34dde8bf3e2d09aecf","modified":1630942681562},{"_id":"public/tags/待续/index.html","hash":"38d84c2f813402401f3aac5e5b1af4196c1d0d5f","modified":1630942681562},{"_id":"public/tags/读书/index.html","hash":"6a496709576ddce6ef458b24a236829c4a97ff3f","modified":1630942681562},{"_id":"public/tags/Objective-C/index.html","hash":"3494ecda8c603c10f6ddf3cb54b9024360c886b7","modified":1630942681562},{"_id":"public/2019/03/24/《亲密关系》读书笔记/index.html","hash":"34960487c53978dfe883fdeb693df1820add9020","modified":1630943440663},{"_id":"public/2019/03/23/什么能力很重要，但大多数人却没有/index.html","hash":"89456d738a56b50b17c689cea834b52a86f92237","modified":1630943440663},{"_id":"public/2019/02/24/hexo 指令/index.html","hash":"bd593adb003117424b00d97c0dd40fef4e1976cd","modified":1630942681562},{"_id":"public/2018/06/23/关于Restkit的使用/index.html","hash":"039c180d342c44cb7b915d24aa9b4ecb6fcf802c","modified":1630942681562},{"_id":"public/2018/05/11/PopMenu提示框实现/index.html","hash":"76c5291dd662ab379d2435e2ffc2f3c557cb8a04","modified":1630943440663},{"_id":"public/2018/03/22/Swift实现可编辑标签页/index.html","hash":"16b12df52eb63eab6ae1d181b58bcd58554f0748","modified":1630942681562},{"_id":"public/2018/03/19/fastlane自动打包脚本/index.html","hash":"77360003768dd1efd3ea365b79e5ccd612ab9a4d","modified":1630942681562},{"_id":"public/2018/03/08/使用 UIPresentationController 实现底部弹出页面 /index.html","hash":"d4a5998232498927fac4f499ee0f38f32610478f","modified":1630942681562},{"_id":"public/2018/02/06/Moya 使用笔记/index.html","hash":"b7a3db7144f870b85c274a1a05f57d74fab0afa5","modified":1630942681562},{"_id":"public/2018/01/26/RxSwift 实现 UITableview/index.html","hash":"8d7e05abb549a985aba72347559aa6ca748264ae","modified":1630942681562},{"_id":"public/2018/01/10/《函数式Swift》笔记/index.html","hash":"2f608728fbdbdf91097c3d6b4698efbbcd341715","modified":1630942681562},{"_id":"public/2018/01/01/2017年末总结/index.html","hash":"0d9682f1ae5243e1b6d3290a5f24c51d62bfc1c4","modified":1630942681562},{"_id":"public/2017/12/18/《Swift 进阶》读书笔记/index.html","hash":"59f5aa64f75a6fd6138a79983fc0a083eb6c8fd6","modified":1630942681562},{"_id":"public/2017/11/20/Swift协议拓展/index.html","hash":"7885777ee59bb9b45e115fd577bc590b704a46df","modified":1630942681562},{"_id":"public/2017/11/14/MVVM设计模式笔记/index.html","hash":"1725bd18a2ad6bebaa04f88b39bfee80769d2cc2","modified":1630942681562},{"_id":"public/2017/11/13/Xcode 单元测试/index.html","hash":"3eeff0241d88aac4933ca8017bb9b678bdcffb3b","modified":1630942681562},{"_id":"public/2017/11/07/Vim使用技巧笔记/index.html","hash":"09a0c45102d2bcbad2252e6192d4ab31b5ae6d01","modified":1630942681562},{"_id":"public/2017/11/07/回顾Swift设计模式/index.html","hash":"18d50b70c153a816a9f985ada75e7a641b654dad","modified":1630942681562},{"_id":"public/2017/11/04/使用vps搭建ss/index.html","hash":"c1be879e9503d26fb03913ca8b79a064284f9441","modified":1630942681562},{"_id":"public/2017/11/03/《批判性思维工具》笔记/index.html","hash":"fb4845c944170324dfa9fe0baed7096e6dd36fe6","modified":1630942681562},{"_id":"public/2017/11/03/关于WKWevView和JS交互开发/index.html","hash":"2093a84076e17126d496cd98b076281718cb91af","modified":1630942681562},{"_id":"public/index.html","hash":"4ee7e38b3c9491ddf08b7fef8fe7d8f1b76db0c2","modified":1630943440663},{"_id":"public/page/2/index.html","hash":"9ee4e3cba08d455b261f729d47c390da4c6fbffe","modified":1630942681562},{"_id":"public/page/3/index.html","hash":"be4ca834e1f687dc7ad37419e6b7a9cfca08334b","modified":1630942681562},{"_id":"public/img/1024.png","hash":"9879eec7a11ae45d7055c7245524a62b61041269","modified":1630942681562},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1630942681562},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1630942681562},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1630942681562},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1630942681562},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1630942681562},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1630942681562},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1630942681562},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1630942681562},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1630942681562},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1630942681562},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1630942681562},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1630942681562},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1630942681562},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1630942681562},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1630942681562},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1630942681562},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1630942681562},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1630942681562},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1630942681562},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1630942681562},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1630942681562},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1630942681562},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1630942681562},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1630942681562},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1630942681562},{"_id":"public/css/main.css","hash":"25344ebe0c2e4a0f0bcaa379d77c99226110ad0d","modified":1630942681562},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1630942681562},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1630942681562},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1630942681562},{"_id":"source/_posts/.obsidian/core-plugins.json","hash":"d702e5e11f463a1713d61d349870f9dc6afa7068","modified":1630943097469},{"_id":"source/_posts/.obsidian/app.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1630943097988},{"_id":"source/_posts/.obsidian/appearance.json","hash":"b017a0a713aed43620fea6ef13e8164a18169702","modified":1630943097992},{"_id":"source/_posts/.obsidian/workspace","hash":"c6ec1e090ad4b5b646c244790d173568c16ef3cf","modified":1630943393688},{"_id":"source/_posts/.obsidian/hotkeys.json","hash":"bf21a9e8fbc5a3846fb05b4fa0859e0917b2202f","modified":1630943096950}],"Category":[{"name":"日记","_id":"ckt8qfy9h00047sn61x99arw7"},{"name":"Swift","_id":"ckt8qfy9w000g7sn6fyh3g6z5"},{"name":"待续","_id":"ckt8qfyan001g7sn6f2tcewff"},{"name":"读书","_id":"ckt8qfyar001n7sn6appf82ge"},{"name":"Objective-C","_id":"ckt8qfyb300257sn66sm78l9o"}],"Data":[],"Page":[{"title":"paddleOCR","date":"2021-01-04T02:48:00.000Z","_content":"","source":"paddleOCR/index.md","raw":"---\ntitle: paddleOCR\ndate: 2021-01-04 10:48:00\n---\n","updated":"2021-01-04T02:48:00.000Z","path":"paddleOCR/index.html","comments":1,"layout":"page","_id":"ckt8qfy9400007sn64lqt4isy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"待续","date":"2017-11-01T09:01:22.000Z","type":"待续","comments":0,"_content":"","source":"待续/index.md","raw":"---\ntitle: 待续\ndate: 2017-11-01 17:01:22\ntype: \"待续\"\ncomments: false\n---\n","updated":"2017-11-02T01:43:31.000Z","path":"待续/index.html","layout":"page","_id":"ckt8qfy9c00027sn66ji64i8p","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Objective-C","date":"2018-06-23T09:55:40.000Z","_content":"","source":"Objective-C/index.md","raw":"---\ntitle: Objective-C\ndate: 2018-06-23 17:55:40\n---\n","updated":"2018-06-23T09:55:40.072Z","path":"Objective-C/index.html","comments":1,"layout":"page","_id":"ckt8qfy9k00067sn6gkl9e7uh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"读书","date":"2017-11-01T09:00:34.000Z","type":"读书","comments":0,"_content":"","source":"读书/index.md","raw":"---\ntitle: 读书\ndate: 2017-11-01 17:00:34\ntype: \"读书\"\ncomments: false\n---\n","updated":"2017-11-02T01:43:21.000Z","path":"读书/index.html","layout":"page","_id":"ckt8qfy9n00087sn62jo21zby","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"日记","date":"2017-11-01T09:00:46.000Z","type":"日记","comments":0,"_content":"","source":"日记/index.md","raw":"---\ntitle: 日记\ndate: 2017-11-01 17:00:46\ntype: \"日记\"\ncomments: false\n---\n","updated":"2017-11-02T01:42:39.000Z","path":"日记/index.html","layout":"page","_id":"ckt8qfy9p000a7sn6c60f3ira","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"日记","title":"2017年末总结","date":"2018-01-01T14:34:53.000Z","_content":"忽然之间 2017 年就已经一去不复返了，这一年应该是从毕业以来感觉过的最快的一年了,虽然也才毕业没多久。这一年感觉发生了很多的事情，忽然就已经到了年末。开始试着总结一下今年的事情吧。\n<!---more---->\n<p>17年初，由于上家公司的裁员，便早早休了春节，也算是之前加了那么久的班给我发了一个很长的假，可惜没有工资（笑）。过年后也在成都找了一段时间的工作，不过还是没遇到合适的啊，看来 iOS 的行情还是很严峻啊。一个人在外地还是辛苦些，便有了想回家工作的想法，3月份就从成都回到了沈阳。和一起在成都租住的大学同学们也算正式告别了，再相聚可能就要等谁结婚了吧。</p>\n<p>回到沈阳了还是感觉亲切些，毕竟这是我生活了20多年的地方。找工作倒也还算是顺利，虽然沈阳的公司确实挺少的，面试机会并不多，但好在还算找到了一个比较满意的公司。新公司并不是很忙碌，工作量也并不是很大，这正是我希望的。因为这样我就有时间去学习去思考新的技术，今年的收获还是蛮大的，公司因开发的项目可以使用 Swift，正好也学习了一下苹果新推出的开发语言。之前还是对 Swift 比较抵触的，觉得用好了 Objective-C 就可以了，完全没有必要去学习使用 Swift。不过了解了 Swift 之后才发现，这一定是将来的趋势，Objective-C 被淘汰的时间可能会比想象中的要快，反正现在要我去重新写 Objective-C 的项目，我应该会十分抗拒吧，哈哈。\n<p>今年学习到的新内容真的挺多的，也幸好在这家公司。让我有精力去学习去思考新技术，不光学习了 Swift，还让我学习到了响应式编程、函数式编程，了解使用 RxSwift 这个牛逼的框架。也去仔细思考了在开发时使用更合理的设计模式，重新复习了一下 C 语言，现在一想在学校的时候还是太偷懒了，如果当时很认真的去学习的话，可能现在的水平会更上一层。对了还学习了一下汇编，不过今年只学习了异步，2018还是要把下半本书继续啃完，也不知道自己能消化多少。哦对了，还有自己搭建了自己的VPS，自已一直想用VPS赚一些外快，可惜一直没找到什么门路，来年在学习看看吧。今年给我最大的收获应该就是知道自己还有很多不足，需要不断地学习，之前实在是浪费了大把的时间，没有在学校的时候把基础打牢，到用的时候明显不够用了。</p>\n<p>2017年还是蛮充实的一年的，算是指引了我以后想走的路。2018年我会去哪里呢？我想应该不再是家里了吧，2017年就当是休息充电的一年，在家里还是太过安逸了，我还是想去外边的城市看看，去了解最新的技术，去接触更加优秀的人。想让自己变得优秀，最简单的方法就是多和优秀的人接触，对此，我是深信不疑的。2018年我想应该还是做 iOS 开发吧，不过我还是希望能做 iOS 安全逆向的一些工作，虽然在这方面我没有什么经验，不过总要向着自己希望的方向走吧。2018 年我也希望能够做一些 MAC 软件的开发，听说苹果公司决定以后手机和电脑的开发平台整合到一起，也就是说手机开发也能够直接进行系统软件的开发了。这可能在 2018 年不会实现，但是以后肯定是会实现的，早些了解总没有什么坏处。</p>\n<p>最后，就这样吧。2018年了，我也27岁了。听起来有些可怕啊。怎么突然20多岁就快要过完了呢？身边的同事也都比我小2岁以上了，时间好快啊。</p>","source":"_posts/2017年末总结.md","raw":"---\nlayout: 日记\ntitle: 2017年末总结\ndate: 2018-01-01 22:34:53\ntags:\n- 日记\n- 随笔\ncategories:\n- 日记\n---\n忽然之间 2017 年就已经一去不复返了，这一年应该是从毕业以来感觉过的最快的一年了,虽然也才毕业没多久。这一年感觉发生了很多的事情，忽然就已经到了年末。开始试着总结一下今年的事情吧。\n<!---more---->\n<p>17年初，由于上家公司的裁员，便早早休了春节，也算是之前加了那么久的班给我发了一个很长的假，可惜没有工资（笑）。过年后也在成都找了一段时间的工作，不过还是没遇到合适的啊，看来 iOS 的行情还是很严峻啊。一个人在外地还是辛苦些，便有了想回家工作的想法，3月份就从成都回到了沈阳。和一起在成都租住的大学同学们也算正式告别了，再相聚可能就要等谁结婚了吧。</p>\n<p>回到沈阳了还是感觉亲切些，毕竟这是我生活了20多年的地方。找工作倒也还算是顺利，虽然沈阳的公司确实挺少的，面试机会并不多，但好在还算找到了一个比较满意的公司。新公司并不是很忙碌，工作量也并不是很大，这正是我希望的。因为这样我就有时间去学习去思考新的技术，今年的收获还是蛮大的，公司因开发的项目可以使用 Swift，正好也学习了一下苹果新推出的开发语言。之前还是对 Swift 比较抵触的，觉得用好了 Objective-C 就可以了，完全没有必要去学习使用 Swift。不过了解了 Swift 之后才发现，这一定是将来的趋势，Objective-C 被淘汰的时间可能会比想象中的要快，反正现在要我去重新写 Objective-C 的项目，我应该会十分抗拒吧，哈哈。\n<p>今年学习到的新内容真的挺多的，也幸好在这家公司。让我有精力去学习去思考新技术，不光学习了 Swift，还让我学习到了响应式编程、函数式编程，了解使用 RxSwift 这个牛逼的框架。也去仔细思考了在开发时使用更合理的设计模式，重新复习了一下 C 语言，现在一想在学校的时候还是太偷懒了，如果当时很认真的去学习的话，可能现在的水平会更上一层。对了还学习了一下汇编，不过今年只学习了异步，2018还是要把下半本书继续啃完，也不知道自己能消化多少。哦对了，还有自己搭建了自己的VPS，自已一直想用VPS赚一些外快，可惜一直没找到什么门路，来年在学习看看吧。今年给我最大的收获应该就是知道自己还有很多不足，需要不断地学习，之前实在是浪费了大把的时间，没有在学校的时候把基础打牢，到用的时候明显不够用了。</p>\n<p>2017年还是蛮充实的一年的，算是指引了我以后想走的路。2018年我会去哪里呢？我想应该不再是家里了吧，2017年就当是休息充电的一年，在家里还是太过安逸了，我还是想去外边的城市看看，去了解最新的技术，去接触更加优秀的人。想让自己变得优秀，最简单的方法就是多和优秀的人接触，对此，我是深信不疑的。2018年我想应该还是做 iOS 开发吧，不过我还是希望能做 iOS 安全逆向的一些工作，虽然在这方面我没有什么经验，不过总要向着自己希望的方向走吧。2018 年我也希望能够做一些 MAC 软件的开发，听说苹果公司决定以后手机和电脑的开发平台整合到一起，也就是说手机开发也能够直接进行系统软件的开发了。这可能在 2018 年不会实现，但是以后肯定是会实现的，早些了解总没有什么坏处。</p>\n<p>最后，就这样吧。2018年了，我也27岁了。听起来有些可怕啊。怎么突然20多岁就快要过完了呢？身边的同事也都比我小2岁以上了，时间好快啊。</p>","slug":"2017年末总结","published":1,"updated":"2021-01-01T14:49:21.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfy9800017sn63slu8c2z","content":"<p>忽然之间 2017 年就已经一去不复返了，这一年应该是从毕业以来感觉过的最快的一年了,虽然也才毕业没多久。这一年感觉发生了很多的事情，忽然就已经到了年末。开始试着总结一下今年的事情吧。</p>\n<!---more---->\n<p>17年初，由于上家公司的裁员，便早早休了春节，也算是之前加了那么久的班给我发了一个很长的假，可惜没有工资（笑）。过年后也在成都找了一段时间的工作，不过还是没遇到合适的啊，看来 iOS 的行情还是很严峻啊。一个人在外地还是辛苦些，便有了想回家工作的想法，3月份就从成都回到了沈阳。和一起在成都租住的大学同学们也算正式告别了，再相聚可能就要等谁结婚了吧。</p>\n<p>回到沈阳了还是感觉亲切些，毕竟这是我生活了20多年的地方。找工作倒也还算是顺利，虽然沈阳的公司确实挺少的，面试机会并不多，但好在还算找到了一个比较满意的公司。新公司并不是很忙碌，工作量也并不是很大，这正是我希望的。因为这样我就有时间去学习去思考新的技术，今年的收获还是蛮大的，公司因开发的项目可以使用 Swift，正好也学习了一下苹果新推出的开发语言。之前还是对 Swift 比较抵触的，觉得用好了 Objective-C 就可以了，完全没有必要去学习使用 Swift。不过了解了 Swift 之后才发现，这一定是将来的趋势，Objective-C 被淘汰的时间可能会比想象中的要快，反正现在要我去重新写 Objective-C 的项目，我应该会十分抗拒吧，哈哈。\n<p>今年学习到的新内容真的挺多的，也幸好在这家公司。让我有精力去学习去思考新技术，不光学习了 Swift，还让我学习到了响应式编程、函数式编程，了解使用 RxSwift 这个牛逼的框架。也去仔细思考了在开发时使用更合理的设计模式，重新复习了一下 C 语言，现在一想在学校的时候还是太偷懒了，如果当时很认真的去学习的话，可能现在的水平会更上一层。对了还学习了一下汇编，不过今年只学习了异步，2018还是要把下半本书继续啃完，也不知道自己能消化多少。哦对了，还有自己搭建了自己的VPS，自已一直想用VPS赚一些外快，可惜一直没找到什么门路，来年在学习看看吧。今年给我最大的收获应该就是知道自己还有很多不足，需要不断地学习，之前实在是浪费了大把的时间，没有在学校的时候把基础打牢，到用的时候明显不够用了。</p>\n<p>2017年还是蛮充实的一年的，算是指引了我以后想走的路。2018年我会去哪里呢？我想应该不再是家里了吧，2017年就当是休息充电的一年，在家里还是太过安逸了，我还是想去外边的城市看看，去了解最新的技术，去接触更加优秀的人。想让自己变得优秀，最简单的方法就是多和优秀的人接触，对此，我是深信不疑的。2018年我想应该还是做 iOS 开发吧，不过我还是希望能做 iOS 安全逆向的一些工作，虽然在这方面我没有什么经验，不过总要向着自己希望的方向走吧。2018 年我也希望能够做一些 MAC 软件的开发，听说苹果公司决定以后手机和电脑的开发平台整合到一起，也就是说手机开发也能够直接进行系统软件的开发了。这可能在 2018 年不会实现，但是以后肯定是会实现的，早些了解总没有什么坏处。</p>\n<p>最后，就这样吧。2018年了，我也27岁了。听起来有些可怕啊。怎么突然20多岁就快要过完了呢？身边的同事也都比我小2岁以上了，时间好快啊。</p>","site":{"data":{}},"excerpt":"","more":"<p>忽然之间 2017 年就已经一去不复返了，这一年应该是从毕业以来感觉过的最快的一年了,虽然也才毕业没多久。这一年感觉发生了很多的事情，忽然就已经到了年末。开始试着总结一下今年的事情吧。</p>\n<!---more---->\n<p>17年初，由于上家公司的裁员，便早早休了春节，也算是之前加了那么久的班给我发了一个很长的假，可惜没有工资（笑）。过年后也在成都找了一段时间的工作，不过还是没遇到合适的啊，看来 iOS 的行情还是很严峻啊。一个人在外地还是辛苦些，便有了想回家工作的想法，3月份就从成都回到了沈阳。和一起在成都租住的大学同学们也算正式告别了，再相聚可能就要等谁结婚了吧。</p>\n<p>回到沈阳了还是感觉亲切些，毕竟这是我生活了20多年的地方。找工作倒也还算是顺利，虽然沈阳的公司确实挺少的，面试机会并不多，但好在还算找到了一个比较满意的公司。新公司并不是很忙碌，工作量也并不是很大，这正是我希望的。因为这样我就有时间去学习去思考新的技术，今年的收获还是蛮大的，公司因开发的项目可以使用 Swift，正好也学习了一下苹果新推出的开发语言。之前还是对 Swift 比较抵触的，觉得用好了 Objective-C 就可以了，完全没有必要去学习使用 Swift。不过了解了 Swift 之后才发现，这一定是将来的趋势，Objective-C 被淘汰的时间可能会比想象中的要快，反正现在要我去重新写 Objective-C 的项目，我应该会十分抗拒吧，哈哈。\n<p>今年学习到的新内容真的挺多的，也幸好在这家公司。让我有精力去学习去思考新技术，不光学习了 Swift，还让我学习到了响应式编程、函数式编程，了解使用 RxSwift 这个牛逼的框架。也去仔细思考了在开发时使用更合理的设计模式，重新复习了一下 C 语言，现在一想在学校的时候还是太偷懒了，如果当时很认真的去学习的话，可能现在的水平会更上一层。对了还学习了一下汇编，不过今年只学习了异步，2018还是要把下半本书继续啃完，也不知道自己能消化多少。哦对了，还有自己搭建了自己的VPS，自已一直想用VPS赚一些外快，可惜一直没找到什么门路，来年在学习看看吧。今年给我最大的收获应该就是知道自己还有很多不足，需要不断地学习，之前实在是浪费了大把的时间，没有在学校的时候把基础打牢，到用的时候明显不够用了。</p>\n<p>2017年还是蛮充实的一年的，算是指引了我以后想走的路。2018年我会去哪里呢？我想应该不再是家里了吧，2017年就当是休息充电的一年，在家里还是太过安逸了，我还是想去外边的城市看看，去了解最新的技术，去接触更加优秀的人。想让自己变得优秀，最简单的方法就是多和优秀的人接触，对此，我是深信不疑的。2018年我想应该还是做 iOS 开发吧，不过我还是希望能做 iOS 安全逆向的一些工作，虽然在这方面我没有什么经验，不过总要向着自己希望的方向走吧。2018 年我也希望能够做一些 MAC 软件的开发，听说苹果公司决定以后手机和电脑的开发平台整合到一起，也就是说手机开发也能够直接进行系统软件的开发了。这可能在 2018 年不会实现，但是以后肯定是会实现的，早些了解总没有什么坏处。</p>\n<p>最后，就这样吧。2018年了，我也27岁了。听起来有些可怕啊。怎么突然20多岁就快要过完了呢？身边的同事也都比我小2岁以上了，时间好快啊。</p>"},{"layout":"日记","title":"2020年末总结","date":"2021-01-01T14:47:59.000Z","_content":"2021 年的第一个日子马上就要过去了，猛然发现自己去年居然一点文字都没有留下。想写下些什么但是又不知从何写起。2020 年也是挺魔幻的一年，就在此记录下。\n<!-- more -->\n疫情就是今年最大的记忆点了吧，开年在家办公了一个月，年末的最后一天依旧也是在家办公，也是有始有终。\n\n技术上今年的进步并不明显，OpenCV 的学习使用还是停留在比较基础层面。倒是 xib 的使用有了一些进步，感觉现在已经进入了舒适区，并不愿意学习新东西了，有些懒惰。今天也尝试学习了 AR 相关的内容，但是并不系统，所以效果也并不好。\n\n2020 年买了很多视频课，但是却没有认真的看完。新的一年要努力把之前欠下的补上了。把欠下的书认真读完，买的视频课好好看看，今年要学会滑雪啊！","source":"_posts/2020年末总结.md","raw":"---\nlayout: 日记\ntitle: 2020年末总结\ndate: 2021-01-01 22:47:59\ntags:\n- 日记\n- 随笔\ncategories:\n- 日记\n---\n2021 年的第一个日子马上就要过去了，猛然发现自己去年居然一点文字都没有留下。想写下些什么但是又不知从何写起。2020 年也是挺魔幻的一年，就在此记录下。\n<!-- more -->\n疫情就是今年最大的记忆点了吧，开年在家办公了一个月，年末的最后一天依旧也是在家办公，也是有始有终。\n\n技术上今年的进步并不明显，OpenCV 的学习使用还是停留在比较基础层面。倒是 xib 的使用有了一些进步，感觉现在已经进入了舒适区，并不愿意学习新东西了，有些懒惰。今天也尝试学习了 AR 相关的内容，但是并不系统，所以效果也并不好。\n\n2020 年买了很多视频课，但是却没有认真的看完。新的一年要努力把之前欠下的补上了。把欠下的书认真读完，买的视频课好好看看，今年要学会滑雪啊！","slug":"2020年末总结","published":1,"updated":"2021-09-06T15:48:17.443Z","_id":"ckt8qfy9d00037sn6btqwfydt","comments":1,"photos":[],"link":"","content":"<p>2021 年的第一个日子马上就要过去了，猛然发现自己去年居然一点文字都没有留下。想写下些什么但是又不知从何写起。2020 年也是挺魔幻的一年，就在此记录下。</p>\n<span id=\"more\"></span>\n<p>疫情就是今年最大的记忆点了吧，开年在家办公了一个月，年末的最后一天依旧也是在家办公，也是有始有终。</p>\n<p>技术上今年的进步并不明显，OpenCV 的学习使用还是停留在比较基础层面。倒是 xib 的使用有了一些进步，感觉现在已经进入了舒适区，并不愿意学习新东西了，有些懒惰。今天也尝试学习了 AR 相关的内容，但是并不系统，所以效果也并不好。</p>\n<p>2020 年买了很多视频课，但是却没有认真的看完。新的一年要努力把之前欠下的补上了。把欠下的书认真读完，买的视频课好好看看，今年要学会滑雪啊！</p>\n","site":{"data":{}},"excerpt":"<p>2021 年的第一个日子马上就要过去了，猛然发现自己去年居然一点文字都没有留下。想写下些什么但是又不知从何写起。2020 年也是挺魔幻的一年，就在此记录下。</p>","more":"<p>疫情就是今年最大的记忆点了吧，开年在家办公了一个月，年末的最后一天依旧也是在家办公，也是有始有终。</p>\n<p>技术上今年的进步并不明显，OpenCV 的学习使用还是停留在比较基础层面。倒是 xib 的使用有了一些进步，感觉现在已经进入了舒适区，并不愿意学习新东西了，有些懒惰。今天也尝试学习了 AR 相关的内容，但是并不系统，所以效果也并不好。</p>\n<p>2020 年买了很多视频课，但是却没有认真的看完。新的一年要努力把之前欠下的补上了。把欠下的书认真读完，买的视频课好好看看，今年要学会滑雪啊！</p>"},{"layout":"swift","title":"MVVM 设计模式笔记","date":"2017-11-14T06:52:35.000Z","_content":"很早就听说过 MVVM 系统模式，但是都是一知半解的。这次就借助泊学网视频重新搭建一个查看天气的项目，系统的研究一下 MVVM 设计模式。\n<!--- more --->\n#### 概述\n简易的画了一个 MVVM 设计图。整体流程如下，接下来将根据这个图进行设计。\n![MVVM](https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/MVVM%E6%A6%82%E8%BF%B0.jpg?raw=true)\n#### 准备工作\n搭建好项目 Sky，并准备好图片。![](https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png?raw=true)\n准备好需要的数据接口，这里使用了 [DarkSky](https://darksky.net/dev) 接口的。\n#### UI搭建 （View）\n平时的项目很少都不会使用 StroyBoard，所以借着这个机会使用一下。文字不太好描述，这里直接贴图了。![](https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/StoryBoard.png?raw=true)\nView 上的控件记得连接在 Controller 上！\n#### Model创建\n这里偷懒直接用 CuteBaby 生成了我们需要的 Model 格式。注意处理好 Model 中嵌套的 struct 名称，尽量不要重名，防止将自己弄混。\n#### ViewModel创建\nViewModel 更多的是让 Controller 从数据处理中解放出来，所以在 Controller 文件夹中单独创建 ViewModels 文件夹，并且将相关代码文件放入其中。\nViewModel 负责处理 Model 中传过来的数据。通过重写 set 方法将 Model 获取，并写好其他属性的 get 方法将数据向外传递。\n\n```\nvar weather: WeatherData! {\n        didSet {\n            if weather != nil {\n                self.isWeatherReady = true\n            }\n            else {\n                self.isWeatherReady = false\n            }\n        }\n    }\nvar summary: String {\n        return weather.currently.summary\n    }\n\n```\n#### Controller搭建\n整体的业务逻辑就可以在 Controller 上进行了，最为重要的部分就是将各个部分的连通，确保能够进行数据的传递。以下几点是比较关键的部分，注意不要忘记实现。\n1. 让 Controller 持有 ViewModel 对象，并重写 Set 方法来刷新 UI.\n2. 将 ViewModel 的数据传递给 View，保证 View 能够显示出 ViewModel 的内容。\n3. 让 Controller 持有 View 控件的点击方法，并能够通过代理将方法传递给其他对象。\n\n#### 处理数据逻辑、业务逻辑\n现在四个基本的元素 M、V、VM 和 C 都已经准备完成。接下来就是关键的数据绑定了，像管道一样逐步将数据传递下去。开始调用方法请求数据就是管道的起点。在 Controller 中需要进行数据请求的地方实现下面的方法。\n\n```\nWeatherDataManager.shared.weatherDataAt(\n            latitude: lat,\n            longtitude: lon,\n            completion: { response, error in\n                if let error = error {\n                    dump(error)\n                }else if let response = response {\n                    self.currentWeatherViewController.viewModel?.weather = response\n                    self.weekWeatherViewController.viewModel = WeekWeatherViewModel(weatherData: response.daily.data)\n                }\n        })\n```\n整体的数据绑定思路如下:\n1. 获取地理位置将参数传递给获取天气的方法，以此来获取数据 Model。\n2. 通过回调获取到 response， 就是获取到 Model 传递给 ViewModel。\n3. 让子页的 Controller 持有的 ViewModel 进行赋值。\n4. 通过重写子页 Controller 中 ViewModel 的 Set 方法，调用 `updateView()` 方法，对子页 Controller 持有的 View 进行刷新赋值。注意：关于 UI 的刷新需要在主线程中进行。\n\n至此，由 Controller -> Model -> ViewModel -> View 的单向数据绑定已经完成。\n接下来就是实现修改 View 上的的点击时间实现更新 Model。就是从 View -> Controller -> ViewModel -> Model。\n整体思路如下：\n1. 由 View 控件获取点击事件，将点击方法传递(通过代理或者 Block )给 Controller。\n2. 修改后的数据通过 Controller 持有的 ViewModel传递。\n3. 修改 ViewModel 中保存的 Model。\n\n关于 MVVM 简单的双向数据绑定就算完成了，更多的使用可以借助一下三方框架，如 RxSwift。","source":"_posts/MVVM设计模式笔记.md","raw":"---\nlayout: swift\ntitle: MVVM 设计模式笔记\ndate: 2017-11-14 14:52:35\ntags: \n- Swift\ncategories: \n- Swift\n---\n很早就听说过 MVVM 系统模式，但是都是一知半解的。这次就借助泊学网视频重新搭建一个查看天气的项目，系统的研究一下 MVVM 设计模式。\n<!--- more --->\n#### 概述\n简易的画了一个 MVVM 设计图。整体流程如下，接下来将根据这个图进行设计。\n![MVVM](https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/MVVM%E6%A6%82%E8%BF%B0.jpg?raw=true)\n#### 准备工作\n搭建好项目 Sky，并准备好图片。![](https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png?raw=true)\n准备好需要的数据接口，这里使用了 [DarkSky](https://darksky.net/dev) 接口的。\n#### UI搭建 （View）\n平时的项目很少都不会使用 StroyBoard，所以借着这个机会使用一下。文字不太好描述，这里直接贴图了。![](https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/StoryBoard.png?raw=true)\nView 上的控件记得连接在 Controller 上！\n#### Model创建\n这里偷懒直接用 CuteBaby 生成了我们需要的 Model 格式。注意处理好 Model 中嵌套的 struct 名称，尽量不要重名，防止将自己弄混。\n#### ViewModel创建\nViewModel 更多的是让 Controller 从数据处理中解放出来，所以在 Controller 文件夹中单独创建 ViewModels 文件夹，并且将相关代码文件放入其中。\nViewModel 负责处理 Model 中传过来的数据。通过重写 set 方法将 Model 获取，并写好其他属性的 get 方法将数据向外传递。\n\n```\nvar weather: WeatherData! {\n        didSet {\n            if weather != nil {\n                self.isWeatherReady = true\n            }\n            else {\n                self.isWeatherReady = false\n            }\n        }\n    }\nvar summary: String {\n        return weather.currently.summary\n    }\n\n```\n#### Controller搭建\n整体的业务逻辑就可以在 Controller 上进行了，最为重要的部分就是将各个部分的连通，确保能够进行数据的传递。以下几点是比较关键的部分，注意不要忘记实现。\n1. 让 Controller 持有 ViewModel 对象，并重写 Set 方法来刷新 UI.\n2. 将 ViewModel 的数据传递给 View，保证 View 能够显示出 ViewModel 的内容。\n3. 让 Controller 持有 View 控件的点击方法，并能够通过代理将方法传递给其他对象。\n\n#### 处理数据逻辑、业务逻辑\n现在四个基本的元素 M、V、VM 和 C 都已经准备完成。接下来就是关键的数据绑定了，像管道一样逐步将数据传递下去。开始调用方法请求数据就是管道的起点。在 Controller 中需要进行数据请求的地方实现下面的方法。\n\n```\nWeatherDataManager.shared.weatherDataAt(\n            latitude: lat,\n            longtitude: lon,\n            completion: { response, error in\n                if let error = error {\n                    dump(error)\n                }else if let response = response {\n                    self.currentWeatherViewController.viewModel?.weather = response\n                    self.weekWeatherViewController.viewModel = WeekWeatherViewModel(weatherData: response.daily.data)\n                }\n        })\n```\n整体的数据绑定思路如下:\n1. 获取地理位置将参数传递给获取天气的方法，以此来获取数据 Model。\n2. 通过回调获取到 response， 就是获取到 Model 传递给 ViewModel。\n3. 让子页的 Controller 持有的 ViewModel 进行赋值。\n4. 通过重写子页 Controller 中 ViewModel 的 Set 方法，调用 `updateView()` 方法，对子页 Controller 持有的 View 进行刷新赋值。注意：关于 UI 的刷新需要在主线程中进行。\n\n至此，由 Controller -> Model -> ViewModel -> View 的单向数据绑定已经完成。\n接下来就是实现修改 View 上的的点击时间实现更新 Model。就是从 View -> Controller -> ViewModel -> Model。\n整体思路如下：\n1. 由 View 控件获取点击事件，将点击方法传递(通过代理或者 Block )给 Controller。\n2. 修改后的数据通过 Controller 持有的 ViewModel传递。\n3. 修改 ViewModel 中保存的 Model。\n\n关于 MVVM 简单的双向数据绑定就算完成了，更多的使用可以借助一下三方框架，如 RxSwift。","slug":"MVVM设计模式笔记","published":1,"updated":"2017-11-14T09:20:30.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfy9l00077sn64wd6aqxo","content":"<p>很早就听说过 MVVM 系统模式，但是都是一知半解的。这次就借助泊学网视频重新搭建一个查看天气的项目，系统的研究一下 MVVM 设计模式。</p>\n<!--- more --->\n<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>简易的画了一个 MVVM 设计图。整体流程如下，接下来将根据这个图进行设计。<br><img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/MVVM%E6%A6%82%E8%BF%B0.jpg?raw=true\" alt=\"MVVM\"></p>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>搭建好项目 Sky，并准备好图片。<img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png?raw=true\"><br>准备好需要的数据接口，这里使用了 <a href=\"https://darksky.net/dev\">DarkSky</a> 接口的。</p>\n<h4 id=\"UI搭建-（View）\"><a href=\"#UI搭建-（View）\" class=\"headerlink\" title=\"UI搭建 （View）\"></a>UI搭建 （View）</h4><p>平时的项目很少都不会使用 StroyBoard，所以借着这个机会使用一下。文字不太好描述，这里直接贴图了。<img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/StoryBoard.png?raw=true\"><br>View 上的控件记得连接在 Controller 上！</p>\n<h4 id=\"Model创建\"><a href=\"#Model创建\" class=\"headerlink\" title=\"Model创建\"></a>Model创建</h4><p>这里偷懒直接用 CuteBaby 生成了我们需要的 Model 格式。注意处理好 Model 中嵌套的 struct 名称，尽量不要重名，防止将自己弄混。</p>\n<h4 id=\"ViewModel创建\"><a href=\"#ViewModel创建\" class=\"headerlink\" title=\"ViewModel创建\"></a>ViewModel创建</h4><p>ViewModel 更多的是让 Controller 从数据处理中解放出来，所以在 Controller 文件夹中单独创建 ViewModels 文件夹，并且将相关代码文件放入其中。<br>ViewModel 负责处理 Model 中传过来的数据。通过重写 set 方法将 Model 获取，并写好其他属性的 get 方法将数据向外传递。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> weather: <span class=\"type\">WeatherData</span>! &#123;</span><br><span class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> weather <span class=\"operator\">!=</span> <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.isWeatherReady <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.isWeatherReady <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> summary: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> weather.currently.summary</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"Controller搭建\"><a href=\"#Controller搭建\" class=\"headerlink\" title=\"Controller搭建\"></a>Controller搭建</h4><p>整体的业务逻辑就可以在 Controller 上进行了，最为重要的部分就是将各个部分的连通，确保能够进行数据的传递。以下几点是比较关键的部分，注意不要忘记实现。</p>\n<ol>\n<li>让 Controller 持有 ViewModel 对象，并重写 Set 方法来刷新 UI.</li>\n<li>将 ViewModel 的数据传递给 View，保证 View 能够显示出 ViewModel 的内容。</li>\n<li>让 Controller 持有 View 控件的点击方法，并能够通过代理将方法传递给其他对象。</li>\n</ol>\n<h4 id=\"处理数据逻辑、业务逻辑\"><a href=\"#处理数据逻辑、业务逻辑\" class=\"headerlink\" title=\"处理数据逻辑、业务逻辑\"></a>处理数据逻辑、业务逻辑</h4><p>现在四个基本的元素 M、V、VM 和 C 都已经准备完成。接下来就是关键的数据绑定了，像管道一样逐步将数据传递下去。开始调用方法请求数据就是管道的起点。在 Controller 中需要进行数据请求的地方实现下面的方法。</p>\n<figure class=\"highlight vbscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WeatherDataManager.shared.weatherDataAt(</span><br><span class=\"line\">            latitude: lat,</span><br><span class=\"line\">            longtitude: lon,</span><br><span class=\"line\">            completion: &#123; <span class=\"built_in\">response</span>, <span class=\"keyword\">error</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"keyword\">error</span> = <span class=\"keyword\">error</span> &#123;</span><br><span class=\"line\">                    dump(<span class=\"keyword\">error</span>)</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"built_in\">response</span> = <span class=\"built_in\">response</span> &#123;</span><br><span class=\"line\">                    self.currentWeatherViewController.viewModel?.weather = <span class=\"built_in\">response</span></span><br><span class=\"line\">                    self.weekWeatherViewController.viewModel = WeekWeatherViewModel(weatherData: <span class=\"built_in\">response</span>.daily.data)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;)</span><br></pre></td></tr></table></figure>\n<p>整体的数据绑定思路如下:</p>\n<ol>\n<li>获取地理位置将参数传递给获取天气的方法，以此来获取数据 Model。</li>\n<li>通过回调获取到 response， 就是获取到 Model 传递给 ViewModel。</li>\n<li>让子页的 Controller 持有的 ViewModel 进行赋值。</li>\n<li>通过重写子页 Controller 中 ViewModel 的 Set 方法，调用 <code>updateView()</code> 方法，对子页 Controller 持有的 View 进行刷新赋值。注意：关于 UI 的刷新需要在主线程中进行。</li>\n</ol>\n<p>至此，由 Controller -&gt; Model -&gt; ViewModel -&gt; View 的单向数据绑定已经完成。<br>接下来就是实现修改 View 上的的点击时间实现更新 Model。就是从 View -&gt; Controller -&gt; ViewModel -&gt; Model。<br>整体思路如下：</p>\n<ol>\n<li>由 View 控件获取点击事件，将点击方法传递(通过代理或者 Block )给 Controller。</li>\n<li>修改后的数据通过 Controller 持有的 ViewModel传递。</li>\n<li>修改 ViewModel 中保存的 Model。</li>\n</ol>\n<p>关于 MVVM 简单的双向数据绑定就算完成了，更多的使用可以借助一下三方框架，如 RxSwift。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>很早就听说过 MVVM 系统模式，但是都是一知半解的。这次就借助泊学网视频重新搭建一个查看天气的项目，系统的研究一下 MVVM 设计模式。</p>\n<!--- more --->\n<h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>简易的画了一个 MVVM 设计图。整体流程如下，接下来将根据这个图进行设计。<br><img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/MVVM%E6%A6%82%E8%BF%B0.jpg?raw=true\" alt=\"MVVM\"></p>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>搭建好项目 Sky，并准备好图片。<img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png?raw=true\"><br>准备好需要的数据接口，这里使用了 <a href=\"https://darksky.net/dev\">DarkSky</a> 接口的。</p>\n<h4 id=\"UI搭建-（View）\"><a href=\"#UI搭建-（View）\" class=\"headerlink\" title=\"UI搭建 （View）\"></a>UI搭建 （View）</h4><p>平时的项目很少都不会使用 StroyBoard，所以借着这个机会使用一下。文字不太好描述，这里直接贴图了。<img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/MVVM/StoryBoard.png?raw=true\"><br>View 上的控件记得连接在 Controller 上！</p>\n<h4 id=\"Model创建\"><a href=\"#Model创建\" class=\"headerlink\" title=\"Model创建\"></a>Model创建</h4><p>这里偷懒直接用 CuteBaby 生成了我们需要的 Model 格式。注意处理好 Model 中嵌套的 struct 名称，尽量不要重名，防止将自己弄混。</p>\n<h4 id=\"ViewModel创建\"><a href=\"#ViewModel创建\" class=\"headerlink\" title=\"ViewModel创建\"></a>ViewModel创建</h4><p>ViewModel 更多的是让 Controller 从数据处理中解放出来，所以在 Controller 文件夹中单独创建 ViewModels 文件夹，并且将相关代码文件放入其中。<br>ViewModel 负责处理 Model 中传过来的数据。通过重写 set 方法将 Model 获取，并写好其他属性的 get 方法将数据向外传递。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> weather: <span class=\"type\">WeatherData</span>! &#123;</span><br><span class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> weather <span class=\"operator\">!=</span> <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.isWeatherReady <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.isWeatherReady <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> summary: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> weather.currently.summary</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"Controller搭建\"><a href=\"#Controller搭建\" class=\"headerlink\" title=\"Controller搭建\"></a>Controller搭建</h4><p>整体的业务逻辑就可以在 Controller 上进行了，最为重要的部分就是将各个部分的连通，确保能够进行数据的传递。以下几点是比较关键的部分，注意不要忘记实现。</p>\n<ol>\n<li>让 Controller 持有 ViewModel 对象，并重写 Set 方法来刷新 UI.</li>\n<li>将 ViewModel 的数据传递给 View，保证 View 能够显示出 ViewModel 的内容。</li>\n<li>让 Controller 持有 View 控件的点击方法，并能够通过代理将方法传递给其他对象。</li>\n</ol>\n<h4 id=\"处理数据逻辑、业务逻辑\"><a href=\"#处理数据逻辑、业务逻辑\" class=\"headerlink\" title=\"处理数据逻辑、业务逻辑\"></a>处理数据逻辑、业务逻辑</h4><p>现在四个基本的元素 M、V、VM 和 C 都已经准备完成。接下来就是关键的数据绑定了，像管道一样逐步将数据传递下去。开始调用方法请求数据就是管道的起点。在 Controller 中需要进行数据请求的地方实现下面的方法。</p>\n<figure class=\"highlight vbscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WeatherDataManager.shared.weatherDataAt(</span><br><span class=\"line\">            latitude: lat,</span><br><span class=\"line\">            longtitude: lon,</span><br><span class=\"line\">            completion: &#123; <span class=\"built_in\">response</span>, <span class=\"keyword\">error</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"keyword\">error</span> = <span class=\"keyword\">error</span> &#123;</span><br><span class=\"line\">                    dump(<span class=\"keyword\">error</span>)</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"built_in\">response</span> = <span class=\"built_in\">response</span> &#123;</span><br><span class=\"line\">                    self.currentWeatherViewController.viewModel?.weather = <span class=\"built_in\">response</span></span><br><span class=\"line\">                    self.weekWeatherViewController.viewModel = WeekWeatherViewModel(weatherData: <span class=\"built_in\">response</span>.daily.data)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;)</span><br></pre></td></tr></table></figure>\n<p>整体的数据绑定思路如下:</p>\n<ol>\n<li>获取地理位置将参数传递给获取天气的方法，以此来获取数据 Model。</li>\n<li>通过回调获取到 response， 就是获取到 Model 传递给 ViewModel。</li>\n<li>让子页的 Controller 持有的 ViewModel 进行赋值。</li>\n<li>通过重写子页 Controller 中 ViewModel 的 Set 方法，调用 <code>updateView()</code> 方法，对子页 Controller 持有的 View 进行刷新赋值。注意：关于 UI 的刷新需要在主线程中进行。</li>\n</ol>\n<p>至此，由 Controller -&gt; Model -&gt; ViewModel -&gt; View 的单向数据绑定已经完成。<br>接下来就是实现修改 View 上的的点击时间实现更新 Model。就是从 View -&gt; Controller -&gt; ViewModel -&gt; Model。<br>整体思路如下：</p>\n<ol>\n<li>由 View 控件获取点击事件，将点击方法传递(通过代理或者 Block )给 Controller。</li>\n<li>修改后的数据通过 Controller 持有的 ViewModel传递。</li>\n<li>修改 ViewModel 中保存的 Model。</li>\n</ol>\n<p>关于 MVVM 简单的双向数据绑定就算完成了，更多的使用可以借助一下三方框架，如 RxSwift。</p>\n"},{"layout":"Moya 使用","title":"Moya 使用","date":"2018-02-06T08:54:57.000Z","_content":"Swift 经常用 Alamofire 来做网络库，而 Moya 在 Alamofire 的基础上又封装了一层。Moya 是你的 app 中缺失的网络层。不用再去想在哪儿（或者如何）安放网络请求，Moya 替你管理。\n<!---more--->\n##### 安装配置\n由于我在项目使用了 CocoaPods，而且也使用了 RxSwift 这个框架，所以直接在在 Podfile 文件中添加 `pod 'Moya/RxSwift'` 即可。\n##### 创建 APIManager\n[Moya 官方用例文档](https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/docs_CN/Examples/Basic.md)讲解的很清晰，使用前我们需要创建一个枚举，作为网络请求的 API 请求分类。\n先创建一个 APIManager.swift 用来统一处理的网络请求。然后创建 APIManager 枚举，用来区分不同的请求接口。\n\n```\nenum APIManager {\n    case getNetWorkRegion  ///> 判断国内国外  0---国外  1---中国\n}\n```\n##### 实现 TargetType 协议\n接下来对这个 APIManager 进行拓展，并且让它遵循 TargetType 协议。这个协议是 Moya 为了方便创建一个 MoayProvider，对网络请求进行一个统一的管理。\n\n```\nextension APIManager: TargetType {\n    var baseURL: URL { return URL(string: BASEURL)! }\n    var path: String { return \"\" }\n    var method: Moya.Method { return .post }\n    var sampleData: Data { return \"\".data(using: .utf8)! }\n    var headers: [String : String]? { return [\"Content-type\": \"application/json\"] }\n    \n    var task: Task {\n        var dict = [\"\": \"\"]\n        switch self {\n        case .getNetWorkRegion:\n            dict =  [\"action\": \"ping\"]\n        }\n        return .requestParameters(parameters: dict, encoding: URLEncoding.queryString)\n    }\n}\n```\n###### baseURL\n基本的网络请求，所有网络请求都会经过这个 URL 进行封装。\n###### path\n具体的网络请求路径，由于我项目中所有的请求都是通过同一个路径，所以这个返回值我并不需要添加任何信息。\n###### method\n网络请求方法，例如 post，get。\n###### sampleData\n单元测试时需要使用的模拟数据，可以自定设置。这个 sample data 个是 Data 实例对象, 它可以表示 JSON, images, text, 或者任何您希望从endpoint得到的.\n###### headers\n请求头部数据。\n###### task\n由于最新的 Moya 已经修改，参数直接在这个属性中进行处理。注意：因为我之前的 encoding 中的参数填写的是 `URLEncoding.default` 和 `JSONEncoding.default` 导致对参数编码处理错误，请求不到正确的 URL。这个接口需要填写 `URLEncoding.queryString` 才能请求成功。\n\n##### 进行网络请求\n我在项目中创建了新文件 HttpTool 来对不同接口的数据进行处理。也导入了 SwiftyJSON 方便处理请求数据。\n\n```\nfunc getNetWorkRegion() {\n    let provider = MoyaProvider<APIManager>()\n    provider.rx.request(.getNetWorkRegion).subscribe { event in\n        \n        switch event {\n        case .success(let response):\n            K_CONFIGJSON.rg = JSON(response.data)[\"rg\"].stringValue\n        case .error(_):\n            K_CONFIGJSON.rg = \"1\"      // 默认为 1---中国\n        }\n    }.disposed(by: bag)\n}\n```\n##### 打印请求日志\n[官方](https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/Sources/Moya/Plugins/NetworkLoggerPlugin.swift)自带了一个插件来管理打印信息，但是这个插件打印信息太过全面，信息太多反而不好查看。我们可以通过[创建自定义插件](https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/docs_CN/Examples/CustomPlugin.md)的方式来实现我们的需求。\n创建一个类来遵循 PluginType 协议，并且实现协议方法。\n\n```\nfinal class HYNetWorkPlugin: PluginType {\n    func willSend(_ request: RequestType, target: TargetType) {\n        let req = request.request?.description ?? \"无效的请求链接\"\n        print(\"++++++++++++++++\\n\\(req)\\n++++++++++++++++\")\n    }\n}\n```\n使用这个插件十分简单，只需要在创建的时候将插件对象作为参数传递到初始化方法中即可：\n\n\tlet provider = MoyaProvider<APIManager>(plugins: [HYNetWorkPlugin()])\n\n##### 参考资料\n\n> [Moya 官方中文文档](https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/docs_CN/README.md)\n> [Swift - 网络抽象层库Moya的使用详解](http://www.hangge.com/blog/cache/detail_1797.html)","source":"_posts/Moya 使用笔记.md","raw":"---\nlayout: Moya 使用\ntitle: Moya 使用\ndate: 2018-02-06 16:54:57\ntags: \n- Swift\ncategories: \n- Swift\n---\nSwift 经常用 Alamofire 来做网络库，而 Moya 在 Alamofire 的基础上又封装了一层。Moya 是你的 app 中缺失的网络层。不用再去想在哪儿（或者如何）安放网络请求，Moya 替你管理。\n<!---more--->\n##### 安装配置\n由于我在项目使用了 CocoaPods，而且也使用了 RxSwift 这个框架，所以直接在在 Podfile 文件中添加 `pod 'Moya/RxSwift'` 即可。\n##### 创建 APIManager\n[Moya 官方用例文档](https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/docs_CN/Examples/Basic.md)讲解的很清晰，使用前我们需要创建一个枚举，作为网络请求的 API 请求分类。\n先创建一个 APIManager.swift 用来统一处理的网络请求。然后创建 APIManager 枚举，用来区分不同的请求接口。\n\n```\nenum APIManager {\n    case getNetWorkRegion  ///> 判断国内国外  0---国外  1---中国\n}\n```\n##### 实现 TargetType 协议\n接下来对这个 APIManager 进行拓展，并且让它遵循 TargetType 协议。这个协议是 Moya 为了方便创建一个 MoayProvider，对网络请求进行一个统一的管理。\n\n```\nextension APIManager: TargetType {\n    var baseURL: URL { return URL(string: BASEURL)! }\n    var path: String { return \"\" }\n    var method: Moya.Method { return .post }\n    var sampleData: Data { return \"\".data(using: .utf8)! }\n    var headers: [String : String]? { return [\"Content-type\": \"application/json\"] }\n    \n    var task: Task {\n        var dict = [\"\": \"\"]\n        switch self {\n        case .getNetWorkRegion:\n            dict =  [\"action\": \"ping\"]\n        }\n        return .requestParameters(parameters: dict, encoding: URLEncoding.queryString)\n    }\n}\n```\n###### baseURL\n基本的网络请求，所有网络请求都会经过这个 URL 进行封装。\n###### path\n具体的网络请求路径，由于我项目中所有的请求都是通过同一个路径，所以这个返回值我并不需要添加任何信息。\n###### method\n网络请求方法，例如 post，get。\n###### sampleData\n单元测试时需要使用的模拟数据，可以自定设置。这个 sample data 个是 Data 实例对象, 它可以表示 JSON, images, text, 或者任何您希望从endpoint得到的.\n###### headers\n请求头部数据。\n###### task\n由于最新的 Moya 已经修改，参数直接在这个属性中进行处理。注意：因为我之前的 encoding 中的参数填写的是 `URLEncoding.default` 和 `JSONEncoding.default` 导致对参数编码处理错误，请求不到正确的 URL。这个接口需要填写 `URLEncoding.queryString` 才能请求成功。\n\n##### 进行网络请求\n我在项目中创建了新文件 HttpTool 来对不同接口的数据进行处理。也导入了 SwiftyJSON 方便处理请求数据。\n\n```\nfunc getNetWorkRegion() {\n    let provider = MoyaProvider<APIManager>()\n    provider.rx.request(.getNetWorkRegion).subscribe { event in\n        \n        switch event {\n        case .success(let response):\n            K_CONFIGJSON.rg = JSON(response.data)[\"rg\"].stringValue\n        case .error(_):\n            K_CONFIGJSON.rg = \"1\"      // 默认为 1---中国\n        }\n    }.disposed(by: bag)\n}\n```\n##### 打印请求日志\n[官方](https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/Sources/Moya/Plugins/NetworkLoggerPlugin.swift)自带了一个插件来管理打印信息，但是这个插件打印信息太过全面，信息太多反而不好查看。我们可以通过[创建自定义插件](https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/docs_CN/Examples/CustomPlugin.md)的方式来实现我们的需求。\n创建一个类来遵循 PluginType 协议，并且实现协议方法。\n\n```\nfinal class HYNetWorkPlugin: PluginType {\n    func willSend(_ request: RequestType, target: TargetType) {\n        let req = request.request?.description ?? \"无效的请求链接\"\n        print(\"++++++++++++++++\\n\\(req)\\n++++++++++++++++\")\n    }\n}\n```\n使用这个插件十分简单，只需要在创建的时候将插件对象作为参数传递到初始化方法中即可：\n\n\tlet provider = MoyaProvider<APIManager>(plugins: [HYNetWorkPlugin()])\n\n##### 参考资料\n\n> [Moya 官方中文文档](https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/docs_CN/README.md)\n> [Swift - 网络抽象层库Moya的使用详解](http://www.hangge.com/blog/cache/detail_1797.html)","slug":"Moya 使用笔记","published":1,"updated":"2018-02-06T09:49:35.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfy9o00097sn6feag30r5","content":"<p>Swift 经常用 Alamofire 来做网络库，而 Moya 在 Alamofire 的基础上又封装了一层。Moya 是你的 app 中缺失的网络层。不用再去想在哪儿（或者如何）安放网络请求，Moya 替你管理。</p>\n<!---more--->\n<h5 id=\"安装配置\"><a href=\"#安装配置\" class=\"headerlink\" title=\"安装配置\"></a>安装配置</h5><p>由于我在项目使用了 CocoaPods，而且也使用了 RxSwift 这个框架，所以直接在在 Podfile 文件中添加 <code>pod &#39;Moya/RxSwift&#39;</code> 即可。</p>\n<h5 id=\"创建-APIManager\"><a href=\"#创建-APIManager\" class=\"headerlink\" title=\"创建 APIManager\"></a>创建 APIManager</h5><p><a href=\"https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/docs_CN/Examples/Basic.md\">Moya 官方用例文档</a>讲解的很清晰，使用前我们需要创建一个枚举，作为网络请求的 API 请求分类。<br>先创建一个 APIManager.swift 用来统一处理的网络请求。然后创建 APIManager 枚举，用来区分不同的请求接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">APIManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> getNetWorkRegion  <span class=\"comment\">///&gt; 判断国内国外  0---国外  1---中国</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"实现-TargetType-协议\"><a href=\"#实现-TargetType-协议\" class=\"headerlink\" title=\"实现 TargetType 协议\"></a>实现 TargetType 协议</h5><p>接下来对这个 APIManager 进行拓展，并且让它遵循 TargetType 协议。这个协议是 Moya 为了方便创建一个 MoayProvider，对网络请求进行一个统一的管理。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension APIManager: TargetType &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> baseURL: URL &#123; <span class=\"keyword\">return</span> URL(string: BASEURL)! &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> path: String &#123; <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> method: Moya.Method &#123; <span class=\"keyword\">return</span> .post &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sampleData: Data &#123; <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>.<span class=\"keyword\">data</span>(using: .utf8)! &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> headers: [String : String]? &#123; <span class=\"keyword\">return</span> [<span class=\"string\">&quot;Content-type&quot;</span>: <span class=\"string\">&quot;application/json&quot;</span>] &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> task: Task &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> dict = [<span class=\"string\">&quot;&quot;</span>: <span class=\"string\">&quot;&quot;</span>]</span><br><span class=\"line\">        switch self &#123;</span><br><span class=\"line\">        case .getNetWorkRegion:</span><br><span class=\"line\">            dict =  [<span class=\"string\">&quot;action&quot;</span>: <span class=\"string\">&quot;ping&quot;</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> .requestParameters(parameters: dict, encoding: URLEncoding.queryString)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"baseURL\"><a href=\"#baseURL\" class=\"headerlink\" title=\"baseURL\"></a>baseURL</h6><p>基本的网络请求，所有网络请求都会经过这个 URL 进行封装。</p>\n<h6 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h6><p>具体的网络请求路径，由于我项目中所有的请求都是通过同一个路径，所以这个返回值我并不需要添加任何信息。</p>\n<h6 id=\"method\"><a href=\"#method\" class=\"headerlink\" title=\"method\"></a>method</h6><p>网络请求方法，例如 post，get。</p>\n<h6 id=\"sampleData\"><a href=\"#sampleData\" class=\"headerlink\" title=\"sampleData\"></a>sampleData</h6><p>单元测试时需要使用的模拟数据，可以自定设置。这个 sample data 个是 Data 实例对象, 它可以表示 JSON, images, text, 或者任何您希望从endpoint得到的.</p>\n<h6 id=\"headers\"><a href=\"#headers\" class=\"headerlink\" title=\"headers\"></a>headers</h6><p>请求头部数据。</p>\n<h6 id=\"task\"><a href=\"#task\" class=\"headerlink\" title=\"task\"></a>task</h6><p>由于最新的 Moya 已经修改，参数直接在这个属性中进行处理。注意：因为我之前的 encoding 中的参数填写的是 <code>URLEncoding.default</code> 和 <code>JSONEncoding.default</code> 导致对参数编码处理错误，请求不到正确的 URL。这个接口需要填写 <code>URLEncoding.queryString</code> 才能请求成功。</p>\n<h5 id=\"进行网络请求\"><a href=\"#进行网络请求\" class=\"headerlink\" title=\"进行网络请求\"></a>进行网络请求</h5><p>我在项目中创建了新文件 HttpTool 来对不同接口的数据进行处理。也导入了 SwiftyJSON 方便处理请求数据。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func getNetWorkRegion() &#123;</span><br><span class=\"line\">    let provider = MoyaProvider&lt;APIManager&gt;()</span><br><span class=\"line\">    provider<span class=\"selector-class\">.rx</span><span class=\"selector-class\">.request</span>(.getNetWorkRegion)<span class=\"selector-class\">.subscribe</span> &#123; event <span class=\"keyword\">in</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        switch event &#123;</span><br><span class=\"line\">        case <span class=\"selector-class\">.success</span>(let response):</span><br><span class=\"line\">            K_CONFIGJSON<span class=\"selector-class\">.rg</span> = JSON(response.data)<span class=\"selector-attr\">[<span class=\"string\">&quot;rg&quot;</span>]</span><span class=\"selector-class\">.stringValue</span></span><br><span class=\"line\">        case <span class=\"selector-class\">.error</span>(_):</span><br><span class=\"line\">            K_CONFIGJSON<span class=\"selector-class\">.rg</span> = <span class=\"string\">&quot;1&quot;</span>      <span class=\"comment\">// 默认为 1---中国</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"selector-class\">.disposed</span>(by: bag)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"打印请求日志\"><a href=\"#打印请求日志\" class=\"headerlink\" title=\"打印请求日志\"></a>打印请求日志</h5><p><a href=\"https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/Sources/Moya/Plugins/NetworkLoggerPlugin.swift\">官方</a>自带了一个插件来管理打印信息，但是这个插件打印信息太过全面，信息太多反而不好查看。我们可以通过<a href=\"https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/docs_CN/Examples/CustomPlugin.md\">创建自定义插件</a>的方式来实现我们的需求。<br>创建一个类来遵循 PluginType 协议，并且实现协议方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HYNetWorkPlugin</span>: <span class=\"title\">PluginType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">willSend</span>(<span class=\"keyword\">_</span> <span class=\"params\">request</span>: <span class=\"type\">RequestType</span>, <span class=\"params\">target</span>: <span class=\"type\">TargetType</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> req <span class=\"operator\">=</span> request.request<span class=\"operator\">?</span>.description <span class=\"operator\">??</span> <span class=\"string\">&quot;无效的请求链接&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;++++++++++++++++<span class=\"subst\">\\n</span><span class=\"subst\">\\(req)</span><span class=\"subst\">\\n</span>++++++++++++++++&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用这个插件十分简单，只需要在创建的时候将插件对象作为参数传递到初始化方法中即可：</p>\n<pre><code>let provider = MoyaProvider&lt;APIManager&gt;(plugins: [HYNetWorkPlugin()])\n</code></pre>\n<h5 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h5><blockquote>\n<p><a href=\"https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/docs_CN/README.md\">Moya 官方中文文档</a><br><a href=\"http://www.hangge.com/blog/cache/detail_1797.html\">Swift - 网络抽象层库Moya的使用详解</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>Swift 经常用 Alamofire 来做网络库，而 Moya 在 Alamofire 的基础上又封装了一层。Moya 是你的 app 中缺失的网络层。不用再去想在哪儿（或者如何）安放网络请求，Moya 替你管理。</p>\n<!---more--->\n<h5 id=\"安装配置\"><a href=\"#安装配置\" class=\"headerlink\" title=\"安装配置\"></a>安装配置</h5><p>由于我在项目使用了 CocoaPods，而且也使用了 RxSwift 这个框架，所以直接在在 Podfile 文件中添加 <code>pod &#39;Moya/RxSwift&#39;</code> 即可。</p>\n<h5 id=\"创建-APIManager\"><a href=\"#创建-APIManager\" class=\"headerlink\" title=\"创建 APIManager\"></a>创建 APIManager</h5><p><a href=\"https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/docs_CN/Examples/Basic.md\">Moya 官方用例文档</a>讲解的很清晰，使用前我们需要创建一个枚举，作为网络请求的 API 请求分类。<br>先创建一个 APIManager.swift 用来统一处理的网络请求。然后创建 APIManager 枚举，用来区分不同的请求接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">APIManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> getNetWorkRegion  <span class=\"comment\">///&gt; 判断国内国外  0---国外  1---中国</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"实现-TargetType-协议\"><a href=\"#实现-TargetType-协议\" class=\"headerlink\" title=\"实现 TargetType 协议\"></a>实现 TargetType 协议</h5><p>接下来对这个 APIManager 进行拓展，并且让它遵循 TargetType 协议。这个协议是 Moya 为了方便创建一个 MoayProvider，对网络请求进行一个统一的管理。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension APIManager: TargetType &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> baseURL: URL &#123; <span class=\"keyword\">return</span> URL(string: BASEURL)! &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> path: String &#123; <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> method: Moya.Method &#123; <span class=\"keyword\">return</span> .post &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sampleData: Data &#123; <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>.<span class=\"keyword\">data</span>(using: .utf8)! &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> headers: [String : String]? &#123; <span class=\"keyword\">return</span> [<span class=\"string\">&quot;Content-type&quot;</span>: <span class=\"string\">&quot;application/json&quot;</span>] &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> task: Task &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> dict = [<span class=\"string\">&quot;&quot;</span>: <span class=\"string\">&quot;&quot;</span>]</span><br><span class=\"line\">        switch self &#123;</span><br><span class=\"line\">        case .getNetWorkRegion:</span><br><span class=\"line\">            dict =  [<span class=\"string\">&quot;action&quot;</span>: <span class=\"string\">&quot;ping&quot;</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> .requestParameters(parameters: dict, encoding: URLEncoding.queryString)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"baseURL\"><a href=\"#baseURL\" class=\"headerlink\" title=\"baseURL\"></a>baseURL</h6><p>基本的网络请求，所有网络请求都会经过这个 URL 进行封装。</p>\n<h6 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h6><p>具体的网络请求路径，由于我项目中所有的请求都是通过同一个路径，所以这个返回值我并不需要添加任何信息。</p>\n<h6 id=\"method\"><a href=\"#method\" class=\"headerlink\" title=\"method\"></a>method</h6><p>网络请求方法，例如 post，get。</p>\n<h6 id=\"sampleData\"><a href=\"#sampleData\" class=\"headerlink\" title=\"sampleData\"></a>sampleData</h6><p>单元测试时需要使用的模拟数据，可以自定设置。这个 sample data 个是 Data 实例对象, 它可以表示 JSON, images, text, 或者任何您希望从endpoint得到的.</p>\n<h6 id=\"headers\"><a href=\"#headers\" class=\"headerlink\" title=\"headers\"></a>headers</h6><p>请求头部数据。</p>\n<h6 id=\"task\"><a href=\"#task\" class=\"headerlink\" title=\"task\"></a>task</h6><p>由于最新的 Moya 已经修改，参数直接在这个属性中进行处理。注意：因为我之前的 encoding 中的参数填写的是 <code>URLEncoding.default</code> 和 <code>JSONEncoding.default</code> 导致对参数编码处理错误，请求不到正确的 URL。这个接口需要填写 <code>URLEncoding.queryString</code> 才能请求成功。</p>\n<h5 id=\"进行网络请求\"><a href=\"#进行网络请求\" class=\"headerlink\" title=\"进行网络请求\"></a>进行网络请求</h5><p>我在项目中创建了新文件 HttpTool 来对不同接口的数据进行处理。也导入了 SwiftyJSON 方便处理请求数据。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func getNetWorkRegion() &#123;</span><br><span class=\"line\">    let provider = MoyaProvider&lt;APIManager&gt;()</span><br><span class=\"line\">    provider<span class=\"selector-class\">.rx</span><span class=\"selector-class\">.request</span>(.getNetWorkRegion)<span class=\"selector-class\">.subscribe</span> &#123; event <span class=\"keyword\">in</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        switch event &#123;</span><br><span class=\"line\">        case <span class=\"selector-class\">.success</span>(let response):</span><br><span class=\"line\">            K_CONFIGJSON<span class=\"selector-class\">.rg</span> = JSON(response.data)<span class=\"selector-attr\">[<span class=\"string\">&quot;rg&quot;</span>]</span><span class=\"selector-class\">.stringValue</span></span><br><span class=\"line\">        case <span class=\"selector-class\">.error</span>(_):</span><br><span class=\"line\">            K_CONFIGJSON<span class=\"selector-class\">.rg</span> = <span class=\"string\">&quot;1&quot;</span>      <span class=\"comment\">// 默认为 1---中国</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"selector-class\">.disposed</span>(by: bag)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"打印请求日志\"><a href=\"#打印请求日志\" class=\"headerlink\" title=\"打印请求日志\"></a>打印请求日志</h5><p><a href=\"https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/Sources/Moya/Plugins/NetworkLoggerPlugin.swift\">官方</a>自带了一个插件来管理打印信息，但是这个插件打印信息太过全面，信息太多反而不好查看。我们可以通过<a href=\"https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/docs_CN/Examples/CustomPlugin.md\">创建自定义插件</a>的方式来实现我们的需求。<br>创建一个类来遵循 PluginType 协议，并且实现协议方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HYNetWorkPlugin</span>: <span class=\"title\">PluginType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">willSend</span>(<span class=\"keyword\">_</span> <span class=\"params\">request</span>: <span class=\"type\">RequestType</span>, <span class=\"params\">target</span>: <span class=\"type\">TargetType</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> req <span class=\"operator\">=</span> request.request<span class=\"operator\">?</span>.description <span class=\"operator\">??</span> <span class=\"string\">&quot;无效的请求链接&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;++++++++++++++++<span class=\"subst\">\\n</span><span class=\"subst\">\\(req)</span><span class=\"subst\">\\n</span>++++++++++++++++&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用这个插件十分简单，只需要在创建的时候将插件对象作为参数传递到初始化方法中即可：</p>\n<pre><code>let provider = MoyaProvider&lt;APIManager&gt;(plugins: [HYNetWorkPlugin()])\n</code></pre>\n<h5 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h5><blockquote>\n<p><a href=\"https://github.com/Moya/Moya/blob/7c599570c2a60079dfefcc27fc67cb303feb48e1/docs_CN/README.md\">Moya 官方中文文档</a><br><a href=\"http://www.hangge.com/blog/cache/detail_1797.html\">Swift - 网络抽象层库Moya的使用详解</a></p>\n</blockquote>\n"},{"layout":"swift","title":"PopMenu提示框实现","date":"2018-05-11T07:15:49.000Z","_content":"在网上看到了一款实现效果不错的提示框，可以自定义提示框样式，设置提示框出现位置。决定看一下别人是如何实现的，了解下别人的实现思路。\n<!-- more -->\n#### 实现效果\n效果如下图所示。\n![](https://raw.githubusercontent.com/CaliCastle/PopMenu/master/.assets/Demo_Showcase.gif)\n使用起来也很简单，[文档](https://calicastle.github.io/PopMenu/index.html)也有很仔细的说明，这里就无需在多做说明。\n\n#### 代码解读\n具体化还是看一下 PopMenu 是如何实现的。借鉴一下别人的实现思路。\n##### 初始化类型\nPopMenu 使用了两种方式进行实例化对象。第一种是用 Manager 创建单例对象，第二种是创建 Controller 进行使用。\n这里我们先研究下第一种实现方式。\n\n```\nfinal public class PopMenuManager: NSObject {\n    /// 默认的管理对象\n    public static let `default` = PopMenuManager()\n    /// 放置 Action 数组\n    public var actions: [PopMenuAction] = []\n    ···\t\n}\n```\n这种方式可以通过直接调用静态属性 `default`。创建对象，然后添加 `actions` 中的内容。可以清楚的看到 `action` 中需要存放遵循 `PopMenuAction` 协议的对象。这样就可以通过实现协议来自定义 action 的 UI。\n##### 自定义 Action\n只要遵循实现 `PopMenAction` 协议，就可以实现自定义的 Action。让我们看一下默认的的 `PopMenuDefaultAction` 是如何实现的。首先是 `PopMenuAction` 协议，这里就只列出简单的属性。\n\n```\n/// Image of the action.\n@objc public protocol PopMenuAction: NSObjectProtocol {\n    var image: UIImage? { get }\n    var view: UIView { get }\n    ······\n    func renderActionView()\n}\n```\n\n当协议完成了，就可以创建一个 class 来遵循这个协议，实现默认的 Action。\n\n```\npublic class PopMenuDefaultAction: NSObject, PopMenuAction {\n    public let image: UIImage?\n    public let view: UIView\n    ······\n    /// 初始化方法\n    public init(image: UIImage? = nil) {\n        self.image = image\n        view = UIView()\n    }\n    /// 加载渲染的 view\n    public func renderActionView() {\n        /// 自定义 UI\n        configureViews()\n    }\n}\n```\n\n默认的 Action 实现好了，使用就比较简单了，直接将实例对象赋到数组中就行。\n\n```\nmanager.actions = [\n    PopMenuDefaultAction(title: \"标题一\"),\n    PopMenuDefaultAction(title: \"有图片的标题\", image: #imageLiteral(resourceName: \"clear-day\"), color: UIColor.orange, didSelect: complete)\n]\n```\n\n##### 显示 & 消失 提示框\n准备工作都完成了，就可以在需要的地方调用显示方法就行。\n\n`manager.present(sourceView: button, on: self, animated: true)`\n一句话即可实现，让我们看看到底是怎么完成这个显示的，其中包括了，转场，显示动画和消失的动画。\n\n```\npublic func present(sourceView: AnyObject? = nil, on viewController: UIViewController? = nil, animated: Bool = true, completion: (() -> Void)? = nil) {\n\n        prepareViewController(sourceView: sourceView)\n        guard let popMenu = popMenu else { print(\"Pop Menu has not been initialized yet.\"); return }\n        \n        if let presentOn = viewController {\n            presentOn.present(popMenu, animated: animated, completion: completion)\n        } else {\n            if let topViewController = PopMenuManager.getTopViewControllerInWindow() {\n                topViewController.present(popMenu, animated: animated, completion: completion)\n            }\n        }\n    }\n```\n\n看起来很简单的实现方式，首先准备了一个 VC `prepareViewController(sourceView: sourceView)`。然后使自身 `popMenu` 持有该属性。然后获取 VC 显示 `popMenu`。\n\n关键就在于如何实现这个准备用的 VC `PopMenuViewController`了。\n\n观察代码可以发现，`PopMenuViewController` 这个自定义的 VC 实现了提示框的 UI 设置与手势交互。\n\n```\nfinal public class PopMenuViewController: UIViewController {\n    public let actionsView = UIStackView()\n    \n    fileprivate func configureActionsView() {\n    \t//// 给 actionsView 添加 具体的 View 并做好布局\n    }\n    ······\n}\n```\n\n整体实现的思路还是很清晰的，具体的细节有很多，就不一一列举了。\n关于显示 VC，让 `PopMenuViewController ` 遵循转场动画协议 `UIViewControllerTransitioningDelegate` 并实现它。\n\n\n```\nextension PopMenuViewController: UIViewControllerTransitioningDelegate {\n    \n    public func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return PopMenuPresentAnimationController(sourceFrame: absoluteSourceFrame)\n    }\n    \n    public func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return PopMenuDismissAnimationController(sourceFrame: absoluteSourceFrame)\n    }\n}\n···\nfinal public class PopMenuPresentAnimationController: NSObject, UIViewControllerAnimatedTransitioning {\n\t/// 实现代理方法 自定义细节动画\n}\n```\n\n关于消失，实现思路就很简单了，在 VC 的背景 View 中添加手势，并实现系统点击事件 `dismiss()`，消失整个 VC 即可。\n\n#### 总结\n这个 PopMenu 实现思路并不是很复杂，但是其中的细节做得很到位，效果也很好，文档也写的很棒。让我对自定义提示框的理解学习到了很多。\n<br>\n>参考资料\n>[PopMenu Git](https://github.com/CaliCastle/PopMenu)\n>[PopMenu使用文档](https://calicastle.github.io/PopMenu/index.html)\n","source":"_posts/PopMenu提示框实现.md","raw":"---\nlayout: swift\ntitle: PopMenu提示框实现\ndate: 2018-05-11 15:15:49\ntags: \n- Swift\ncategories: \n- Swift\n---\n在网上看到了一款实现效果不错的提示框，可以自定义提示框样式，设置提示框出现位置。决定看一下别人是如何实现的，了解下别人的实现思路。\n<!-- more -->\n#### 实现效果\n效果如下图所示。\n![](https://raw.githubusercontent.com/CaliCastle/PopMenu/master/.assets/Demo_Showcase.gif)\n使用起来也很简单，[文档](https://calicastle.github.io/PopMenu/index.html)也有很仔细的说明，这里就无需在多做说明。\n\n#### 代码解读\n具体化还是看一下 PopMenu 是如何实现的。借鉴一下别人的实现思路。\n##### 初始化类型\nPopMenu 使用了两种方式进行实例化对象。第一种是用 Manager 创建单例对象，第二种是创建 Controller 进行使用。\n这里我们先研究下第一种实现方式。\n\n```\nfinal public class PopMenuManager: NSObject {\n    /// 默认的管理对象\n    public static let `default` = PopMenuManager()\n    /// 放置 Action 数组\n    public var actions: [PopMenuAction] = []\n    ···\t\n}\n```\n这种方式可以通过直接调用静态属性 `default`。创建对象，然后添加 `actions` 中的内容。可以清楚的看到 `action` 中需要存放遵循 `PopMenuAction` 协议的对象。这样就可以通过实现协议来自定义 action 的 UI。\n##### 自定义 Action\n只要遵循实现 `PopMenAction` 协议，就可以实现自定义的 Action。让我们看一下默认的的 `PopMenuDefaultAction` 是如何实现的。首先是 `PopMenuAction` 协议，这里就只列出简单的属性。\n\n```\n/// Image of the action.\n@objc public protocol PopMenuAction: NSObjectProtocol {\n    var image: UIImage? { get }\n    var view: UIView { get }\n    ······\n    func renderActionView()\n}\n```\n\n当协议完成了，就可以创建一个 class 来遵循这个协议，实现默认的 Action。\n\n```\npublic class PopMenuDefaultAction: NSObject, PopMenuAction {\n    public let image: UIImage?\n    public let view: UIView\n    ······\n    /// 初始化方法\n    public init(image: UIImage? = nil) {\n        self.image = image\n        view = UIView()\n    }\n    /// 加载渲染的 view\n    public func renderActionView() {\n        /// 自定义 UI\n        configureViews()\n    }\n}\n```\n\n默认的 Action 实现好了，使用就比较简单了，直接将实例对象赋到数组中就行。\n\n```\nmanager.actions = [\n    PopMenuDefaultAction(title: \"标题一\"),\n    PopMenuDefaultAction(title: \"有图片的标题\", image: #imageLiteral(resourceName: \"clear-day\"), color: UIColor.orange, didSelect: complete)\n]\n```\n\n##### 显示 & 消失 提示框\n准备工作都完成了，就可以在需要的地方调用显示方法就行。\n\n`manager.present(sourceView: button, on: self, animated: true)`\n一句话即可实现，让我们看看到底是怎么完成这个显示的，其中包括了，转场，显示动画和消失的动画。\n\n```\npublic func present(sourceView: AnyObject? = nil, on viewController: UIViewController? = nil, animated: Bool = true, completion: (() -> Void)? = nil) {\n\n        prepareViewController(sourceView: sourceView)\n        guard let popMenu = popMenu else { print(\"Pop Menu has not been initialized yet.\"); return }\n        \n        if let presentOn = viewController {\n            presentOn.present(popMenu, animated: animated, completion: completion)\n        } else {\n            if let topViewController = PopMenuManager.getTopViewControllerInWindow() {\n                topViewController.present(popMenu, animated: animated, completion: completion)\n            }\n        }\n    }\n```\n\n看起来很简单的实现方式，首先准备了一个 VC `prepareViewController(sourceView: sourceView)`。然后使自身 `popMenu` 持有该属性。然后获取 VC 显示 `popMenu`。\n\n关键就在于如何实现这个准备用的 VC `PopMenuViewController`了。\n\n观察代码可以发现，`PopMenuViewController` 这个自定义的 VC 实现了提示框的 UI 设置与手势交互。\n\n```\nfinal public class PopMenuViewController: UIViewController {\n    public let actionsView = UIStackView()\n    \n    fileprivate func configureActionsView() {\n    \t//// 给 actionsView 添加 具体的 View 并做好布局\n    }\n    ······\n}\n```\n\n整体实现的思路还是很清晰的，具体的细节有很多，就不一一列举了。\n关于显示 VC，让 `PopMenuViewController ` 遵循转场动画协议 `UIViewControllerTransitioningDelegate` 并实现它。\n\n\n```\nextension PopMenuViewController: UIViewControllerTransitioningDelegate {\n    \n    public func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return PopMenuPresentAnimationController(sourceFrame: absoluteSourceFrame)\n    }\n    \n    public func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return PopMenuDismissAnimationController(sourceFrame: absoluteSourceFrame)\n    }\n}\n···\nfinal public class PopMenuPresentAnimationController: NSObject, UIViewControllerAnimatedTransitioning {\n\t/// 实现代理方法 自定义细节动画\n}\n```\n\n关于消失，实现思路就很简单了，在 VC 的背景 View 中添加手势，并实现系统点击事件 `dismiss()`，消失整个 VC 即可。\n\n#### 总结\n这个 PopMenu 实现思路并不是很复杂，但是其中的细节做得很到位，效果也很好，文档也写的很棒。让我对自定义提示框的理解学习到了很多。\n<br>\n>参考资料\n>[PopMenu Git](https://github.com/CaliCastle/PopMenu)\n>[PopMenu使用文档](https://calicastle.github.io/PopMenu/index.html)\n","slug":"PopMenu提示框实现","published":1,"updated":"2021-09-06T15:49:58.020Z","_id":"ckt8qfy9q000b7sn6g4he2qnj","comments":1,"photos":[],"link":"","content":"<p>在网上看到了一款实现效果不错的提示框，可以自定义提示框样式，设置提示框出现位置。决定看一下别人是如何实现的，了解下别人的实现思路。</p>\n<span id=\"more\"></span>\n<h4 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h4><p>效果如下图所示。<br><img src=\"https://raw.githubusercontent.com/CaliCastle/PopMenu/master/.assets/Demo_Showcase.gif\"><br>使用起来也很简单，<a href=\"https://calicastle.github.io/PopMenu/index.html\">文档</a>也有很仔细的说明，这里就无需在多做说明。</p>\n<h4 id=\"代码解读\"><a href=\"#代码解读\" class=\"headerlink\" title=\"代码解读\"></a>代码解读</h4><p>具体化还是看一下 PopMenu 是如何实现的。借鉴一下别人的实现思路。</p>\n<h5 id=\"初始化类型\"><a href=\"#初始化类型\" class=\"headerlink\" title=\"初始化类型\"></a>初始化类型</h5><p>PopMenu 使用了两种方式进行实例化对象。第一种是用 Manager 创建单例对象，第二种是创建 Controller 进行使用。<br>这里我们先研究下第一种实现方式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopMenuManager</span>: <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 默认的管理对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> `default` <span class=\"operator\">=</span> <span class=\"type\">PopMenuManager</span>()</span><br><span class=\"line\">    <span class=\"comment\">/// 放置 Action 数组</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> actions: [<span class=\"type\">PopMenuAction</span>] <span class=\"operator\">=</span> []</span><br><span class=\"line\">    ···\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式可以通过直接调用静态属性 <code>default</code>。创建对象，然后添加 <code>actions</code> 中的内容。可以清楚的看到 <code>action</code> 中需要存放遵循 <code>PopMenuAction</code> 协议的对象。这样就可以通过实现协议来自定义 action 的 UI。</p>\n<h5 id=\"自定义-Action\"><a href=\"#自定义-Action\" class=\"headerlink\" title=\"自定义 Action\"></a>自定义 Action</h5><p>只要遵循实现 <code>PopMenAction</code> 协议，就可以实现自定义的 Action。让我们看一下默认的的 <code>PopMenuDefaultAction</code> 是如何实现的。首先是 <code>PopMenuAction</code> 协议，这里就只列出简单的属性。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Image of the action.</span></span><br><span class=\"line\"><span class=\"keyword\">@objc</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">PopMenuAction</span>: <span class=\"title\">NSObjectProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> image: <span class=\"type\">UIImage</span>? &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> view: <span class=\"type\">UIView</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    ······</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">renderActionView</span>()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当协议完成了，就可以创建一个 class 来遵循这个协议，实现默认的 Action。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopMenuDefaultAction</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">PopMenuAction</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> image: <span class=\"type\">UIImage</span>?</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> view: <span class=\"type\">UIView</span></span><br><span class=\"line\">    ······</span><br><span class=\"line\">    <span class=\"comment\">/// 初始化方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">image</span>: <span class=\"type\">UIImage</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.image <span class=\"operator\">=</span> image</span><br><span class=\"line\">        view <span class=\"operator\">=</span> <span class=\"type\">UIView</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/// 加载渲染的 view</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">renderActionView</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 自定义 UI</span></span><br><span class=\"line\">        configureViews()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>默认的 Action 实现好了，使用就比较简单了，直接将实例对象赋到数组中就行。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">manager.actions = [</span><br><span class=\"line\">    PopMenuDefaultAction(<span class=\"built_in\">title</span>: <span class=\"string\">&quot;标题一&quot;</span>),</span><br><span class=\"line\">    PopMenuDefaultAction(<span class=\"built_in\">title</span>: <span class=\"string\">&quot;有图片的标题&quot;</span>, <span class=\"built_in\">image</span>: #imageLiteral(resourceName: <span class=\"string\">&quot;clear-day&quot;</span>), <span class=\"built_in\">color</span>: UIColor.orange, didSelect: complete)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"显示-amp-消失-提示框\"><a href=\"#显示-amp-消失-提示框\" class=\"headerlink\" title=\"显示 &amp; 消失 提示框\"></a>显示 &amp; 消失 提示框</h5><p>准备工作都完成了，就可以在需要的地方调用显示方法就行。</p>\n<p><code>manager.present(sourceView: button, on: self, animated: true)</code><br>一句话即可实现，让我们看看到底是怎么完成这个显示的，其中包括了，转场，显示动画和消失的动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">present</span>(<span class=\"params\">sourceView</span>: <span class=\"type\">AnyObject</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>, <span class=\"params\">on</span> <span class=\"params\">viewController</span>: <span class=\"type\">UIViewController</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>, <span class=\"params\">animated</span>: <span class=\"type\">Bool</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>, <span class=\"params\">completion</span>: (() -&gt; <span class=\"type\">Void</span>)<span class=\"operator\">?</span> <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        prepareViewController(sourceView: sourceView)</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> popMenu <span class=\"operator\">=</span> popMenu <span class=\"keyword\">else</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Pop Menu has not been initialized yet.&quot;</span>); <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> presentOn <span class=\"operator\">=</span> viewController &#123;</span><br><span class=\"line\">            presentOn.present(popMenu, animated: animated, completion: completion)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> topViewController <span class=\"operator\">=</span> <span class=\"type\">PopMenuManager</span>.getTopViewControllerInWindow() &#123;</span><br><span class=\"line\">                topViewController.present(popMenu, animated: animated, completion: completion)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来很简单的实现方式，首先准备了一个 VC <code>prepareViewController(sourceView: sourceView)</code>。然后使自身 <code>popMenu</code> 持有该属性。然后获取 VC 显示 <code>popMenu</code>。</p>\n<p>关键就在于如何实现这个准备用的 VC <code>PopMenuViewController</code>了。</p>\n<p>观察代码可以发现，<code>PopMenuViewController</code> 这个自定义的 VC 实现了提示框的 UI 设置与手势交互。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopMenuViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> actionsView <span class=\"operator\">=</span> <span class=\"type\">UIStackView</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">configureActionsView</span>()</span> &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//// 给 actionsView 添加 具体的 View 并做好布局</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ······</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整体实现的思路还是很清晰的，具体的细节有很多，就不一一列举了。<br>关于显示 VC，让 <code>PopMenuViewController </code> 遵循转场动画协议 <code>UIViewControllerTransitioningDelegate</code> 并实现它。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">PopMenuViewController</span>: <span class=\"title\">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span>(<span class=\"params\">forPresented</span> <span class=\"params\">presented</span>: <span class=\"type\">UIViewController</span>, <span class=\"params\">presenting</span>: <span class=\"type\">UIViewController</span>, <span class=\"params\">source</span>: <span class=\"type\">UIViewController</span>)</span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">PopMenuPresentAnimationController</span>(sourceFrame: absoluteSourceFrame)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span>(<span class=\"params\">forDismissed</span> <span class=\"params\">dismissed</span>: <span class=\"type\">UIViewController</span>)</span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">PopMenuDismissAnimationController</span>(sourceFrame: absoluteSourceFrame)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopMenuPresentAnimationController</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class=\"line\">true<span class=\"comment\">/// 实现代理方法 自定义细节动画</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于消失，实现思路就很简单了，在 VC 的背景 View 中添加手势，并实现系统点击事件 <code>dismiss()</code>，消失整个 VC 即可。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这个 PopMenu 实现思路并不是很复杂，但是其中的细节做得很到位，效果也很好，文档也写的很棒。让我对自定义提示框的理解学习到了很多。<br><br></p>\n<blockquote>\n<p>参考资料<br><a href=\"https://github.com/CaliCastle/PopMenu\">PopMenu Git</a><br><a href=\"https://calicastle.github.io/PopMenu/index.html\">PopMenu使用文档</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>在网上看到了一款实现效果不错的提示框，可以自定义提示框样式，设置提示框出现位置。决定看一下别人是如何实现的，了解下别人的实现思路。</p>","more":"<h4 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h4><p>效果如下图所示。<br><img src=\"https://raw.githubusercontent.com/CaliCastle/PopMenu/master/.assets/Demo_Showcase.gif\"><br>使用起来也很简单，<a href=\"https://calicastle.github.io/PopMenu/index.html\">文档</a>也有很仔细的说明，这里就无需在多做说明。</p>\n<h4 id=\"代码解读\"><a href=\"#代码解读\" class=\"headerlink\" title=\"代码解读\"></a>代码解读</h4><p>具体化还是看一下 PopMenu 是如何实现的。借鉴一下别人的实现思路。</p>\n<h5 id=\"初始化类型\"><a href=\"#初始化类型\" class=\"headerlink\" title=\"初始化类型\"></a>初始化类型</h5><p>PopMenu 使用了两种方式进行实例化对象。第一种是用 Manager 创建单例对象，第二种是创建 Controller 进行使用。<br>这里我们先研究下第一种实现方式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopMenuManager</span>: <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 默认的管理对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> `default` <span class=\"operator\">=</span> <span class=\"type\">PopMenuManager</span>()</span><br><span class=\"line\">    <span class=\"comment\">/// 放置 Action 数组</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> actions: [<span class=\"type\">PopMenuAction</span>] <span class=\"operator\">=</span> []</span><br><span class=\"line\">    ···\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式可以通过直接调用静态属性 <code>default</code>。创建对象，然后添加 <code>actions</code> 中的内容。可以清楚的看到 <code>action</code> 中需要存放遵循 <code>PopMenuAction</code> 协议的对象。这样就可以通过实现协议来自定义 action 的 UI。</p>\n<h5 id=\"自定义-Action\"><a href=\"#自定义-Action\" class=\"headerlink\" title=\"自定义 Action\"></a>自定义 Action</h5><p>只要遵循实现 <code>PopMenAction</code> 协议，就可以实现自定义的 Action。让我们看一下默认的的 <code>PopMenuDefaultAction</code> 是如何实现的。首先是 <code>PopMenuAction</code> 协议，这里就只列出简单的属性。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Image of the action.</span></span><br><span class=\"line\"><span class=\"keyword\">@objc</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">PopMenuAction</span>: <span class=\"title\">NSObjectProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> image: <span class=\"type\">UIImage</span>? &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> view: <span class=\"type\">UIView</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    ······</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">renderActionView</span>()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当协议完成了，就可以创建一个 class 来遵循这个协议，实现默认的 Action。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopMenuDefaultAction</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">PopMenuAction</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> image: <span class=\"type\">UIImage</span>?</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> view: <span class=\"type\">UIView</span></span><br><span class=\"line\">    ······</span><br><span class=\"line\">    <span class=\"comment\">/// 初始化方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">image</span>: <span class=\"type\">UIImage</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.image <span class=\"operator\">=</span> image</span><br><span class=\"line\">        view <span class=\"operator\">=</span> <span class=\"type\">UIView</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/// 加载渲染的 view</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">renderActionView</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 自定义 UI</span></span><br><span class=\"line\">        configureViews()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>默认的 Action 实现好了，使用就比较简单了，直接将实例对象赋到数组中就行。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">manager.actions = [</span><br><span class=\"line\">    PopMenuDefaultAction(<span class=\"built_in\">title</span>: <span class=\"string\">&quot;标题一&quot;</span>),</span><br><span class=\"line\">    PopMenuDefaultAction(<span class=\"built_in\">title</span>: <span class=\"string\">&quot;有图片的标题&quot;</span>, <span class=\"built_in\">image</span>: #imageLiteral(resourceName: <span class=\"string\">&quot;clear-day&quot;</span>), <span class=\"built_in\">color</span>: UIColor.orange, didSelect: complete)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"显示-amp-消失-提示框\"><a href=\"#显示-amp-消失-提示框\" class=\"headerlink\" title=\"显示 &amp; 消失 提示框\"></a>显示 &amp; 消失 提示框</h5><p>准备工作都完成了，就可以在需要的地方调用显示方法就行。</p>\n<p><code>manager.present(sourceView: button, on: self, animated: true)</code><br>一句话即可实现，让我们看看到底是怎么完成这个显示的，其中包括了，转场，显示动画和消失的动画。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">present</span>(<span class=\"params\">sourceView</span>: <span class=\"type\">AnyObject</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>, <span class=\"params\">on</span> <span class=\"params\">viewController</span>: <span class=\"type\">UIViewController</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>, <span class=\"params\">animated</span>: <span class=\"type\">Bool</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>, <span class=\"params\">completion</span>: (() -&gt; <span class=\"type\">Void</span>)<span class=\"operator\">?</span> <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        prepareViewController(sourceView: sourceView)</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> popMenu <span class=\"operator\">=</span> popMenu <span class=\"keyword\">else</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Pop Menu has not been initialized yet.&quot;</span>); <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> presentOn <span class=\"operator\">=</span> viewController &#123;</span><br><span class=\"line\">            presentOn.present(popMenu, animated: animated, completion: completion)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> topViewController <span class=\"operator\">=</span> <span class=\"type\">PopMenuManager</span>.getTopViewControllerInWindow() &#123;</span><br><span class=\"line\">                topViewController.present(popMenu, animated: animated, completion: completion)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来很简单的实现方式，首先准备了一个 VC <code>prepareViewController(sourceView: sourceView)</code>。然后使自身 <code>popMenu</code> 持有该属性。然后获取 VC 显示 <code>popMenu</code>。</p>\n<p>关键就在于如何实现这个准备用的 VC <code>PopMenuViewController</code>了。</p>\n<p>观察代码可以发现，<code>PopMenuViewController</code> 这个自定义的 VC 实现了提示框的 UI 设置与手势交互。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopMenuViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> actionsView <span class=\"operator\">=</span> <span class=\"type\">UIStackView</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">configureActionsView</span>()</span> &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//// 给 actionsView 添加 具体的 View 并做好布局</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ······</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整体实现的思路还是很清晰的，具体的细节有很多，就不一一列举了。<br>关于显示 VC，让 <code>PopMenuViewController </code> 遵循转场动画协议 <code>UIViewControllerTransitioningDelegate</code> 并实现它。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">PopMenuViewController</span>: <span class=\"title\">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span>(<span class=\"params\">forPresented</span> <span class=\"params\">presented</span>: <span class=\"type\">UIViewController</span>, <span class=\"params\">presenting</span>: <span class=\"type\">UIViewController</span>, <span class=\"params\">source</span>: <span class=\"type\">UIViewController</span>)</span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">PopMenuPresentAnimationController</span>(sourceFrame: absoluteSourceFrame)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span>(<span class=\"params\">forDismissed</span> <span class=\"params\">dismissed</span>: <span class=\"type\">UIViewController</span>)</span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">PopMenuDismissAnimationController</span>(sourceFrame: absoluteSourceFrame)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">···</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopMenuPresentAnimationController</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class=\"line\">true<span class=\"comment\">/// 实现代理方法 自定义细节动画</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于消失，实现思路就很简单了，在 VC 的背景 View 中添加手势，并实现系统点击事件 <code>dismiss()</code>，消失整个 VC 即可。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这个 PopMenu 实现思路并不是很复杂，但是其中的细节做得很到位，效果也很好，文档也写的很棒。让我对自定义提示框的理解学习到了很多。<br><br></p>\n<blockquote>\n<p>参考资料<br><a href=\"https://github.com/CaliCastle/PopMenu\">PopMenu Git</a><br><a href=\"https://calicastle.github.io/PopMenu/index.html\">PopMenu使用文档</a></p>\n</blockquote>"},{"layout":"RxSwift 实现 UITableview","title":"RxSwift 实现 UITableview","date":"2018-01-26T05:48:02.000Z","_content":"UITableView 在开发中是最常使用的控件，由于 UITableview 相对来说功能比较多，所以对应的方法也很多，实现操作起来比较繁琐。通过 RxSwift 可以简化实现 UITableview 的方法，让开发者更注重业务逻辑。\n<!----more----> \n#### 简单的实现方式\n创建一个没有额外 Section 的 Tableview 可以很容易的实现。思路就是通过 Observable 将数据逐个绑定到相应的 Cell 上。\n\n```\nvar dataArray = Variable<[model]>([])\n\nstruct Model {\n    let title: String\n}\n```\n接下来就是创建一个将 Model 绑定到 Cell 上的闭包\n\n```\nlet setCell = {(i: Int, e: Model, c: TableViewCell) in\n\tc.setupWithModel(e)\n}\n```\n准备工作都已经做完了，接下来就是最关键的绑定部分，通过 Observeable 的 bind 方法来实现：\n`dataArray.asObservable().bind(to: self.tableView.rx.items(cellIdentifier: \"Cell\", cellType: TableViewCell.self))(setCell).disposed(by: bag)`\n注意其中的 cellType 一定要和刚才创建的闭包中的对应，否则就会报错。\n\n#### 带 Section 的实现方法\n刚才的实现方式仅仅创建了一个 Section，很多时候是无法满足需求的。想创建带 Section 的 UITableview 就需要引入 `import RxDataSources` 来实现了。\n\n首先，创建一个 dataSource 用来处理 UITableview 中的代理方法\n\n```\nlet dataSource = RxTableViewSectionedReloadDataSource<SectionModel<String, Model>>(configureCell:{ (source, tableview, index, model) -> UITableViewCell in\n\tlet cell = tableview.dequeueReusableCell(withIdentifier: \"Cell\", for: index) as! TableViewCell\n\tcell.setupWithModel(model)\n\treturn cell\n})\n```\n由于需要使用 Section，所以我们的数据源也要进行一些修改：\n`var dataArray = Variable<[SectionModel<String, Model>]>([])`。\n接下来的绑定和上边的方式差不多，我们可以直接将 dataSource 绑定到 dataArray 上。\n\n`dataArray.asObservable().bind(to: self.tableView.rx.items(dataSource: dataSource)).disposed(by: bag)`\n\n#### Proxy\nRxSwift 已经提供了很多代理方法以供我们使用，但是有的时候我们还是需要创建自己的代理方法。\n创建一个新文件来处理 Proxy ：\n\n```\n// 泊学网的方法还是 Swift 2.0 的版本 新版的 RxSwift 已经做了一些修改\nclass MyDelegateProxy: DelegateProxy<UITableView, UITableViewDelegate> ,UITableViewDelegate ,DelegateProxyType {\n    \n    public weak private(set) var tableView: UITableView?\n    \n    public init(tableView: ParentObject) {\n        self.tableView = tableView\n        super.init(parentObject: tableView, delegateProxy: MyDelegateProxy.self)\n    }\n\t // 如果没有实现这个方法 下面两个方法也不会实现 就会报错！参考了 Rx 中的实现方式实现的\n    static func registerKnownImplementations() {\n        self.register { MyDelegateProxy(tableView: $0) }\n    }\n    \n    static func setCurrentDelegate(_ delegate: UITableViewDelegate?, to object: UITableView) {\n        object.delegate = delegate\n    }\n    \n    static func currentDelegate(for object: UITableView) -> UITableViewDelegate? {\n        return object.delegate\n    }\n}\n```\n接下来需要对 UITableview 进行拓展\n\n```\n// 对 Selector 进行处理可以优雅的调用\nprivate extension Selector {\n    static let didSelectRowAtIndexPath = #selector(UITableViewDelegate.tableView(_:didSelectRowAt:))\n}\n\nextension UITableView {\n    var rxDelegate: MyDelegateProxy {\n        return MyDelegateProxy.proxy(for: self)\n    }\n    // RxSwift 中对 Selector 绑定的方法已经修改 这里需要使用 methodInvoked 方法实现。\n    var rxDidSelectRowAtIndexPath: Observable<(UITableView, IndexPath)> {\n        return rxDelegate.methodInvoked(.didSelectRowAtIndexPath).map { a in\n            return (a[0] as! UITableView, a[1] as! IndexPath)\n        }\n    }\n}\n```\n等以上准备步骤完成以后，接下来的调用就很容易了：\n\n```\ntableView.rxDidSelectRowAtIndexPath.subscribe(onNext: { a, b in\n\tprint(b)\t\t\t// [0,1]\n}).disposed(by: bag)   \n```\n有的时候我们同样需要原生的代理方法，RxSwift 也对此进行了支持。不过不能简单的使用 `tableView.delegate = self` 来实现了。需要调用 `tableView.rx.setDelegate(self).disposed(by: bag)` 来设置代理人。**注意:委托代理一定要在绑定数据前执行，否则会造成崩溃！**\n直接对 ViewController 进行拓展就能够实现原生代理方法了：\n\n```\nextension ViewController {\n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n        // 视频中说 会先走 Proxy 中的方法，但是实践的时候我发现情况相反。先走原生代理方法，然后再执行 Proxy 中的订阅方法。\n        print(indexPath)\n    }\n}\n```\n#### 关于下拉刷新\n下拉刷新这个功能很常见，这里就简单记录一下我的实现方法吧。这里使用三方框架 `MJRefresh`。\n首先创建下拉和上拉对象\n\n```\n// 顶部刷新\nlet header = MJRefreshNormalHeader()\n// 底部刷新\nlet footer = MJRefreshAutoNormalFooter()    \n```\n然后绑定好处理事件\n\n```\nheader.setRefreshingTarget(self, refreshingAction: #selector(upRefresh))\nfooter.setRefreshingTarget(self, refreshingAction: #selector(downRefresh))\nself.tableView.mj_header = header\nself.tableView.mj_footer = footer\n```\n最后实现刷新事件即可\n\n```\n@objc func upRefresh() {\n    dataArray.value.removeAll()\n    page = 1\n    Network.default.searchDouBan(start: String(page), count: \"10\").subscribe(onNext:{\n        self.tableView.mj_header.endRefreshing()\n        // 封装成 SectionModel 数据绑定\n\t\t let sec = SectionModel(model: \"header\", items: $0)\n        self.dataArray.value.append(sec)    \n    }).disposed(by: bag)\n}\n\n@objc func downRefresh() {\n    page += 1\n    Network.default.searchDouBan(start: String(page), count: \"10\").subscribe(onNext:{\n        self.tableView.mj_footer.endRefreshing()\n        let sec = SectionModel(model: \"header\", items: $0)\n        self.dataArray.value.append(sec)  \n    }).disposed(by: bag)\n}\n```","source":"_posts/RxSwift 实现 UITableview.md","raw":"---\nlayout: RxSwift 实现 UITableview\ntitle: RxSwift 实现 UITableview\ndate: 2018-01-26 13:48:02\ntags: \n- Swift\ncategories: \n- Swift\n---\nUITableView 在开发中是最常使用的控件，由于 UITableview 相对来说功能比较多，所以对应的方法也很多，实现操作起来比较繁琐。通过 RxSwift 可以简化实现 UITableview 的方法，让开发者更注重业务逻辑。\n<!----more----> \n#### 简单的实现方式\n创建一个没有额外 Section 的 Tableview 可以很容易的实现。思路就是通过 Observable 将数据逐个绑定到相应的 Cell 上。\n\n```\nvar dataArray = Variable<[model]>([])\n\nstruct Model {\n    let title: String\n}\n```\n接下来就是创建一个将 Model 绑定到 Cell 上的闭包\n\n```\nlet setCell = {(i: Int, e: Model, c: TableViewCell) in\n\tc.setupWithModel(e)\n}\n```\n准备工作都已经做完了，接下来就是最关键的绑定部分，通过 Observeable 的 bind 方法来实现：\n`dataArray.asObservable().bind(to: self.tableView.rx.items(cellIdentifier: \"Cell\", cellType: TableViewCell.self))(setCell).disposed(by: bag)`\n注意其中的 cellType 一定要和刚才创建的闭包中的对应，否则就会报错。\n\n#### 带 Section 的实现方法\n刚才的实现方式仅仅创建了一个 Section，很多时候是无法满足需求的。想创建带 Section 的 UITableview 就需要引入 `import RxDataSources` 来实现了。\n\n首先，创建一个 dataSource 用来处理 UITableview 中的代理方法\n\n```\nlet dataSource = RxTableViewSectionedReloadDataSource<SectionModel<String, Model>>(configureCell:{ (source, tableview, index, model) -> UITableViewCell in\n\tlet cell = tableview.dequeueReusableCell(withIdentifier: \"Cell\", for: index) as! TableViewCell\n\tcell.setupWithModel(model)\n\treturn cell\n})\n```\n由于需要使用 Section，所以我们的数据源也要进行一些修改：\n`var dataArray = Variable<[SectionModel<String, Model>]>([])`。\n接下来的绑定和上边的方式差不多，我们可以直接将 dataSource 绑定到 dataArray 上。\n\n`dataArray.asObservable().bind(to: self.tableView.rx.items(dataSource: dataSource)).disposed(by: bag)`\n\n#### Proxy\nRxSwift 已经提供了很多代理方法以供我们使用，但是有的时候我们还是需要创建自己的代理方法。\n创建一个新文件来处理 Proxy ：\n\n```\n// 泊学网的方法还是 Swift 2.0 的版本 新版的 RxSwift 已经做了一些修改\nclass MyDelegateProxy: DelegateProxy<UITableView, UITableViewDelegate> ,UITableViewDelegate ,DelegateProxyType {\n    \n    public weak private(set) var tableView: UITableView?\n    \n    public init(tableView: ParentObject) {\n        self.tableView = tableView\n        super.init(parentObject: tableView, delegateProxy: MyDelegateProxy.self)\n    }\n\t // 如果没有实现这个方法 下面两个方法也不会实现 就会报错！参考了 Rx 中的实现方式实现的\n    static func registerKnownImplementations() {\n        self.register { MyDelegateProxy(tableView: $0) }\n    }\n    \n    static func setCurrentDelegate(_ delegate: UITableViewDelegate?, to object: UITableView) {\n        object.delegate = delegate\n    }\n    \n    static func currentDelegate(for object: UITableView) -> UITableViewDelegate? {\n        return object.delegate\n    }\n}\n```\n接下来需要对 UITableview 进行拓展\n\n```\n// 对 Selector 进行处理可以优雅的调用\nprivate extension Selector {\n    static let didSelectRowAtIndexPath = #selector(UITableViewDelegate.tableView(_:didSelectRowAt:))\n}\n\nextension UITableView {\n    var rxDelegate: MyDelegateProxy {\n        return MyDelegateProxy.proxy(for: self)\n    }\n    // RxSwift 中对 Selector 绑定的方法已经修改 这里需要使用 methodInvoked 方法实现。\n    var rxDidSelectRowAtIndexPath: Observable<(UITableView, IndexPath)> {\n        return rxDelegate.methodInvoked(.didSelectRowAtIndexPath).map { a in\n            return (a[0] as! UITableView, a[1] as! IndexPath)\n        }\n    }\n}\n```\n等以上准备步骤完成以后，接下来的调用就很容易了：\n\n```\ntableView.rxDidSelectRowAtIndexPath.subscribe(onNext: { a, b in\n\tprint(b)\t\t\t// [0,1]\n}).disposed(by: bag)   \n```\n有的时候我们同样需要原生的代理方法，RxSwift 也对此进行了支持。不过不能简单的使用 `tableView.delegate = self` 来实现了。需要调用 `tableView.rx.setDelegate(self).disposed(by: bag)` 来设置代理人。**注意:委托代理一定要在绑定数据前执行，否则会造成崩溃！**\n直接对 ViewController 进行拓展就能够实现原生代理方法了：\n\n```\nextension ViewController {\n    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n        // 视频中说 会先走 Proxy 中的方法，但是实践的时候我发现情况相反。先走原生代理方法，然后再执行 Proxy 中的订阅方法。\n        print(indexPath)\n    }\n}\n```\n#### 关于下拉刷新\n下拉刷新这个功能很常见，这里就简单记录一下我的实现方法吧。这里使用三方框架 `MJRefresh`。\n首先创建下拉和上拉对象\n\n```\n// 顶部刷新\nlet header = MJRefreshNormalHeader()\n// 底部刷新\nlet footer = MJRefreshAutoNormalFooter()    \n```\n然后绑定好处理事件\n\n```\nheader.setRefreshingTarget(self, refreshingAction: #selector(upRefresh))\nfooter.setRefreshingTarget(self, refreshingAction: #selector(downRefresh))\nself.tableView.mj_header = header\nself.tableView.mj_footer = footer\n```\n最后实现刷新事件即可\n\n```\n@objc func upRefresh() {\n    dataArray.value.removeAll()\n    page = 1\n    Network.default.searchDouBan(start: String(page), count: \"10\").subscribe(onNext:{\n        self.tableView.mj_header.endRefreshing()\n        // 封装成 SectionModel 数据绑定\n\t\t let sec = SectionModel(model: \"header\", items: $0)\n        self.dataArray.value.append(sec)    \n    }).disposed(by: bag)\n}\n\n@objc func downRefresh() {\n    page += 1\n    Network.default.searchDouBan(start: String(page), count: \"10\").subscribe(onNext:{\n        self.tableView.mj_footer.endRefreshing()\n        let sec = SectionModel(model: \"header\", items: $0)\n        self.dataArray.value.append(sec)  \n    }).disposed(by: bag)\n}\n```","slug":"RxSwift 实现 UITableview","published":1,"updated":"2018-01-26T10:03:57.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfy9t000e7sn6eadw10rp","content":"<p>UITableView 在开发中是最常使用的控件，由于 UITableview 相对来说功能比较多，所以对应的方法也很多，实现操作起来比较繁琐。通过 RxSwift 可以简化实现 UITableview 的方法，让开发者更注重业务逻辑。</p>\n<!----more----> \n<h4 id=\"简单的实现方式\"><a href=\"#简单的实现方式\" class=\"headerlink\" title=\"简单的实现方式\"></a>简单的实现方式</h4><p>创建一个没有额外 Section 的 Tableview 可以很容易的实现。思路就是通过 Observable 将数据逐个绑定到相应的 Cell 上。</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dataArray = Variable&lt;[model]&gt;([])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"type\">Model</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">title</span>: <span class=\"keyword\">String</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来就是创建一个将 Model 绑定到 Cell 上的闭包</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> setCell = &#123;(i: Int, e: Model, c: TableViewCell) <span class=\"keyword\">in</span></span><br><span class=\"line\">truec.setup<span class=\"constructor\">WithModel(<span class=\"params\">e</span>)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>准备工作都已经做完了，接下来就是最关键的绑定部分，通过 Observeable 的 bind 方法来实现：<br><code>dataArray.asObservable().bind(to: self.tableView.rx.items(cellIdentifier: &quot;Cell&quot;, cellType: TableViewCell.self))(setCell).disposed(by: bag)</code><br>注意其中的 cellType 一定要和刚才创建的闭包中的对应，否则就会报错。</p>\n<h4 id=\"带-Section-的实现方法\"><a href=\"#带-Section-的实现方法\" class=\"headerlink\" title=\"带 Section 的实现方法\"></a>带 Section 的实现方法</h4><p>刚才的实现方式仅仅创建了一个 Section，很多时候是无法满足需求的。想创建带 Section 的 UITableview 就需要引入 <code>import RxDataSources</code> 来实现了。</p>\n<p>首先，创建一个 dataSource 用来处理 UITableview 中的代理方法</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;<span class=\"built_in\">String</span>, Model&gt;&gt;<span class=\"function\"><span class=\"params\">(configureCell:&#123; (source, tableview, index, model) -&gt; UITableViewCell <span class=\"keyword\">in</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">let</span> cell = tableview.dequeueReusableCell(withIdentifier: <span class=\"string\">&quot;Cell&quot;</span>, <span class=\"keyword\">for</span>: index) <span class=\"keyword\">as</span>! TableViewCell</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tcell.setupWithModel(model)</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">return</span> cell</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">&#125;)</span></span></span><br></pre></td></tr></table></figure>\n<p>由于需要使用 Section，所以我们的数据源也要进行一些修改：<br><code>var dataArray = Variable&lt;[SectionModel&lt;String, Model&gt;]&gt;([])</code>。<br>接下来的绑定和上边的方式差不多，我们可以直接将 dataSource 绑定到 dataArray 上。</p>\n<p><code>dataArray.asObservable().bind(to: self.tableView.rx.items(dataSource: dataSource)).disposed(by: bag)</code></p>\n<h4 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h4><p>RxSwift 已经提供了很多代理方法以供我们使用，但是有的时候我们还是需要创建自己的代理方法。<br>创建一个新文件来处理 Proxy ：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 泊学网的方法还是 Swift 2.0 的版本 新版的 RxSwift 已经做了一些修改</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDelegateProxy</span>: <span class=\"title\">DelegateProxy</span>&lt;<span class=\"title\">UITableView</span>, <span class=\"title\">UITableViewDelegate</span>&gt; ,<span class=\"title\">UITableViewDelegate</span> ,<span class=\"title\">DelegateProxyType</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">private(set)</span> <span class=\"keyword\">var</span> tableView: <span class=\"type\">UITableView</span>?</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">tableView</span>: <span class=\"type\">ParentObject</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.tableView <span class=\"operator\">=</span> tableView</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(parentObject: tableView, delegateProxy: <span class=\"type\">MyDelegateProxy</span>.<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">true <span class=\"comment\">// 如果没有实现这个方法 下面两个方法也不会实现 就会报错！参考了 Rx 中的实现方式实现的</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">registerKnownImplementations</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.register &#123; <span class=\"type\">MyDelegateProxy</span>(tableView: <span class=\"variable\">$0</span>) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setCurrentDelegate</span>(<span class=\"keyword\">_</span> <span class=\"params\">delegate</span>: <span class=\"type\">UITableViewDelegate</span>?, <span class=\"params\">to</span> <span class=\"params\">object</span>: <span class=\"type\">UITableView</span>)</span> &#123;</span><br><span class=\"line\">        object.delegate <span class=\"operator\">=</span> delegate</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">currentDelegate</span>(<span class=\"params\">for</span> <span class=\"params\">object</span>: <span class=\"type\">UITableView</span>)</span> -&gt; <span class=\"type\">UITableViewDelegate</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object.delegate</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来需要对 UITableview 进行拓展</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对 Selector 进行处理可以优雅的调用</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Selector</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> didSelectRowAtIndexPath <span class=\"operator\">=</span> <span class=\"keyword\">#selector</span>(<span class=\"type\">UITableViewDelegate</span>.tableView(<span class=\"keyword\">_</span>:didSelectRowAt:))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UITableView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rxDelegate: <span class=\"type\">MyDelegateProxy</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">MyDelegateProxy</span>.proxy(for: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// RxSwift 中对 Selector 绑定的方法已经修改 这里需要使用 methodInvoked 方法实现。</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> rxDidSelectRowAtIndexPath: <span class=\"type\">Observable</span>&lt;(<span class=\"type\">UITableView</span>, <span class=\"type\">IndexPath</span>)&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rxDelegate.methodInvoked(.didSelectRowAtIndexPath).map &#123; a <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (a[<span class=\"number\">0</span>] <span class=\"keyword\">as!</span> <span class=\"type\">UITableView</span>, a[<span class=\"number\">1</span>] <span class=\"keyword\">as!</span> <span class=\"type\">IndexPath</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等以上准备步骤完成以后，接下来的调用就很容易了：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">tableView</span><span class=\"selector-class\">.rxDidSelectRowAtIndexPath</span><span class=\"selector-class\">.subscribe</span>(<span class=\"attribute\">onNext</span>: &#123; <span class=\"selector-tag\">a</span>, <span class=\"selector-tag\">b</span> <span class=\"selector-tag\">in</span></span><br><span class=\"line\">true<span class=\"selector-tag\">print</span>(b)\t\t\t<span class=\"comment\">// [0,1]</span></span><br><span class=\"line\">&#125;)<span class=\"selector-class\">.disposed</span>(<span class=\"attribute\">by</span>: bag)   </span><br></pre></td></tr></table></figure>\n<p>有的时候我们同样需要原生的代理方法，RxSwift 也对此进行了支持。不过不能简单的使用 <code>tableView.delegate = self</code> 来实现了。需要调用 <code>tableView.rx.setDelegate(self).disposed(by: bag)</code> 来设置代理人。<strong>注意:委托代理一定要在绑定数据前执行，否则会造成崩溃！</strong><br>直接对 ViewController 进行拓展就能够实现原生代理方法了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">ViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span>(<span class=\"keyword\">_</span> <span class=\"params\">tableView</span>: <span class=\"type\">UITableView</span>, <span class=\"params\">didSelectRowAt</span> <span class=\"params\">indexPath</span>: <span class=\"type\">IndexPath</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 视频中说 会先走 Proxy 中的方法，但是实践的时候我发现情况相反。先走原生代理方法，然后再执行 Proxy 中的订阅方法。</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(indexPath)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"关于下拉刷新\"><a href=\"#关于下拉刷新\" class=\"headerlink\" title=\"关于下拉刷新\"></a>关于下拉刷新</h4><p>下拉刷新这个功能很常见，这里就简单记录一下我的实现方法吧。这里使用三方框架 <code>MJRefresh</code>。<br>首先创建下拉和上拉对象</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶部刷新</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> header = <span class=\"constructor\">MJRefreshNormalHeader()</span></span><br><span class=\"line\"><span class=\"comment\">// 底部刷新</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> footer = <span class=\"constructor\">MJRefreshAutoNormalFooter()</span>    </span><br></pre></td></tr></table></figure>\n<p>然后绑定好处理事件</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">header</span><span class=\"selector-class\">.setRefreshingTarget</span>(self, refreshingAction: <span class=\"selector-id\">#selector</span>(upRefresh))</span><br><span class=\"line\"><span class=\"selector-tag\">footer</span><span class=\"selector-class\">.setRefreshingTarget</span>(self, refreshingAction: <span class=\"selector-id\">#selector</span>(downRefresh))</span><br><span class=\"line\">self<span class=\"selector-class\">.tableView</span><span class=\"selector-class\">.mj_header</span> = <span class=\"selector-tag\">header</span></span><br><span class=\"line\">self<span class=\"selector-class\">.tableView</span><span class=\"selector-class\">.mj_footer</span> = footer</span><br></pre></td></tr></table></figure>\n<p>最后实现刷新事件即可</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc func upRefresh() &#123;</span><br><span class=\"line\">    dataArray<span class=\"selector-class\">.value</span><span class=\"selector-class\">.removeAll</span>()</span><br><span class=\"line\">    page = <span class=\"number\">1</span></span><br><span class=\"line\">    Network<span class=\"selector-class\">.default</span><span class=\"selector-class\">.searchDouBan</span>(start: String(page), count: <span class=\"string\">&quot;10&quot;</span>)<span class=\"selector-class\">.subscribe</span>(onNext:&#123;</span><br><span class=\"line\">        self<span class=\"selector-class\">.tableView</span><span class=\"selector-class\">.mj_header</span><span class=\"selector-class\">.endRefreshing</span>()</span><br><span class=\"line\">        <span class=\"comment\">// 封装成 SectionModel 数据绑定</span></span><br><span class=\"line\">truetrue let sec = SectionModel(model: <span class=\"string\">&quot;header&quot;</span>, items: $<span class=\"number\">0</span>)</span><br><span class=\"line\">        self<span class=\"selector-class\">.dataArray</span><span class=\"selector-class\">.value</span><span class=\"selector-class\">.append</span>(sec)    </span><br><span class=\"line\">    &#125;)<span class=\"selector-class\">.disposed</span>(by: bag)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@objc func downRefresh() &#123;</span><br><span class=\"line\">    page += <span class=\"number\">1</span></span><br><span class=\"line\">    Network<span class=\"selector-class\">.default</span><span class=\"selector-class\">.searchDouBan</span>(start: String(page), count: <span class=\"string\">&quot;10&quot;</span>)<span class=\"selector-class\">.subscribe</span>(onNext:&#123;</span><br><span class=\"line\">        self<span class=\"selector-class\">.tableView</span><span class=\"selector-class\">.mj_footer</span><span class=\"selector-class\">.endRefreshing</span>()</span><br><span class=\"line\">        let sec = SectionModel(model: <span class=\"string\">&quot;header&quot;</span>, items: $<span class=\"number\">0</span>)</span><br><span class=\"line\">        self<span class=\"selector-class\">.dataArray</span><span class=\"selector-class\">.value</span><span class=\"selector-class\">.append</span>(sec)  </span><br><span class=\"line\">    &#125;)<span class=\"selector-class\">.disposed</span>(by: bag)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>UITableView 在开发中是最常使用的控件，由于 UITableview 相对来说功能比较多，所以对应的方法也很多，实现操作起来比较繁琐。通过 RxSwift 可以简化实现 UITableview 的方法，让开发者更注重业务逻辑。</p>\n<!----more----> \n<h4 id=\"简单的实现方式\"><a href=\"#简单的实现方式\" class=\"headerlink\" title=\"简单的实现方式\"></a>简单的实现方式</h4><p>创建一个没有额外 Section 的 Tableview 可以很容易的实现。思路就是通过 Observable 将数据逐个绑定到相应的 Cell 上。</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dataArray = Variable&lt;[model]&gt;([])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"type\">Model</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">title</span>: <span class=\"keyword\">String</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来就是创建一个将 Model 绑定到 Cell 上的闭包</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> setCell = &#123;(i: Int, e: Model, c: TableViewCell) <span class=\"keyword\">in</span></span><br><span class=\"line\">truec.setup<span class=\"constructor\">WithModel(<span class=\"params\">e</span>)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>准备工作都已经做完了，接下来就是最关键的绑定部分，通过 Observeable 的 bind 方法来实现：<br><code>dataArray.asObservable().bind(to: self.tableView.rx.items(cellIdentifier: &quot;Cell&quot;, cellType: TableViewCell.self))(setCell).disposed(by: bag)</code><br>注意其中的 cellType 一定要和刚才创建的闭包中的对应，否则就会报错。</p>\n<h4 id=\"带-Section-的实现方法\"><a href=\"#带-Section-的实现方法\" class=\"headerlink\" title=\"带 Section 的实现方法\"></a>带 Section 的实现方法</h4><p>刚才的实现方式仅仅创建了一个 Section，很多时候是无法满足需求的。想创建带 Section 的 UITableview 就需要引入 <code>import RxDataSources</code> 来实现了。</p>\n<p>首先，创建一个 dataSource 用来处理 UITableview 中的代理方法</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;<span class=\"built_in\">String</span>, Model&gt;&gt;<span class=\"function\"><span class=\"params\">(configureCell:&#123; (source, tableview, index, model) -&gt; UITableViewCell <span class=\"keyword\">in</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">let</span> cell = tableview.dequeueReusableCell(withIdentifier: <span class=\"string\">&quot;Cell&quot;</span>, <span class=\"keyword\">for</span>: index) <span class=\"keyword\">as</span>! TableViewCell</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tcell.setupWithModel(model)</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t<span class=\"keyword\">return</span> cell</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">&#125;)</span></span></span><br></pre></td></tr></table></figure>\n<p>由于需要使用 Section，所以我们的数据源也要进行一些修改：<br><code>var dataArray = Variable&lt;[SectionModel&lt;String, Model&gt;]&gt;([])</code>。<br>接下来的绑定和上边的方式差不多，我们可以直接将 dataSource 绑定到 dataArray 上。</p>\n<p><code>dataArray.asObservable().bind(to: self.tableView.rx.items(dataSource: dataSource)).disposed(by: bag)</code></p>\n<h4 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h4><p>RxSwift 已经提供了很多代理方法以供我们使用，但是有的时候我们还是需要创建自己的代理方法。<br>创建一个新文件来处理 Proxy ：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 泊学网的方法还是 Swift 2.0 的版本 新版的 RxSwift 已经做了一些修改</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDelegateProxy</span>: <span class=\"title\">DelegateProxy</span>&lt;<span class=\"title\">UITableView</span>, <span class=\"title\">UITableViewDelegate</span>&gt; ,<span class=\"title\">UITableViewDelegate</span> ,<span class=\"title\">DelegateProxyType</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">weak</span> <span class=\"keyword\">private(set)</span> <span class=\"keyword\">var</span> tableView: <span class=\"type\">UITableView</span>?</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">tableView</span>: <span class=\"type\">ParentObject</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.tableView <span class=\"operator\">=</span> tableView</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(parentObject: tableView, delegateProxy: <span class=\"type\">MyDelegateProxy</span>.<span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">true <span class=\"comment\">// 如果没有实现这个方法 下面两个方法也不会实现 就会报错！参考了 Rx 中的实现方式实现的</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">registerKnownImplementations</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.register &#123; <span class=\"type\">MyDelegateProxy</span>(tableView: <span class=\"variable\">$0</span>) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setCurrentDelegate</span>(<span class=\"keyword\">_</span> <span class=\"params\">delegate</span>: <span class=\"type\">UITableViewDelegate</span>?, <span class=\"params\">to</span> <span class=\"params\">object</span>: <span class=\"type\">UITableView</span>)</span> &#123;</span><br><span class=\"line\">        object.delegate <span class=\"operator\">=</span> delegate</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">currentDelegate</span>(<span class=\"params\">for</span> <span class=\"params\">object</span>: <span class=\"type\">UITableView</span>)</span> -&gt; <span class=\"type\">UITableViewDelegate</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object.delegate</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来需要对 UITableview 进行拓展</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对 Selector 进行处理可以优雅的调用</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Selector</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> didSelectRowAtIndexPath <span class=\"operator\">=</span> <span class=\"keyword\">#selector</span>(<span class=\"type\">UITableViewDelegate</span>.tableView(<span class=\"keyword\">_</span>:didSelectRowAt:))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UITableView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rxDelegate: <span class=\"type\">MyDelegateProxy</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">MyDelegateProxy</span>.proxy(for: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// RxSwift 中对 Selector 绑定的方法已经修改 这里需要使用 methodInvoked 方法实现。</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> rxDidSelectRowAtIndexPath: <span class=\"type\">Observable</span>&lt;(<span class=\"type\">UITableView</span>, <span class=\"type\">IndexPath</span>)&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rxDelegate.methodInvoked(.didSelectRowAtIndexPath).map &#123; a <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (a[<span class=\"number\">0</span>] <span class=\"keyword\">as!</span> <span class=\"type\">UITableView</span>, a[<span class=\"number\">1</span>] <span class=\"keyword\">as!</span> <span class=\"type\">IndexPath</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等以上准备步骤完成以后，接下来的调用就很容易了：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">tableView</span><span class=\"selector-class\">.rxDidSelectRowAtIndexPath</span><span class=\"selector-class\">.subscribe</span>(<span class=\"attribute\">onNext</span>: &#123; <span class=\"selector-tag\">a</span>, <span class=\"selector-tag\">b</span> <span class=\"selector-tag\">in</span></span><br><span class=\"line\">true<span class=\"selector-tag\">print</span>(b)\t\t\t<span class=\"comment\">// [0,1]</span></span><br><span class=\"line\">&#125;)<span class=\"selector-class\">.disposed</span>(<span class=\"attribute\">by</span>: bag)   </span><br></pre></td></tr></table></figure>\n<p>有的时候我们同样需要原生的代理方法，RxSwift 也对此进行了支持。不过不能简单的使用 <code>tableView.delegate = self</code> 来实现了。需要调用 <code>tableView.rx.setDelegate(self).disposed(by: bag)</code> 来设置代理人。<strong>注意:委托代理一定要在绑定数据前执行，否则会造成崩溃！</strong><br>直接对 ViewController 进行拓展就能够实现原生代理方法了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">ViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span>(<span class=\"keyword\">_</span> <span class=\"params\">tableView</span>: <span class=\"type\">UITableView</span>, <span class=\"params\">didSelectRowAt</span> <span class=\"params\">indexPath</span>: <span class=\"type\">IndexPath</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 视频中说 会先走 Proxy 中的方法，但是实践的时候我发现情况相反。先走原生代理方法，然后再执行 Proxy 中的订阅方法。</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(indexPath)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"关于下拉刷新\"><a href=\"#关于下拉刷新\" class=\"headerlink\" title=\"关于下拉刷新\"></a>关于下拉刷新</h4><p>下拉刷新这个功能很常见，这里就简单记录一下我的实现方法吧。这里使用三方框架 <code>MJRefresh</code>。<br>首先创建下拉和上拉对象</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 顶部刷新</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> header = <span class=\"constructor\">MJRefreshNormalHeader()</span></span><br><span class=\"line\"><span class=\"comment\">// 底部刷新</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> footer = <span class=\"constructor\">MJRefreshAutoNormalFooter()</span>    </span><br></pre></td></tr></table></figure>\n<p>然后绑定好处理事件</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">header</span><span class=\"selector-class\">.setRefreshingTarget</span>(self, refreshingAction: <span class=\"selector-id\">#selector</span>(upRefresh))</span><br><span class=\"line\"><span class=\"selector-tag\">footer</span><span class=\"selector-class\">.setRefreshingTarget</span>(self, refreshingAction: <span class=\"selector-id\">#selector</span>(downRefresh))</span><br><span class=\"line\">self<span class=\"selector-class\">.tableView</span><span class=\"selector-class\">.mj_header</span> = <span class=\"selector-tag\">header</span></span><br><span class=\"line\">self<span class=\"selector-class\">.tableView</span><span class=\"selector-class\">.mj_footer</span> = footer</span><br></pre></td></tr></table></figure>\n<p>最后实现刷新事件即可</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc func upRefresh() &#123;</span><br><span class=\"line\">    dataArray<span class=\"selector-class\">.value</span><span class=\"selector-class\">.removeAll</span>()</span><br><span class=\"line\">    page = <span class=\"number\">1</span></span><br><span class=\"line\">    Network<span class=\"selector-class\">.default</span><span class=\"selector-class\">.searchDouBan</span>(start: String(page), count: <span class=\"string\">&quot;10&quot;</span>)<span class=\"selector-class\">.subscribe</span>(onNext:&#123;</span><br><span class=\"line\">        self<span class=\"selector-class\">.tableView</span><span class=\"selector-class\">.mj_header</span><span class=\"selector-class\">.endRefreshing</span>()</span><br><span class=\"line\">        <span class=\"comment\">// 封装成 SectionModel 数据绑定</span></span><br><span class=\"line\">truetrue let sec = SectionModel(model: <span class=\"string\">&quot;header&quot;</span>, items: $<span class=\"number\">0</span>)</span><br><span class=\"line\">        self<span class=\"selector-class\">.dataArray</span><span class=\"selector-class\">.value</span><span class=\"selector-class\">.append</span>(sec)    </span><br><span class=\"line\">    &#125;)<span class=\"selector-class\">.disposed</span>(by: bag)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@objc func downRefresh() &#123;</span><br><span class=\"line\">    page += <span class=\"number\">1</span></span><br><span class=\"line\">    Network<span class=\"selector-class\">.default</span><span class=\"selector-class\">.searchDouBan</span>(start: String(page), count: <span class=\"string\">&quot;10&quot;</span>)<span class=\"selector-class\">.subscribe</span>(onNext:&#123;</span><br><span class=\"line\">        self<span class=\"selector-class\">.tableView</span><span class=\"selector-class\">.mj_footer</span><span class=\"selector-class\">.endRefreshing</span>()</span><br><span class=\"line\">        let sec = SectionModel(model: <span class=\"string\">&quot;header&quot;</span>, items: $<span class=\"number\">0</span>)</span><br><span class=\"line\">        self<span class=\"selector-class\">.dataArray</span><span class=\"selector-class\">.value</span><span class=\"selector-class\">.append</span>(sec)  </span><br><span class=\"line\">    &#125;)<span class=\"selector-class\">.disposed</span>(by: bag)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"swift","title":"Swift协议拓展","date":"2017-11-20T08:29:11.000Z","_content":"很多时候都会对 UI 进行自定义设置，之前使用 Objective-C 的时候都是用分类来自定义方法，而 Swift 提供了拓展可以更方便的来处理。看过一篇关于 UI 链式编程的博客，发现实现思路很棒，这里来学习一下。\n<!--- more --->\n#### 简单实现方式\n要对 UI 进行拓展可以直接使用 extension 添加自定的方法。但是这么做的话感觉不够帅气！\n\n```\nextension UIView: ViewChainable {\n    func adhere(_ toSupView: UIView) -> Self {\n        toSupView.addSubview(self)\n        return self\n    }\n    // 使用 @discardableResult 关键字可以让 XCode 忽略返回值警告\n    @discardableResult\n    func layout(snapKitMaker: (ConstraintMaker) -> Void) -> Self {\n        self.snp.makeConstraints {\n            snapKitMaker($0)\n        }\n        return self\n    }\n}\n```\n这样就给算给 UIView 添加了 `adhere()` 和 `layout()` 方法。虽然只是给父视图添加自身和 SnapKit 布局，但是简单的思路就是在 extension 中添加自定义方法。\n假设我们现在需求如下：创建一个 UILabel，背景色为透明，字体为20，文字颜色为黑灰，默认文字为 Label。\n如果我们用刚才的思路就是在 extension 中添加一个 `config()` 方法把我们刚才的设定都放进去，然后创建一个 UILabel 调用拓展方法。这么做当然可以，但是不够灵活也不够帅气！！！在 Swift 中可以使用闭包和协议，这些问题就能够很好的解决。\n首先定义一个空的协议。然后对这个协议进行拓展，并且限定 UIView 遵循这个协议。最后就能够在拓展里添加方法，方法的参数是一个闭包，传递自身。\n\n```\nprotocol ViewChainable {}\nextension ViewChainable where Self: UIView {\n    @discardableResult\n    func config(_ config: (Self) -> Void) -> Self {\n        config(self)\n        return self\n    }\n}\n```\n这些协议和拓展设置完成就算是能够对 UI 进行链式编程了。简单的实现如下:\n\n```\nlet label = UILabel()\n    .adhere(toSuperView: view)\n    .layout { (make) in\n        make.top.equalToSuperview().offset(80)\n        make.centerX.equalToSuperview()\n    }\n    .config { (label) in\n        label.backgroundColor = UIColor.clear\n        label.font = UIFont.systemFont(ofSize: 20)\n        label.textColor = UIColor.darkGray\n        label.text = \"Label\"\n    }\n```\n关于我们的需求，看起来好像没有更好的处理，也需要在每个 lable 中进行单独的设置。但是不要忘记了，我们的 `config()` 方法中传递的是一个**闭包**，也就是说可以抽象出设置方法作为参数传递给多个 label。\n\n```\nlet labelConfiger = { (label: UILabel) in\n    label.backgroundColor = UIColor.clear\n    label.font = UIFont.systemFont(ofSize: 20)\n    label.textColor = UIColor.darkGray\n    label.text = \"Label\"\n}\nlabel.config(labelConfiger)\n```\n这个时候如果还有一个 label2。我们就可以给 label2 直接传递定义好的闭包 `labelConfiger`。如果 label2 的 text 需要传递不同的内容，实现起来也很容易，只需要再次传递一个 `config()` 就可以了。\n\n```\nlabel.config(labelConfiger)\n    .config { (label) in\n        label.text = \"Label1\"\n    }\n\nlabel2.config(labelConfiger)\n    .config { (label) in\n        label.text = \"Label2\"\n    }\n```\n其实做到这里，也会发现**链式函数的关键就在于<font color=#d13f28>返回值类型与自身相同</font>**。\n\n#### 很帅气的实现方式\n在使用 RxSwift 的时候就觉得自定义 .rx 的方式很帅，但是一直不知道如何实现的。知道看过了牛人的 blog 才发现实现起来蛮简单的，但是不那么好理解，接下来就按照他的思路一步步整理一下。\n首先肯定是定义一个协议，这个协议的作用就是对需要封装的内容进行拓展，定义一个自定义参数。这里使用 `hu` 作为拓展属性的名称。\n\n```\npublic protocol HUNamespaceProtocol {\n    /// - associatedtype 关键字 用来在协议中表达参数化类型\n    /// - 定义 HUNameType 为协议中的参数类型\n    associatedtype nameType\n    var hu: nameType { get }\n    static var hu: nameType.Type { get }\n}\n```\nTips: 协议中不能直接使用 `Element` 作为泛型关键字，需要时用 `associatedtype` 声明一个形参。\n接下来就需要对这个协议进行拓展。\n\n```\npublic extension HUNamespaceProtocol {\n    var hu: HUNamespaceWrapper<Self> {\n        return HUNamespaceWrapper(value: self)\n    }\n    static var hu: HUNamespaceWrapper<Self>.Type {\n        return HUNamespaceWrapper.self\n    }\n}\npublic protocol TypeWrapperProtocol {\n    associatedtype nameType\n    var wrappedValue: nameType { get }\n    init(value: nameType)\n}\n/// 定义的泛型结构体 遵循 TypeWrapperProtocol 协议\npublic struct HUNamespaceWrapper<T>: TypeWrapperProtocol {\n    public let wrappedValue: T\n    public init(value: T) {\n        self.wrappedValue = value\n    }\n}\n```\n这里对协议的属性 `hu` 进行了拓展，定义了一个泛型结构体来用来接收初始化的对象作为自身。这里有一点难懂。因为这是基于一个这个原理的。\n> namespace 形式扩展的原理，就是对原类型进行一层封装。在 Swift 中，这个封装类型使用的是 Struct，然后，对这个 Struct 进行自定义的方法扩展。\n\n我的理解就是定义了一个泛型结构体，而这个泛型结构体遵循一个协议。这个协议规定了: 1.可以获取自身类型属性。2有一个使用自身属性初始化自身的方法。这样泛型结构体就可以通过 `wrappendVlaue` 属性来获取自身的 Type。这样当我们实现第一个协议的方法时候，规定属性 `hu` 必须继承我们定义的结构体，且通过规定好的初始化方法返回结构体对象。啊。。。还是很难懂。\n\n接下来就是实现自定义的拓展方法了。这一步比较容易理解，只要让需要实现的类型遵循我们定义好的命名协议，然后在实现命名协议的扩展方法就可以了。例如下面分别给 UIView 和 String 添加了自定义方法。\n\n```\nextension UIView: HUNamespaceProtocol { }\n///如果对象是引用类型的(类) 如: UIView 等 就必须使用 :\nextension HUNamespaceWrapper where nameType: UIView {\n    public func adhere(_ toSuperView: UIView) -> T {\n        toSuperView.addSubview(wrappedValue)\n        return wrappedValue\n    }\n    @discardableResult\n    public func layout(_ snapKitMaker: (ConstraintMaker) -> Void) -> T {\n        wrappedValue.snp.makeConstraints {\n            snapKitMaker($0)\n        }\n        return wrappedValue\n    }\n    @discardableResult\n    public func config(_ config: (T) -> Void) -> T {\n        config(wrappedValue)\n        return wrappedValue\n    }\n}\nextension String: HUNamespaceProtocol {}\n/// 如果约束对象是值类型的 如: String, Date 等 就必须使用 ==\nextension HUNamespaceWrapper where nameType == String {\n    func test(_ string: String) -> String {\n        return \"hu:\\(string)\"\n    }\n}\n```\n这样就可以很帅气的实现了。\n\n```\nprint(\"\".hu.test(\"123\"))\nlet button = UIButton(type: .custom)\nbutton.hu.adhere(self.view)\n    .hu.config(buttonConfig)\n    .hu.layout {\n        $0.center.equalTo(self.view)\n        $0.width.equalTo(120)\n        $0.height.equalTo(40)\n}\n```\n<br>\n> 参考资料\n> [Swift 实践篇之链式 UI 代码](https://blog.nswebfrog.com/2017/10/20/swift-practice-ui-chaining-code/)\n> [Swift 命名空间形式扩展的实现](https://blog.nswebfrog.com/2017/03/23/swift-namespace/)","source":"_posts/Swift协议拓展.md","raw":"---\nlayout: swift\ntitle: Swift协议拓展\ndate: 2017-11-20 16:29:11\ntags: \n- Swift\ncategories: \n- Swift\n---\n很多时候都会对 UI 进行自定义设置，之前使用 Objective-C 的时候都是用分类来自定义方法，而 Swift 提供了拓展可以更方便的来处理。看过一篇关于 UI 链式编程的博客，发现实现思路很棒，这里来学习一下。\n<!--- more --->\n#### 简单实现方式\n要对 UI 进行拓展可以直接使用 extension 添加自定的方法。但是这么做的话感觉不够帅气！\n\n```\nextension UIView: ViewChainable {\n    func adhere(_ toSupView: UIView) -> Self {\n        toSupView.addSubview(self)\n        return self\n    }\n    // 使用 @discardableResult 关键字可以让 XCode 忽略返回值警告\n    @discardableResult\n    func layout(snapKitMaker: (ConstraintMaker) -> Void) -> Self {\n        self.snp.makeConstraints {\n            snapKitMaker($0)\n        }\n        return self\n    }\n}\n```\n这样就给算给 UIView 添加了 `adhere()` 和 `layout()` 方法。虽然只是给父视图添加自身和 SnapKit 布局，但是简单的思路就是在 extension 中添加自定义方法。\n假设我们现在需求如下：创建一个 UILabel，背景色为透明，字体为20，文字颜色为黑灰，默认文字为 Label。\n如果我们用刚才的思路就是在 extension 中添加一个 `config()` 方法把我们刚才的设定都放进去，然后创建一个 UILabel 调用拓展方法。这么做当然可以，但是不够灵活也不够帅气！！！在 Swift 中可以使用闭包和协议，这些问题就能够很好的解决。\n首先定义一个空的协议。然后对这个协议进行拓展，并且限定 UIView 遵循这个协议。最后就能够在拓展里添加方法，方法的参数是一个闭包，传递自身。\n\n```\nprotocol ViewChainable {}\nextension ViewChainable where Self: UIView {\n    @discardableResult\n    func config(_ config: (Self) -> Void) -> Self {\n        config(self)\n        return self\n    }\n}\n```\n这些协议和拓展设置完成就算是能够对 UI 进行链式编程了。简单的实现如下:\n\n```\nlet label = UILabel()\n    .adhere(toSuperView: view)\n    .layout { (make) in\n        make.top.equalToSuperview().offset(80)\n        make.centerX.equalToSuperview()\n    }\n    .config { (label) in\n        label.backgroundColor = UIColor.clear\n        label.font = UIFont.systemFont(ofSize: 20)\n        label.textColor = UIColor.darkGray\n        label.text = \"Label\"\n    }\n```\n关于我们的需求，看起来好像没有更好的处理，也需要在每个 lable 中进行单独的设置。但是不要忘记了，我们的 `config()` 方法中传递的是一个**闭包**，也就是说可以抽象出设置方法作为参数传递给多个 label。\n\n```\nlet labelConfiger = { (label: UILabel) in\n    label.backgroundColor = UIColor.clear\n    label.font = UIFont.systemFont(ofSize: 20)\n    label.textColor = UIColor.darkGray\n    label.text = \"Label\"\n}\nlabel.config(labelConfiger)\n```\n这个时候如果还有一个 label2。我们就可以给 label2 直接传递定义好的闭包 `labelConfiger`。如果 label2 的 text 需要传递不同的内容，实现起来也很容易，只需要再次传递一个 `config()` 就可以了。\n\n```\nlabel.config(labelConfiger)\n    .config { (label) in\n        label.text = \"Label1\"\n    }\n\nlabel2.config(labelConfiger)\n    .config { (label) in\n        label.text = \"Label2\"\n    }\n```\n其实做到这里，也会发现**链式函数的关键就在于<font color=#d13f28>返回值类型与自身相同</font>**。\n\n#### 很帅气的实现方式\n在使用 RxSwift 的时候就觉得自定义 .rx 的方式很帅，但是一直不知道如何实现的。知道看过了牛人的 blog 才发现实现起来蛮简单的，但是不那么好理解，接下来就按照他的思路一步步整理一下。\n首先肯定是定义一个协议，这个协议的作用就是对需要封装的内容进行拓展，定义一个自定义参数。这里使用 `hu` 作为拓展属性的名称。\n\n```\npublic protocol HUNamespaceProtocol {\n    /// - associatedtype 关键字 用来在协议中表达参数化类型\n    /// - 定义 HUNameType 为协议中的参数类型\n    associatedtype nameType\n    var hu: nameType { get }\n    static var hu: nameType.Type { get }\n}\n```\nTips: 协议中不能直接使用 `Element` 作为泛型关键字，需要时用 `associatedtype` 声明一个形参。\n接下来就需要对这个协议进行拓展。\n\n```\npublic extension HUNamespaceProtocol {\n    var hu: HUNamespaceWrapper<Self> {\n        return HUNamespaceWrapper(value: self)\n    }\n    static var hu: HUNamespaceWrapper<Self>.Type {\n        return HUNamespaceWrapper.self\n    }\n}\npublic protocol TypeWrapperProtocol {\n    associatedtype nameType\n    var wrappedValue: nameType { get }\n    init(value: nameType)\n}\n/// 定义的泛型结构体 遵循 TypeWrapperProtocol 协议\npublic struct HUNamespaceWrapper<T>: TypeWrapperProtocol {\n    public let wrappedValue: T\n    public init(value: T) {\n        self.wrappedValue = value\n    }\n}\n```\n这里对协议的属性 `hu` 进行了拓展，定义了一个泛型结构体来用来接收初始化的对象作为自身。这里有一点难懂。因为这是基于一个这个原理的。\n> namespace 形式扩展的原理，就是对原类型进行一层封装。在 Swift 中，这个封装类型使用的是 Struct，然后，对这个 Struct 进行自定义的方法扩展。\n\n我的理解就是定义了一个泛型结构体，而这个泛型结构体遵循一个协议。这个协议规定了: 1.可以获取自身类型属性。2有一个使用自身属性初始化自身的方法。这样泛型结构体就可以通过 `wrappendVlaue` 属性来获取自身的 Type。这样当我们实现第一个协议的方法时候，规定属性 `hu` 必须继承我们定义的结构体，且通过规定好的初始化方法返回结构体对象。啊。。。还是很难懂。\n\n接下来就是实现自定义的拓展方法了。这一步比较容易理解，只要让需要实现的类型遵循我们定义好的命名协议，然后在实现命名协议的扩展方法就可以了。例如下面分别给 UIView 和 String 添加了自定义方法。\n\n```\nextension UIView: HUNamespaceProtocol { }\n///如果对象是引用类型的(类) 如: UIView 等 就必须使用 :\nextension HUNamespaceWrapper where nameType: UIView {\n    public func adhere(_ toSuperView: UIView) -> T {\n        toSuperView.addSubview(wrappedValue)\n        return wrappedValue\n    }\n    @discardableResult\n    public func layout(_ snapKitMaker: (ConstraintMaker) -> Void) -> T {\n        wrappedValue.snp.makeConstraints {\n            snapKitMaker($0)\n        }\n        return wrappedValue\n    }\n    @discardableResult\n    public func config(_ config: (T) -> Void) -> T {\n        config(wrappedValue)\n        return wrappedValue\n    }\n}\nextension String: HUNamespaceProtocol {}\n/// 如果约束对象是值类型的 如: String, Date 等 就必须使用 ==\nextension HUNamespaceWrapper where nameType == String {\n    func test(_ string: String) -> String {\n        return \"hu:\\(string)\"\n    }\n}\n```\n这样就可以很帅气的实现了。\n\n```\nprint(\"\".hu.test(\"123\"))\nlet button = UIButton(type: .custom)\nbutton.hu.adhere(self.view)\n    .hu.config(buttonConfig)\n    .hu.layout {\n        $0.center.equalTo(self.view)\n        $0.width.equalTo(120)\n        $0.height.equalTo(40)\n}\n```\n<br>\n> 参考资料\n> [Swift 实践篇之链式 UI 代码](https://blog.nswebfrog.com/2017/10/20/swift-practice-ui-chaining-code/)\n> [Swift 命名空间形式扩展的实现](https://blog.nswebfrog.com/2017/03/23/swift-namespace/)","slug":"Swift协议拓展","published":1,"updated":"2017-11-21T07:04:07.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfy9v000f7sn617br57og","content":"<p>很多时候都会对 UI 进行自定义设置，之前使用 Objective-C 的时候都是用分类来自定义方法，而 Swift 提供了拓展可以更方便的来处理。看过一篇关于 UI 链式编程的博客，发现实现思路很棒，这里来学习一下。</p>\n<!--- more --->\n<h4 id=\"简单实现方式\"><a href=\"#简单实现方式\" class=\"headerlink\" title=\"简单实现方式\"></a>简单实现方式</h4><p>要对 UI 进行拓展可以直接使用 extension 添加自定的方法。但是这么做的话感觉不够帅气！</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIView</span>: <span class=\"title\">ViewChainable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adhere</span>(<span class=\"keyword\">_</span> <span class=\"params\">toSupView</span>: <span class=\"type\">UIView</span>)</span> -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        toSupView.addSubview(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 @discardableResult 关键字可以让 XCode 忽略返回值警告</span></span><br><span class=\"line\">    <span class=\"keyword\">@discardableResult</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layout</span>(<span class=\"params\">snapKitMaker</span>: (<span class=\"type\">ConstraintMaker</span>) -&gt; <span class=\"type\">Void</span>)</span> -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.snp.makeConstraints &#123;</span><br><span class=\"line\">            snapKitMaker(<span class=\"variable\">$0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就给算给 UIView 添加了 <code>adhere()</code> 和 <code>layout()</code> 方法。虽然只是给父视图添加自身和 SnapKit 布局，但是简单的思路就是在 extension 中添加自定义方法。<br>假设我们现在需求如下：创建一个 UILabel，背景色为透明，字体为20，文字颜色为黑灰，默认文字为 Label。<br>如果我们用刚才的思路就是在 extension 中添加一个 <code>config()</code> 方法把我们刚才的设定都放进去，然后创建一个 UILabel 调用拓展方法。这么做当然可以，但是不够灵活也不够帅气！！！在 Swift 中可以使用闭包和协议，这些问题就能够很好的解决。<br>首先定义一个空的协议。然后对这个协议进行拓展，并且限定 UIView 遵循这个协议。最后就能够在拓展里添加方法，方法的参数是一个闭包，传递自身。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">ViewChainable</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">ViewChainable</span> <span class=\"title\">where</span> <span class=\"title\">Self</span>: <span class=\"title\">UIView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@discardableResult</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">config</span>(<span class=\"keyword\">_</span> <span class=\"params\">config</span>: (<span class=\"keyword\">Self</span>) -&gt; <span class=\"type\">Void</span>)</span> -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        config(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些协议和拓展设置完成就算是能够对 UI 进行链式编程了。简单的实现如下:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let <span class=\"selector-tag\">label</span> = UILabel()</span><br><span class=\"line\">    <span class=\"selector-class\">.adhere</span>(toSuperView: view)</span><br><span class=\"line\">    <span class=\"selector-class\">.layout</span> &#123; (make) <span class=\"keyword\">in</span></span><br><span class=\"line\">        make<span class=\"selector-class\">.top</span><span class=\"selector-class\">.equalToSuperview</span>()<span class=\"selector-class\">.offset</span>(<span class=\"number\">80</span>)</span><br><span class=\"line\">        make<span class=\"selector-class\">.centerX</span><span class=\"selector-class\">.equalToSuperview</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-class\">.config</span> &#123; (label) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"selector-tag\">label</span><span class=\"selector-class\">.backgroundColor</span> = UIColor<span class=\"selector-class\">.clear</span></span><br><span class=\"line\">        <span class=\"selector-tag\">label</span><span class=\"selector-class\">.font</span> = UIFont<span class=\"selector-class\">.systemFont</span>(ofSize: <span class=\"number\">20</span>)</span><br><span class=\"line\">        <span class=\"selector-tag\">label</span><span class=\"selector-class\">.textColor</span> = UIColor<span class=\"selector-class\">.darkGray</span></span><br><span class=\"line\">        <span class=\"selector-tag\">label</span><span class=\"selector-class\">.text</span> = <span class=\"string\">&quot;Label&quot;</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>关于我们的需求，看起来好像没有更好的处理，也需要在每个 lable 中进行单独的设置。但是不要忘记了，我们的 <code>config()</code> 方法中传递的是一个<strong>闭包</strong>，也就是说可以抽象出设置方法作为参数传递给多个 label。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let labelConfiger = &#123; (<span class=\"selector-tag\">label</span>: UILabel) <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"selector-tag\">label</span><span class=\"selector-class\">.backgroundColor</span> = UIColor<span class=\"selector-class\">.clear</span></span><br><span class=\"line\">    <span class=\"selector-tag\">label</span><span class=\"selector-class\">.font</span> = UIFont<span class=\"selector-class\">.systemFont</span>(ofSize: <span class=\"number\">20</span>)</span><br><span class=\"line\">    <span class=\"selector-tag\">label</span><span class=\"selector-class\">.textColor</span> = UIColor<span class=\"selector-class\">.darkGray</span></span><br><span class=\"line\">    <span class=\"selector-tag\">label</span><span class=\"selector-class\">.text</span> = <span class=\"string\">&quot;Label&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">label</span><span class=\"selector-class\">.config</span>(labelConfiger)</span><br></pre></td></tr></table></figure>\n<p>这个时候如果还有一个 label2。我们就可以给 label2 直接传递定义好的闭包 <code>labelConfiger</code>。如果 label2 的 text 需要传递不同的内容，实现起来也很容易，只需要再次传递一个 <code>config()</code> 就可以了。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">label</span><span class=\"selector-class\">.config</span>(labelConfiger)</span><br><span class=\"line\">    <span class=\"selector-class\">.config</span> &#123; (label) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"selector-tag\">label</span><span class=\"selector-class\">.text</span> = <span class=\"string\">&quot;Label1&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label2<span class=\"selector-class\">.config</span>(labelConfiger)</span><br><span class=\"line\">    <span class=\"selector-class\">.config</span> &#123; (label) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"selector-tag\">label</span><span class=\"selector-class\">.text</span> = <span class=\"string\">&quot;Label2&quot;</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其实做到这里，也会发现**链式函数的关键就在于<font color=#d13f28>返回值类型与自身相同</font>**。</p>\n<h4 id=\"很帅气的实现方式\"><a href=\"#很帅气的实现方式\" class=\"headerlink\" title=\"很帅气的实现方式\"></a>很帅气的实现方式</h4><p>在使用 RxSwift 的时候就觉得自定义 .rx 的方式很帅，但是一直不知道如何实现的。知道看过了牛人的 blog 才发现实现起来蛮简单的，但是不那么好理解，接下来就按照他的思路一步步整理一下。<br>首先肯定是定义一个协议，这个协议的作用就是对需要封装的内容进行拓展，定义一个自定义参数。这里使用 <code>hu</code> 作为拓展属性的名称。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">HUNamespaceProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// - associatedtype 关键字 用来在协议中表达参数化类型</span></span><br><span class=\"line\">    <span class=\"comment\">/// - 定义 HUNameType 为协议中的参数类型</span></span><br><span class=\"line\">    <span class=\"keyword\">associatedtype</span> nameType</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hu: nameType &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> hu: nameType.<span class=\"keyword\">Type</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tips: 协议中不能直接使用 <code>Element</code> 作为泛型关键字，需要时用 <code>associatedtype</code> 声明一个形参。<br>接下来就需要对这个协议进行拓展。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">HUNamespaceProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hu: <span class=\"type\">HUNamespaceWrapper</span>&lt;<span class=\"keyword\">Self</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">HUNamespaceWrapper</span>(value: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> hu: <span class=\"type\">HUNamespaceWrapper</span>&lt;<span class=\"keyword\">Self</span>&gt;.<span class=\"keyword\">Type</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">HUNamespaceWrapper</span>.<span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">TypeWrapperProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">associatedtype</span> nameType</span><br><span class=\"line\">    <span class=\"keyword\">var</span> wrappedValue: nameType &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">value</span>: nameType)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/// 定义的泛型结构体 遵循 TypeWrapperProtocol 协议</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HUNamespaceWrapper</span>&lt;<span class=\"title\">T</span>&gt;: <span class=\"title\">TypeWrapperProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> wrappedValue: <span class=\"type\">T</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">value</span>: <span class=\"type\">T</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.wrappedValue <span class=\"operator\">=</span> value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里对协议的属性 <code>hu</code> 进行了拓展，定义了一个泛型结构体来用来接收初始化的对象作为自身。这里有一点难懂。因为这是基于一个这个原理的。</p>\n<blockquote>\n<p>namespace 形式扩展的原理，就是对原类型进行一层封装。在 Swift 中，这个封装类型使用的是 Struct，然后，对这个 Struct 进行自定义的方法扩展。</p>\n</blockquote>\n<p>我的理解就是定义了一个泛型结构体，而这个泛型结构体遵循一个协议。这个协议规定了: 1.可以获取自身类型属性。2有一个使用自身属性初始化自身的方法。这样泛型结构体就可以通过 <code>wrappendVlaue</code> 属性来获取自身的 Type。这样当我们实现第一个协议的方法时候，规定属性 <code>hu</code> 必须继承我们定义的结构体，且通过规定好的初始化方法返回结构体对象。啊。。。还是很难懂。</p>\n<p>接下来就是实现自定义的拓展方法了。这一步比较容易理解，只要让需要实现的类型遵循我们定义好的命名协议，然后在实现命名协议的扩展方法就可以了。例如下面分别给 UIView 和 String 添加了自定义方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIView</span>: <span class=\"title\">HUNamespaceProtocol</span> </span>&#123; &#125;</span><br><span class=\"line\"><span class=\"comment\">///如果对象是引用类型的(类) 如: UIView 等 就必须使用 :</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">HUNamespaceWrapper</span> <span class=\"title\">where</span> <span class=\"title\">nameType</span>: <span class=\"title\">UIView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adhere</span>(<span class=\"keyword\">_</span> <span class=\"params\">toSuperView</span>: <span class=\"type\">UIView</span>)</span> -&gt; <span class=\"type\">T</span> &#123;</span><br><span class=\"line\">        toSuperView.addSubview(wrappedValue)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrappedValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">@discardableResult</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layout</span>(<span class=\"keyword\">_</span> <span class=\"params\">snapKitMaker</span>: (<span class=\"type\">ConstraintMaker</span>) -&gt; <span class=\"type\">Void</span>)</span> -&gt; <span class=\"type\">T</span> &#123;</span><br><span class=\"line\">        wrappedValue.snp.makeConstraints &#123;</span><br><span class=\"line\">            snapKitMaker(<span class=\"variable\">$0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrappedValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">@discardableResult</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">config</span>(<span class=\"keyword\">_</span> <span class=\"params\">config</span>: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Void</span>)</span> -&gt; <span class=\"type\">T</span> &#123;</span><br><span class=\"line\">        config(wrappedValue)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrappedValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">String</span>: <span class=\"title\">HUNamespaceProtocol</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">/// 如果约束对象是值类型的 如: String, Date 等 就必须使用 ==</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">HUNamespaceWrapper</span> <span class=\"title\">where</span> <span class=\"title\">nameType</span> == <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span>(<span class=\"keyword\">_</span> <span class=\"params\">string</span>: <span class=\"type\">String</span>)</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hu:<span class=\"subst\">\\(string)</span>&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以很帅气的实现了。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(<span class=\"string\">&quot;&quot;</span>.hu.test(<span class=\"string\">&quot;123&quot;</span>)</span></span>)</span><br><span class=\"line\">let <span class=\"selector-tag\">button</span> = UIButton(type: .custom)</span><br><span class=\"line\"><span class=\"selector-tag\">button</span><span class=\"selector-class\">.hu</span><span class=\"selector-class\">.adhere</span>(self.view)</span><br><span class=\"line\">    <span class=\"selector-class\">.hu</span><span class=\"selector-class\">.config</span>(buttonConfig)</span><br><span class=\"line\">    <span class=\"selector-class\">.hu</span><span class=\"selector-class\">.layout</span> &#123;</span><br><span class=\"line\">        $<span class=\"number\">0</span><span class=\"selector-class\">.center</span><span class=\"selector-class\">.equalTo</span>(self.view)</span><br><span class=\"line\">        $<span class=\"number\">0</span><span class=\"selector-class\">.width</span><span class=\"selector-class\">.equalTo</span>(<span class=\"number\">120</span>)</span><br><span class=\"line\">        $<span class=\"number\">0</span><span class=\"selector-class\">.height</span><span class=\"selector-class\">.equalTo</span>(<span class=\"number\">40</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n> 参考资料\n> [Swift 实践篇之链式 UI 代码](https://blog.nswebfrog.com/2017/10/20/swift-practice-ui-chaining-code/)\n> [Swift 命名空间形式扩展的实现](https://blog.nswebfrog.com/2017/03/23/swift-namespace/)","site":{"data":{}},"excerpt":"","more":"<p>很多时候都会对 UI 进行自定义设置，之前使用 Objective-C 的时候都是用分类来自定义方法，而 Swift 提供了拓展可以更方便的来处理。看过一篇关于 UI 链式编程的博客，发现实现思路很棒，这里来学习一下。</p>\n<!--- more --->\n<h4 id=\"简单实现方式\"><a href=\"#简单实现方式\" class=\"headerlink\" title=\"简单实现方式\"></a>简单实现方式</h4><p>要对 UI 进行拓展可以直接使用 extension 添加自定的方法。但是这么做的话感觉不够帅气！</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIView</span>: <span class=\"title\">ViewChainable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adhere</span>(<span class=\"keyword\">_</span> <span class=\"params\">toSupView</span>: <span class=\"type\">UIView</span>)</span> -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        toSupView.addSubview(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 @discardableResult 关键字可以让 XCode 忽略返回值警告</span></span><br><span class=\"line\">    <span class=\"keyword\">@discardableResult</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layout</span>(<span class=\"params\">snapKitMaker</span>: (<span class=\"type\">ConstraintMaker</span>) -&gt; <span class=\"type\">Void</span>)</span> -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.snp.makeConstraints &#123;</span><br><span class=\"line\">            snapKitMaker(<span class=\"variable\">$0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就给算给 UIView 添加了 <code>adhere()</code> 和 <code>layout()</code> 方法。虽然只是给父视图添加自身和 SnapKit 布局，但是简单的思路就是在 extension 中添加自定义方法。<br>假设我们现在需求如下：创建一个 UILabel，背景色为透明，字体为20，文字颜色为黑灰，默认文字为 Label。<br>如果我们用刚才的思路就是在 extension 中添加一个 <code>config()</code> 方法把我们刚才的设定都放进去，然后创建一个 UILabel 调用拓展方法。这么做当然可以，但是不够灵活也不够帅气！！！在 Swift 中可以使用闭包和协议，这些问题就能够很好的解决。<br>首先定义一个空的协议。然后对这个协议进行拓展，并且限定 UIView 遵循这个协议。最后就能够在拓展里添加方法，方法的参数是一个闭包，传递自身。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">ViewChainable</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">ViewChainable</span> <span class=\"title\">where</span> <span class=\"title\">Self</span>: <span class=\"title\">UIView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">@discardableResult</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">config</span>(<span class=\"keyword\">_</span> <span class=\"params\">config</span>: (<span class=\"keyword\">Self</span>) -&gt; <span class=\"type\">Void</span>)</span> -&gt; <span class=\"keyword\">Self</span> &#123;</span><br><span class=\"line\">        config(<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这些协议和拓展设置完成就算是能够对 UI 进行链式编程了。简单的实现如下:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let <span class=\"selector-tag\">label</span> = UILabel()</span><br><span class=\"line\">    <span class=\"selector-class\">.adhere</span>(toSuperView: view)</span><br><span class=\"line\">    <span class=\"selector-class\">.layout</span> &#123; (make) <span class=\"keyword\">in</span></span><br><span class=\"line\">        make<span class=\"selector-class\">.top</span><span class=\"selector-class\">.equalToSuperview</span>()<span class=\"selector-class\">.offset</span>(<span class=\"number\">80</span>)</span><br><span class=\"line\">        make<span class=\"selector-class\">.centerX</span><span class=\"selector-class\">.equalToSuperview</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-class\">.config</span> &#123; (label) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"selector-tag\">label</span><span class=\"selector-class\">.backgroundColor</span> = UIColor<span class=\"selector-class\">.clear</span></span><br><span class=\"line\">        <span class=\"selector-tag\">label</span><span class=\"selector-class\">.font</span> = UIFont<span class=\"selector-class\">.systemFont</span>(ofSize: <span class=\"number\">20</span>)</span><br><span class=\"line\">        <span class=\"selector-tag\">label</span><span class=\"selector-class\">.textColor</span> = UIColor<span class=\"selector-class\">.darkGray</span></span><br><span class=\"line\">        <span class=\"selector-tag\">label</span><span class=\"selector-class\">.text</span> = <span class=\"string\">&quot;Label&quot;</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>关于我们的需求，看起来好像没有更好的处理，也需要在每个 lable 中进行单独的设置。但是不要忘记了，我们的 <code>config()</code> 方法中传递的是一个<strong>闭包</strong>，也就是说可以抽象出设置方法作为参数传递给多个 label。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let labelConfiger = &#123; (<span class=\"selector-tag\">label</span>: UILabel) <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"selector-tag\">label</span><span class=\"selector-class\">.backgroundColor</span> = UIColor<span class=\"selector-class\">.clear</span></span><br><span class=\"line\">    <span class=\"selector-tag\">label</span><span class=\"selector-class\">.font</span> = UIFont<span class=\"selector-class\">.systemFont</span>(ofSize: <span class=\"number\">20</span>)</span><br><span class=\"line\">    <span class=\"selector-tag\">label</span><span class=\"selector-class\">.textColor</span> = UIColor<span class=\"selector-class\">.darkGray</span></span><br><span class=\"line\">    <span class=\"selector-tag\">label</span><span class=\"selector-class\">.text</span> = <span class=\"string\">&quot;Label&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">label</span><span class=\"selector-class\">.config</span>(labelConfiger)</span><br></pre></td></tr></table></figure>\n<p>这个时候如果还有一个 label2。我们就可以给 label2 直接传递定义好的闭包 <code>labelConfiger</code>。如果 label2 的 text 需要传递不同的内容，实现起来也很容易，只需要再次传递一个 <code>config()</code> 就可以了。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">label</span><span class=\"selector-class\">.config</span>(labelConfiger)</span><br><span class=\"line\">    <span class=\"selector-class\">.config</span> &#123; (label) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"selector-tag\">label</span><span class=\"selector-class\">.text</span> = <span class=\"string\">&quot;Label1&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">label2<span class=\"selector-class\">.config</span>(labelConfiger)</span><br><span class=\"line\">    <span class=\"selector-class\">.config</span> &#123; (label) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"selector-tag\">label</span><span class=\"selector-class\">.text</span> = <span class=\"string\">&quot;Label2&quot;</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其实做到这里，也会发现**链式函数的关键就在于<font color=#d13f28>返回值类型与自身相同</font>**。</p>\n<h4 id=\"很帅气的实现方式\"><a href=\"#很帅气的实现方式\" class=\"headerlink\" title=\"很帅气的实现方式\"></a>很帅气的实现方式</h4><p>在使用 RxSwift 的时候就觉得自定义 .rx 的方式很帅，但是一直不知道如何实现的。知道看过了牛人的 blog 才发现实现起来蛮简单的，但是不那么好理解，接下来就按照他的思路一步步整理一下。<br>首先肯定是定义一个协议，这个协议的作用就是对需要封装的内容进行拓展，定义一个自定义参数。这里使用 <code>hu</code> 作为拓展属性的名称。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">HUNamespaceProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/// - associatedtype 关键字 用来在协议中表达参数化类型</span></span><br><span class=\"line\">    <span class=\"comment\">/// - 定义 HUNameType 为协议中的参数类型</span></span><br><span class=\"line\">    <span class=\"keyword\">associatedtype</span> nameType</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hu: nameType &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> hu: nameType.<span class=\"keyword\">Type</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tips: 协议中不能直接使用 <code>Element</code> 作为泛型关键字，需要时用 <code>associatedtype</code> 声明一个形参。<br>接下来就需要对这个协议进行拓展。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">HUNamespaceProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hu: <span class=\"type\">HUNamespaceWrapper</span>&lt;<span class=\"keyword\">Self</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">HUNamespaceWrapper</span>(value: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> hu: <span class=\"type\">HUNamespaceWrapper</span>&lt;<span class=\"keyword\">Self</span>&gt;.<span class=\"keyword\">Type</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">HUNamespaceWrapper</span>.<span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">TypeWrapperProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">associatedtype</span> nameType</span><br><span class=\"line\">    <span class=\"keyword\">var</span> wrappedValue: nameType &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">value</span>: nameType)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/// 定义的泛型结构体 遵循 TypeWrapperProtocol 协议</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">HUNamespaceWrapper</span>&lt;<span class=\"title\">T</span>&gt;: <span class=\"title\">TypeWrapperProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> wrappedValue: <span class=\"type\">T</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">value</span>: <span class=\"type\">T</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.wrappedValue <span class=\"operator\">=</span> value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里对协议的属性 <code>hu</code> 进行了拓展，定义了一个泛型结构体来用来接收初始化的对象作为自身。这里有一点难懂。因为这是基于一个这个原理的。</p>\n<blockquote>\n<p>namespace 形式扩展的原理，就是对原类型进行一层封装。在 Swift 中，这个封装类型使用的是 Struct，然后，对这个 Struct 进行自定义的方法扩展。</p>\n</blockquote>\n<p>我的理解就是定义了一个泛型结构体，而这个泛型结构体遵循一个协议。这个协议规定了: 1.可以获取自身类型属性。2有一个使用自身属性初始化自身的方法。这样泛型结构体就可以通过 <code>wrappendVlaue</code> 属性来获取自身的 Type。这样当我们实现第一个协议的方法时候，规定属性 <code>hu</code> 必须继承我们定义的结构体，且通过规定好的初始化方法返回结构体对象。啊。。。还是很难懂。</p>\n<p>接下来就是实现自定义的拓展方法了。这一步比较容易理解，只要让需要实现的类型遵循我们定义好的命名协议，然后在实现命名协议的扩展方法就可以了。例如下面分别给 UIView 和 String 添加了自定义方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIView</span>: <span class=\"title\">HUNamespaceProtocol</span> </span>&#123; &#125;</span><br><span class=\"line\"><span class=\"comment\">///如果对象是引用类型的(类) 如: UIView 等 就必须使用 :</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">HUNamespaceWrapper</span> <span class=\"title\">where</span> <span class=\"title\">nameType</span>: <span class=\"title\">UIView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adhere</span>(<span class=\"keyword\">_</span> <span class=\"params\">toSuperView</span>: <span class=\"type\">UIView</span>)</span> -&gt; <span class=\"type\">T</span> &#123;</span><br><span class=\"line\">        toSuperView.addSubview(wrappedValue)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrappedValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">@discardableResult</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layout</span>(<span class=\"keyword\">_</span> <span class=\"params\">snapKitMaker</span>: (<span class=\"type\">ConstraintMaker</span>) -&gt; <span class=\"type\">Void</span>)</span> -&gt; <span class=\"type\">T</span> &#123;</span><br><span class=\"line\">        wrappedValue.snp.makeConstraints &#123;</span><br><span class=\"line\">            snapKitMaker(<span class=\"variable\">$0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrappedValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">@discardableResult</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">config</span>(<span class=\"keyword\">_</span> <span class=\"params\">config</span>: (<span class=\"type\">T</span>) -&gt; <span class=\"type\">Void</span>)</span> -&gt; <span class=\"type\">T</span> &#123;</span><br><span class=\"line\">        config(wrappedValue)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrappedValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">String</span>: <span class=\"title\">HUNamespaceProtocol</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">/// 如果约束对象是值类型的 如: String, Date 等 就必须使用 ==</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">HUNamespaceWrapper</span> <span class=\"title\">where</span> <span class=\"title\">nameType</span> == <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span>(<span class=\"keyword\">_</span> <span class=\"params\">string</span>: <span class=\"type\">String</span>)</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hu:<span class=\"subst\">\\(string)</span>&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以很帅气的实现了。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span><span class=\"params\">(<span class=\"string\">&quot;&quot;</span>.hu.test(<span class=\"string\">&quot;123&quot;</span>)</span></span>)</span><br><span class=\"line\">let <span class=\"selector-tag\">button</span> = UIButton(type: .custom)</span><br><span class=\"line\"><span class=\"selector-tag\">button</span><span class=\"selector-class\">.hu</span><span class=\"selector-class\">.adhere</span>(self.view)</span><br><span class=\"line\">    <span class=\"selector-class\">.hu</span><span class=\"selector-class\">.config</span>(buttonConfig)</span><br><span class=\"line\">    <span class=\"selector-class\">.hu</span><span class=\"selector-class\">.layout</span> &#123;</span><br><span class=\"line\">        $<span class=\"number\">0</span><span class=\"selector-class\">.center</span><span class=\"selector-class\">.equalTo</span>(self.view)</span><br><span class=\"line\">        $<span class=\"number\">0</span><span class=\"selector-class\">.width</span><span class=\"selector-class\">.equalTo</span>(<span class=\"number\">120</span>)</span><br><span class=\"line\">        $<span class=\"number\">0</span><span class=\"selector-class\">.height</span><span class=\"selector-class\">.equalTo</span>(<span class=\"number\">40</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n> 参考资料\n> [Swift 实践篇之链式 UI 代码](https://blog.nswebfrog.com/2017/10/20/swift-practice-ui-chaining-code/)\n> [Swift 命名空间形式扩展的实现](https://blog.nswebfrog.com/2017/03/23/swift-namespace/)"},{"layout":"swift","title":"Swift实现可编辑标签页","date":"2018-03-22T06:19:46.000Z","_content":"工作中遇到一个需要自定义的标签页，在网上找到了一个比较合适的 demo，可惜是以 Objective-C 实现的。就正好自己再用 swift 重写一下，也学习一下别人的思路。\n<!---- more ---->\n#### SDTagsView  \n[这里](https://github.com/SlowDony/SDTagsView) 是原作者的 demo，他分别采用了 Label 和 CollectionView 两种实现方式。不过作者比较推荐第二种，我也只以 CollectionView 的方式实现。\n![SDTagsView](https://github.com/SlowDony/SDTagsView/blob/master/SDTagsView/SDEditTagsView.gif?raw=true)\n#### 目录结构\n因为我们这个 UI 控件可能需要在任意的 UIViewcontroller 中点击出现。所以我采用将这个控件同样以一个 UIViewcontroller 为承载。在需要的时候调用 present 弹出即可。目录结构如下:\n![](https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E7%AC%94%E8%AE%B0/%E6%A0%87%E7%AD%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png?raw=true)\n#### 实现 HUEditTagsViewController\nTagsViewController 作为一个 Controller，是放置 view 和相关数据的基本控件。我们需要在此定义好数据源和相关的 view。\n\n```\nvar myTagsArr: [String] = []\n    var moreTagsArr: [String] = []\n    private var dataArr: [[String]] {\n        return [self.myTagsArr, self.moreTagsArr]\n    }\n    typealias tagsBlock = ([String], [String]) -> Void\n    var saveBlock: tagsBlock?\n    \n    var tagsView : HUCollectionTagsView?\n```\n定义好必要的属性后，在 viewDidLoad 方法中做好相关的设置就可以了。这里我定义了3个数组，第一个数组放置我的标签内容，第二个数组放置更多标签的内容，第三个数组只有 get 方法，是将前两个数组放置到一起，传递给 view 作为数据源使用。\n#### 实现 HUCollectionTagsView\n这个作为一个 collectionview，实现它并不复杂。需要注意的是，我们这个 collectionview 实现头部view，也同样需要注册 header 的 cellIdefntifier，否则会造成崩溃。\n\n```\nself.register(UICollectionReusableView.self, forSupplementaryViewOfKind: UICollectionElementKindSectionHeader, withReuseIdentifier: cellHeaderIdentifier)\n```\n。需要在初始化的时候注册，和 cell 一样。\n#### 实现 HUCollectViewCell 和 HUCollectionTagsFlowLayout\n这两个配置文件是对 collectionview 的具体必要配置，可以按照自己的需求进行自定义。\n#### 点击移动 item\n至此，整体的结构已经实现完成，最后要实现一些点击事件的交互逻辑就可以完成。\n\n由于点击事件的代理方法是绑定在 view 中的，但是我们想要点击时对 Controller 中的数据进行修改，就需要将事件传递出去。实现方式有很多，可以使用代理、block等。这里我们采用代理方式，需要自定义一个协议。\n\n```\nprotocol HUCollectionTagsViewDelegate {\n    func collectionTagsView(collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)\n}\n/// HUCollectionTagsView \nvar hu_delegate: HUCollectionTagsViewDelegate?\n\nfunc collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n\tself.hu_delegate?.collectionTagsView(collectionView: self, didSelectItemAt: indexPath)\n}\n```\n这个协议只有一个必要实现的方法，就是响应点击具体的 item。 \n再由 HUEditTagsViewController 来实现：\n\n```\nfunc collectionTagsView(collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n\t\t/// 处理点击 改变数据内容\n}\n```\n做的时候觉得数据的传递绑定处理的不太完善，但是一直也没想到更好的处理办法，还需要进行优化，如果后面想到了，再来修改吧。\n最后实现效果：\n![](https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E7%AC%94%E8%AE%B0/%E6%A0%87%E7%AD%BE%E6%95%88%E6%9E%9C.gif?raw=true)\n完整代码在[这里](https://github.com/hGhostD/HUTagsView)\n\n<br>\n<br>\n> 参考资料\n> [SDTagsView1.0](https://github.com/SlowDony/SDTagsView)","source":"_posts/Swift实现可编辑标签页.md","raw":"---\nlayout: swift\ntitle: Swift实现可编辑标签页\ndate: 2018-03-22 14:19:46\ntags: \n- Swift\ncategories: \n- Swift\n---\n工作中遇到一个需要自定义的标签页，在网上找到了一个比较合适的 demo，可惜是以 Objective-C 实现的。就正好自己再用 swift 重写一下，也学习一下别人的思路。\n<!---- more ---->\n#### SDTagsView  \n[这里](https://github.com/SlowDony/SDTagsView) 是原作者的 demo，他分别采用了 Label 和 CollectionView 两种实现方式。不过作者比较推荐第二种，我也只以 CollectionView 的方式实现。\n![SDTagsView](https://github.com/SlowDony/SDTagsView/blob/master/SDTagsView/SDEditTagsView.gif?raw=true)\n#### 目录结构\n因为我们这个 UI 控件可能需要在任意的 UIViewcontroller 中点击出现。所以我采用将这个控件同样以一个 UIViewcontroller 为承载。在需要的时候调用 present 弹出即可。目录结构如下:\n![](https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E7%AC%94%E8%AE%B0/%E6%A0%87%E7%AD%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png?raw=true)\n#### 实现 HUEditTagsViewController\nTagsViewController 作为一个 Controller，是放置 view 和相关数据的基本控件。我们需要在此定义好数据源和相关的 view。\n\n```\nvar myTagsArr: [String] = []\n    var moreTagsArr: [String] = []\n    private var dataArr: [[String]] {\n        return [self.myTagsArr, self.moreTagsArr]\n    }\n    typealias tagsBlock = ([String], [String]) -> Void\n    var saveBlock: tagsBlock?\n    \n    var tagsView : HUCollectionTagsView?\n```\n定义好必要的属性后，在 viewDidLoad 方法中做好相关的设置就可以了。这里我定义了3个数组，第一个数组放置我的标签内容，第二个数组放置更多标签的内容，第三个数组只有 get 方法，是将前两个数组放置到一起，传递给 view 作为数据源使用。\n#### 实现 HUCollectionTagsView\n这个作为一个 collectionview，实现它并不复杂。需要注意的是，我们这个 collectionview 实现头部view，也同样需要注册 header 的 cellIdefntifier，否则会造成崩溃。\n\n```\nself.register(UICollectionReusableView.self, forSupplementaryViewOfKind: UICollectionElementKindSectionHeader, withReuseIdentifier: cellHeaderIdentifier)\n```\n。需要在初始化的时候注册，和 cell 一样。\n#### 实现 HUCollectViewCell 和 HUCollectionTagsFlowLayout\n这两个配置文件是对 collectionview 的具体必要配置，可以按照自己的需求进行自定义。\n#### 点击移动 item\n至此，整体的结构已经实现完成，最后要实现一些点击事件的交互逻辑就可以完成。\n\n由于点击事件的代理方法是绑定在 view 中的，但是我们想要点击时对 Controller 中的数据进行修改，就需要将事件传递出去。实现方式有很多，可以使用代理、block等。这里我们采用代理方式，需要自定义一个协议。\n\n```\nprotocol HUCollectionTagsViewDelegate {\n    func collectionTagsView(collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath)\n}\n/// HUCollectionTagsView \nvar hu_delegate: HUCollectionTagsViewDelegate?\n\nfunc collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n\tself.hu_delegate?.collectionTagsView(collectionView: self, didSelectItemAt: indexPath)\n}\n```\n这个协议只有一个必要实现的方法，就是响应点击具体的 item。 \n再由 HUEditTagsViewController 来实现：\n\n```\nfunc collectionTagsView(collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n\t\t/// 处理点击 改变数据内容\n}\n```\n做的时候觉得数据的传递绑定处理的不太完善，但是一直也没想到更好的处理办法，还需要进行优化，如果后面想到了，再来修改吧。\n最后实现效果：\n![](https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E7%AC%94%E8%AE%B0/%E6%A0%87%E7%AD%BE%E6%95%88%E6%9E%9C.gif?raw=true)\n完整代码在[这里](https://github.com/hGhostD/HUTagsView)\n\n<br>\n<br>\n> 参考资料\n> [SDTagsView1.0](https://github.com/SlowDony/SDTagsView)","slug":"Swift实现可编辑标签页","published":1,"updated":"2018-05-16T08:57:35.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfy9y000j7sn6d5zfe9wp","content":"<p>工作中遇到一个需要自定义的标签页，在网上找到了一个比较合适的 demo，可惜是以 Objective-C 实现的。就正好自己再用 swift 重写一下，也学习一下别人的思路。</p>\n<!---- more ---->\n<h4 id=\"SDTagsView\"><a href=\"#SDTagsView\" class=\"headerlink\" title=\"SDTagsView\"></a>SDTagsView</h4><p><a href=\"https://github.com/SlowDony/SDTagsView\">这里</a> 是原作者的 demo，他分别采用了 Label 和 CollectionView 两种实现方式。不过作者比较推荐第二种，我也只以 CollectionView 的方式实现。<br><img src=\"https://github.com/SlowDony/SDTagsView/blob/master/SDTagsView/SDEditTagsView.gif?raw=true\" alt=\"SDTagsView\"></p>\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><p>因为我们这个 UI 控件可能需要在任意的 UIViewcontroller 中点击出现。所以我采用将这个控件同样以一个 UIViewcontroller 为承载。在需要的时候调用 present 弹出即可。目录结构如下:<br><img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E7%AC%94%E8%AE%B0/%E6%A0%87%E7%AD%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png?raw=true\"></p>\n<h4 id=\"实现-HUEditTagsViewController\"><a href=\"#实现-HUEditTagsViewController\" class=\"headerlink\" title=\"实现 HUEditTagsViewController\"></a>实现 HUEditTagsViewController</h4><p>TagsViewController 作为一个 Controller，是放置 view 和相关数据的基本控件。我们需要在此定义好数据源和相关的 view。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myTagsArr: [<span class=\"keyword\">String</span>] = []</span><br><span class=\"line\">    <span class=\"keyword\">var</span> moreTagsArr: [<span class=\"keyword\">String</span>] = []</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> dataArr: [[<span class=\"keyword\">String</span>]] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">self</span>.myTagsArr, <span class=\"built_in\">self</span>.moreTagsArr]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    typealias tagsBlock = ([<span class=\"keyword\">String</span>], [<span class=\"keyword\">String</span>]) -&gt; <span class=\"keyword\">Void</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> saveBlock: tagsBlock?</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> tagsView : HUCollectionTagsView?</span><br></pre></td></tr></table></figure>\n<p>定义好必要的属性后，在 viewDidLoad 方法中做好相关的设置就可以了。这里我定义了3个数组，第一个数组放置我的标签内容，第二个数组放置更多标签的内容，第三个数组只有 get 方法，是将前两个数组放置到一起，传递给 view 作为数据源使用。</p>\n<h4 id=\"实现-HUCollectionTagsView\"><a href=\"#实现-HUCollectionTagsView\" class=\"headerlink\" title=\"实现 HUCollectionTagsView\"></a>实现 HUCollectionTagsView</h4><p>这个作为一个 collectionview，实现它并不复杂。需要注意的是，我们这个 collectionview 实现头部view，也同样需要注册 header 的 cellIdefntifier，否则会造成崩溃。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.register(<span class=\"type\">UICollectionReusableView</span>.<span class=\"keyword\">self</span>, forSupplementaryViewOfKind: <span class=\"type\">UICollectionElementKindSectionHeader</span>, withReuseIdentifier: cellHeaderIdentifier)</span><br></pre></td></tr></table></figure>\n<p>。需要在初始化的时候注册，和 cell 一样。</p>\n<h4 id=\"实现-HUCollectViewCell-和-HUCollectionTagsFlowLayout\"><a href=\"#实现-HUCollectViewCell-和-HUCollectionTagsFlowLayout\" class=\"headerlink\" title=\"实现 HUCollectViewCell 和 HUCollectionTagsFlowLayout\"></a>实现 HUCollectViewCell 和 HUCollectionTagsFlowLayout</h4><p>这两个配置文件是对 collectionview 的具体必要配置，可以按照自己的需求进行自定义。</p>\n<h4 id=\"点击移动-item\"><a href=\"#点击移动-item\" class=\"headerlink\" title=\"点击移动 item\"></a>点击移动 item</h4><p>至此，整体的结构已经实现完成，最后要实现一些点击事件的交互逻辑就可以完成。</p>\n<p>由于点击事件的代理方法是绑定在 view 中的，但是我们想要点击时对 Controller 中的数据进行修改，就需要将事件传递出去。实现方式有很多，可以使用代理、block等。这里我们采用代理方式，需要自定义一个协议。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">HUCollectionTagsViewDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionTagsView</span>(<span class=\"params\">collectionView</span>: <span class=\"type\">UICollectionView</span>, <span class=\"params\">didSelectItemAt</span> <span class=\"params\">indexPath</span>: <span class=\"type\">IndexPath</span>)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/// HUCollectionTagsView </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hu_delegate: <span class=\"type\">HUCollectionTagsViewDelegate</span>?</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span>(<span class=\"keyword\">_</span> <span class=\"params\">collectionView</span>: <span class=\"type\">UICollectionView</span>, <span class=\"params\">didSelectItemAt</span> <span class=\"params\">indexPath</span>: <span class=\"type\">IndexPath</span>)</span> &#123;</span><br><span class=\"line\">true<span class=\"keyword\">self</span>.hu_delegate<span class=\"operator\">?</span>.collectionTagsView(collectionView: <span class=\"keyword\">self</span>, didSelectItemAt: indexPath)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个协议只有一个必要实现的方法，就是响应点击具体的 item。<br>再由 HUEditTagsViewController 来实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionTagsView</span>(<span class=\"params\">collectionView</span>: <span class=\"type\">UICollectionView</span>, <span class=\"params\">didSelectItemAt</span> <span class=\"params\">indexPath</span>: <span class=\"type\">IndexPath</span>)</span> &#123;</span><br><span class=\"line\">truetrue<span class=\"comment\">/// 处理点击 改变数据内容</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>做的时候觉得数据的传递绑定处理的不太完善，但是一直也没想到更好的处理办法，还需要进行优化，如果后面想到了，再来修改吧。<br>最后实现效果：<br><img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E7%AC%94%E8%AE%B0/%E6%A0%87%E7%AD%BE%E6%95%88%E6%9E%9C.gif?raw=true\"><br>完整代码在<a href=\"https://github.com/hGhostD/HUTagsView\">这里</a></p>\n<br>\n<br>\n> 参考资料\n> [SDTagsView1.0](https://github.com/SlowDony/SDTagsView)","site":{"data":{}},"excerpt":"","more":"<p>工作中遇到一个需要自定义的标签页，在网上找到了一个比较合适的 demo，可惜是以 Objective-C 实现的。就正好自己再用 swift 重写一下，也学习一下别人的思路。</p>\n<!---- more ---->\n<h4 id=\"SDTagsView\"><a href=\"#SDTagsView\" class=\"headerlink\" title=\"SDTagsView\"></a>SDTagsView</h4><p><a href=\"https://github.com/SlowDony/SDTagsView\">这里</a> 是原作者的 demo，他分别采用了 Label 和 CollectionView 两种实现方式。不过作者比较推荐第二种，我也只以 CollectionView 的方式实现。<br><img src=\"https://github.com/SlowDony/SDTagsView/blob/master/SDTagsView/SDEditTagsView.gif?raw=true\" alt=\"SDTagsView\"></p>\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><p>因为我们这个 UI 控件可能需要在任意的 UIViewcontroller 中点击出现。所以我采用将这个控件同样以一个 UIViewcontroller 为承载。在需要的时候调用 present 弹出即可。目录结构如下:<br><img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E7%AC%94%E8%AE%B0/%E6%A0%87%E7%AD%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png?raw=true\"></p>\n<h4 id=\"实现-HUEditTagsViewController\"><a href=\"#实现-HUEditTagsViewController\" class=\"headerlink\" title=\"实现 HUEditTagsViewController\"></a>实现 HUEditTagsViewController</h4><p>TagsViewController 作为一个 Controller，是放置 view 和相关数据的基本控件。我们需要在此定义好数据源和相关的 view。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myTagsArr: [<span class=\"keyword\">String</span>] = []</span><br><span class=\"line\">    <span class=\"keyword\">var</span> moreTagsArr: [<span class=\"keyword\">String</span>] = []</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> dataArr: [[<span class=\"keyword\">String</span>]] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">self</span>.myTagsArr, <span class=\"built_in\">self</span>.moreTagsArr]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    typealias tagsBlock = ([<span class=\"keyword\">String</span>], [<span class=\"keyword\">String</span>]) -&gt; <span class=\"keyword\">Void</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> saveBlock: tagsBlock?</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> tagsView : HUCollectionTagsView?</span><br></pre></td></tr></table></figure>\n<p>定义好必要的属性后，在 viewDidLoad 方法中做好相关的设置就可以了。这里我定义了3个数组，第一个数组放置我的标签内容，第二个数组放置更多标签的内容，第三个数组只有 get 方法，是将前两个数组放置到一起，传递给 view 作为数据源使用。</p>\n<h4 id=\"实现-HUCollectionTagsView\"><a href=\"#实现-HUCollectionTagsView\" class=\"headerlink\" title=\"实现 HUCollectionTagsView\"></a>实现 HUCollectionTagsView</h4><p>这个作为一个 collectionview，实现它并不复杂。需要注意的是，我们这个 collectionview 实现头部view，也同样需要注册 header 的 cellIdefntifier，否则会造成崩溃。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.register(<span class=\"type\">UICollectionReusableView</span>.<span class=\"keyword\">self</span>, forSupplementaryViewOfKind: <span class=\"type\">UICollectionElementKindSectionHeader</span>, withReuseIdentifier: cellHeaderIdentifier)</span><br></pre></td></tr></table></figure>\n<p>。需要在初始化的时候注册，和 cell 一样。</p>\n<h4 id=\"实现-HUCollectViewCell-和-HUCollectionTagsFlowLayout\"><a href=\"#实现-HUCollectViewCell-和-HUCollectionTagsFlowLayout\" class=\"headerlink\" title=\"实现 HUCollectViewCell 和 HUCollectionTagsFlowLayout\"></a>实现 HUCollectViewCell 和 HUCollectionTagsFlowLayout</h4><p>这两个配置文件是对 collectionview 的具体必要配置，可以按照自己的需求进行自定义。</p>\n<h4 id=\"点击移动-item\"><a href=\"#点击移动-item\" class=\"headerlink\" title=\"点击移动 item\"></a>点击移动 item</h4><p>至此，整体的结构已经实现完成，最后要实现一些点击事件的交互逻辑就可以完成。</p>\n<p>由于点击事件的代理方法是绑定在 view 中的，但是我们想要点击时对 Controller 中的数据进行修改，就需要将事件传递出去。实现方式有很多，可以使用代理、block等。这里我们采用代理方式，需要自定义一个协议。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">HUCollectionTagsViewDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionTagsView</span>(<span class=\"params\">collectionView</span>: <span class=\"type\">UICollectionView</span>, <span class=\"params\">didSelectItemAt</span> <span class=\"params\">indexPath</span>: <span class=\"type\">IndexPath</span>)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/// HUCollectionTagsView </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hu_delegate: <span class=\"type\">HUCollectionTagsViewDelegate</span>?</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionView</span>(<span class=\"keyword\">_</span> <span class=\"params\">collectionView</span>: <span class=\"type\">UICollectionView</span>, <span class=\"params\">didSelectItemAt</span> <span class=\"params\">indexPath</span>: <span class=\"type\">IndexPath</span>)</span> &#123;</span><br><span class=\"line\">true<span class=\"keyword\">self</span>.hu_delegate<span class=\"operator\">?</span>.collectionTagsView(collectionView: <span class=\"keyword\">self</span>, didSelectItemAt: indexPath)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个协议只有一个必要实现的方法，就是响应点击具体的 item。<br>再由 HUEditTagsViewController 来实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectionTagsView</span>(<span class=\"params\">collectionView</span>: <span class=\"type\">UICollectionView</span>, <span class=\"params\">didSelectItemAt</span> <span class=\"params\">indexPath</span>: <span class=\"type\">IndexPath</span>)</span> &#123;</span><br><span class=\"line\">truetrue<span class=\"comment\">/// 处理点击 改变数据内容</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>做的时候觉得数据的传递绑定处理的不太完善，但是一直也没想到更好的处理办法，还需要进行优化，如果后面想到了，再来修改吧。<br>最后实现效果：<br><img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E7%AC%94%E8%AE%B0/%E6%A0%87%E7%AD%BE%E6%95%88%E6%9E%9C.gif?raw=true\"><br>完整代码在<a href=\"https://github.com/hGhostD/HUTagsView\">这里</a></p>\n<br>\n<br>\n> 参考资料\n> [SDTagsView1.0](https://github.com/SlowDony/SDTagsView)"},{"layout":"swift","title":"Swift的正则表达式","date":"2017-11-03T07:36:21.000Z","_content":"有的时候会遇到了需要自定义正则来判断输入信息  \n<!--- more --->\n\n```\nextension String {\n    func regularExpressions() -> Bool {\n        if self.isEmpty {\n            return false\n        }\n        //简单判断邮箱或者是手机号\n        let photoReges = \"^([A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,4})\n        ||1[0-9]{10}$\"\n        \n        let test = NSPredicate(format: \"SELF MATCHES %@\", photoReges)\n        return test.evaluate(with: self)\n    }\n}\n```\n这里为了省事，直接给 String 添加了拓展方法。以后可以根据需求添加正则规则。\n<br>\n>参考资料\n>[Swift 正则表达式规则](http://www.jianshu.com/p/d569dc998073)","source":"_posts/Swift的正则表达式.md","raw":"---\nlayout: swift\ntitle: Swift的正则表达式\ndate: 2017-11-03 15:36:21\ntags: \n- Swift\ncategories: \n- Swift\n---\n有的时候会遇到了需要自定义正则来判断输入信息  \n<!--- more --->\n\n```\nextension String {\n    func regularExpressions() -> Bool {\n        if self.isEmpty {\n            return false\n        }\n        //简单判断邮箱或者是手机号\n        let photoReges = \"^([A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,4})\n        ||1[0-9]{10}$\"\n        \n        let test = NSPredicate(format: \"SELF MATCHES %@\", photoReges)\n        return test.evaluate(with: self)\n    }\n}\n```\n这里为了省事，直接给 String 添加了拓展方法。以后可以根据需求添加正则规则。\n<br>\n>参考资料\n>[Swift 正则表达式规则](http://www.jianshu.com/p/d569dc998073)","slug":"Swift的正则表达式","published":1,"updated":"2017-11-08T09:32:57.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfya1000l7sn6fwziegu8","content":"<p>有的时候会遇到了需要自定义正则来判断输入信息  </p>\n<!--- more --->\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">regularExpressions</span>()</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.isEmpty &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//简单判断邮箱或者是手机号</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> photoReges <span class=\"operator\">=</span> <span class=\"string\">&quot;^([A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+<span class=\"subst\">\\\\</span>.[A-Za-z]&#123;2,4&#125;)</span></span><br><span class=\"line\"><span class=\"string\">        ||1[0-9]&#123;10&#125;$&quot;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> test <span class=\"operator\">=</span> <span class=\"type\">NSPredicate</span>(format: <span class=\"string\">&quot;SELF MATCHES %@&quot;</span>, photoReges)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> test.evaluate(with: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里为了省事，直接给 String 添加了拓展方法。以后可以根据需求添加正则规则。<br><br></p>\n<blockquote>\n<p>参考资料<br><a href=\"http://www.jianshu.com/p/d569dc998073\">Swift 正则表达式规则</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>有的时候会遇到了需要自定义正则来判断输入信息  </p>\n<!--- more --->\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">regularExpressions</span>()</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.isEmpty &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//简单判断邮箱或者是手机号</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> photoReges <span class=\"operator\">=</span> <span class=\"string\">&quot;^([A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+<span class=\"subst\">\\\\</span>.[A-Za-z]&#123;2,4&#125;)</span></span><br><span class=\"line\"><span class=\"string\">        ||1[0-9]&#123;10&#125;$&quot;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> test <span class=\"operator\">=</span> <span class=\"type\">NSPredicate</span>(format: <span class=\"string\">&quot;SELF MATCHES %@&quot;</span>, photoReges)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> test.evaluate(with: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里为了省事，直接给 String 添加了拓展方法。以后可以根据需求添加正则规则。<br><br></p>\n<blockquote>\n<p>参考资料<br><a href=\"http://www.jianshu.com/p/d569dc998073\">Swift 正则表达式规则</a></p>\n</blockquote>\n"},{"layout":"日记","title":"Vim使用技巧笔记","date":"2017-11-07T06:44:14.000Z","_content":"边学习 Vim 技巧 边做笔记 学到一点就记录一点\n<!--- more --->\n从今天开始练习使用Vim，从最开始开始。\n- 查询： 可以在 Vi 模式下直接使用 `:h ctrl-w` 查询 `<C-w>` 的用法。\n- 输出： :echo 指令。\n\n        Vim中的printf。 :echo \"Hello,world!\" \n- 持久化消息， 使用 `:echom \"Hello again,World!\"` 指令，然后使用 `:messages` 。能够再次看到 echom打印 \"Hello again,World!\" 的指令\n\n - 基本映射 `:map \\ dd` 使用 '\\' 指令代表 `dd` (删除行)  \n- 缩写 可以快捷输入一些类内容\n\n        :iabbrev hu Copyright 2011 Steve Losh\n---\n- 插入模式映射设置  `:inoremap jk <esc>`  在插入模式下按jk退出插入模式\n- `J` (大写) 讲两行拼接成一行\n- 多行注释 `Ctrl+v, 选中行，I（大写I）, #, ESC`\n\n---\n- `f` `F` 移动光标到当前行的字母 例如 `fc` 移动到光标后面第一个 c 字母上。`Fc` 移动到光标前第一个 c 字母。\n\t使用 `;` 查找本行下一个符合的字符 例如 `;` 跳转到下一个 c 字母上。使用 `,` 向前查找。\n- `t` `T` 类似 `f` `F` 。差别是移动到字母前一个位置\n\n---\n- `\\` 或者 `?` 查找 例如 `\\error` `?error` 查找全文的error\n按 `n` 向后查找匹配项 按 `N` 向前查找匹配项\n- `CTRL-O` 光标跳转到上一个查找对象处 `CTRL-I` 光标跳转到下一个查找处\n- 通过 `:set ic` 来忽略大小写 通过 `:set noic` 来分辨大小写 如果仅在第一次搜索时忽略大小写 直接在 搜索内容后添加 `\\c` 例如: `\\error\\c`\n- 设置搜索高亮 `:set hls is`  注: 取消搜索高亮 `:nohlsearch`\n\n---\n今天终于在xcode 9 上安装了 [XVim](https://github.com/XVimProject/XVim2) 了！！！\n- `sp` 或 `Ctrl+w s` 水平分割窗口\n- `vs` 或 `Ctrl+w v` 垂直分割窗口\n- `Ctrl+w q` 关闭当前窗口\n- `Ctrl+w o` 关闭除当前串口外的所有窗口\n- `Ctrl+w w` 遍历切换窗口\n\n---\n- `#` 匹配单词 寻找下一个相同的单词。\n- `di\"` 删除 \" 之间的内容。\n\n---\n- `>G` 使当前行到文档末尾处增加一个缩进，可以使用 `.` 继续重复命令。\n- `s` 替换当前单词 == `cl`。\n- `S` == `C` 删除整行 并重新输入。\n\n---\n- `:%s/\\.o/\\.c/g` 将 .o 替换为 .c。 `%` 表示所有行，`g` 表示全部替换\n  `:s/aaa/bbb` 只替换第一行的第一个。`1,12s/aaa/bbb/g` 替换1到12行所有的。\n- `daw` `diw` 可以更快向前删除一个单词 `aw` 比 `iw` 多删除空格。 \n- `dab` `dib` 删除小括号内中的内容. `ab`  比 `ib` 多删除括号。等于 `da(` `di(`,类似还有 `daB` `diB` 等于 `da{` `di{` 删除大括号内容。\n- `dit` `dat` 删除匹配标签栏中的内容。如 <a color=#00ff00>title</a>,输入 `dit` 会删除 title，删除掉标签中的内容。\n- `<C-a>` `<C-x>` 把当前数字加一或减一。Tips: 如果是对 007 使用 `<C-a>` 将会得到结果为 010，是因为 vim 认为 007 是8进制，在 .vimrc 中设置 `set nrformats=` 会转为十进制。\n\n---\n- <font color=#0089ff>蓝色代表插入模式下指令</font>。\n- <font color=#0089ff>\u000eCtrl+w</font> 删除一个单词。\n- <font color=#0089ff>\u000eCtrl+u</font> 删除至行首。\n- `yt,` 复制光标到 \",\" 之间所有的内容。<font color=#0089ff>Ctrl+r0</font> 在光标位置粘贴复制内容。yt 的意思是复制内容到专用寄存器中，所以 Ctrl+r0 表示取出第0个内容。\n- <font color=#0089ff>Ctrl+r=</font> 使用运算功能。例如 计算 6 \\* 35:在插入模式输入 `<C+r>=6*35`。直接获得结果210。\n\n---\n- <font color=#008900>绿色代表可视模式下指令</font>。\n- `gv` 重选上次高亮选区。\n- <font color=#008900>**o**</font> 切换高亮选区活动端。\n- <font color=#008900>**u U**</font> 对选中单词进行小写/大写切换。\n\n---\n`:[range] delete [x]` 删除指定范围内的行[到寄存器 x 中]。\n`\"[x]p` 粘贴寄存器 x 中的内容，例如粘贴寄存器 2 中的内容：`\"2p`。\n`:reg` 查看寄存器内容。\n`@:` 重复上一条命令。\n`:!` 执行 Shell 中的程序，例如：`:!ls`。\n\n---\n`<C+o>` 类似网页后退，后退到上一个打开的文本。对应的还有 `<C+i>` 前进。\n`:jumps` 打开历史文件列表。\n\n---\n`m{a-zA-z}` 把位置标记 {a-zA-Z} 设在当前光标位置 (不移动光标，这不是动作命令)。\n`'{mark}` 跳转到标记行首。 \\`\\` 跳转到上次光标位置。\n``{mark}` 跳转到标记处。 \n\n---\n`qa` (需要记录的指令) `q` 使用 `q` + 寄存器位置来记录宏操作，最后以 `q` 指令结尾。\n`@a` 执行寄存器(a)中指令。 `:reg` 查看寄存器中所有的内容。\n`~` 大小写转换，并使光标跳转到下一个字符。\n\n---\n`q/` 查看历史指令。\n\n--- \n`<C+]>` 跳转光标到关键字的定义处。 \n`<C+n>`  和 `<C+p>` 可以激活自动补全功能。\n`<C+x>` `<C+l>` 组合使用可以补全本行内容。\n`:set spell` 检查拼写错误。 通过 `[s` 和 `]s` 命令在拼写错误间进行跳转。还可以通过 `z=` 命令获取建议列表。\n\n--- \n`ZZ` 快速退出并保存。\n`dfi` 从光标处删除至i(包括i), `dti` 从光标处删除至i(不包括i)。\n\n---\n有的时候需要在单词左右添加引号括号之类的，需要在 .vimrc 中添加定义\n\n```\nfunction! s:surround()\n    let word = expand(\"<cword>\")\n    let wrap= input(\"wrap with: \")\n    let command = \"s/\".word.\"/\".wrap.word.wrap.\"/\"\n    execute command\nendfunction\nnmap cx :call <SID>surround()<CR>\n```\n\n这样在 nomal 模式下使用 `cx` + `\"` 就能在单词左右添加引号。","source":"_posts/Vim使用技巧笔记.md","raw":"---\nlayout: 日记\ntitle: Vim使用技巧笔记\ndate: 2017-11-07 14:44:14\ntags:\n- 日记\n- Vim\ncategories:\n- 日记\n\n---\n边学习 Vim 技巧 边做笔记 学到一点就记录一点\n<!--- more --->\n从今天开始练习使用Vim，从最开始开始。\n- 查询： 可以在 Vi 模式下直接使用 `:h ctrl-w` 查询 `<C-w>` 的用法。\n- 输出： :echo 指令。\n\n        Vim中的printf。 :echo \"Hello,world!\" \n- 持久化消息， 使用 `:echom \"Hello again,World!\"` 指令，然后使用 `:messages` 。能够再次看到 echom打印 \"Hello again,World!\" 的指令\n\n - 基本映射 `:map \\ dd` 使用 '\\' 指令代表 `dd` (删除行)  \n- 缩写 可以快捷输入一些类内容\n\n        :iabbrev hu Copyright 2011 Steve Losh\n---\n- 插入模式映射设置  `:inoremap jk <esc>`  在插入模式下按jk退出插入模式\n- `J` (大写) 讲两行拼接成一行\n- 多行注释 `Ctrl+v, 选中行，I（大写I）, #, ESC`\n\n---\n- `f` `F` 移动光标到当前行的字母 例如 `fc` 移动到光标后面第一个 c 字母上。`Fc` 移动到光标前第一个 c 字母。\n\t使用 `;` 查找本行下一个符合的字符 例如 `;` 跳转到下一个 c 字母上。使用 `,` 向前查找。\n- `t` `T` 类似 `f` `F` 。差别是移动到字母前一个位置\n\n---\n- `\\` 或者 `?` 查找 例如 `\\error` `?error` 查找全文的error\n按 `n` 向后查找匹配项 按 `N` 向前查找匹配项\n- `CTRL-O` 光标跳转到上一个查找对象处 `CTRL-I` 光标跳转到下一个查找处\n- 通过 `:set ic` 来忽略大小写 通过 `:set noic` 来分辨大小写 如果仅在第一次搜索时忽略大小写 直接在 搜索内容后添加 `\\c` 例如: `\\error\\c`\n- 设置搜索高亮 `:set hls is`  注: 取消搜索高亮 `:nohlsearch`\n\n---\n今天终于在xcode 9 上安装了 [XVim](https://github.com/XVimProject/XVim2) 了！！！\n- `sp` 或 `Ctrl+w s` 水平分割窗口\n- `vs` 或 `Ctrl+w v` 垂直分割窗口\n- `Ctrl+w q` 关闭当前窗口\n- `Ctrl+w o` 关闭除当前串口外的所有窗口\n- `Ctrl+w w` 遍历切换窗口\n\n---\n- `#` 匹配单词 寻找下一个相同的单词。\n- `di\"` 删除 \" 之间的内容。\n\n---\n- `>G` 使当前行到文档末尾处增加一个缩进，可以使用 `.` 继续重复命令。\n- `s` 替换当前单词 == `cl`。\n- `S` == `C` 删除整行 并重新输入。\n\n---\n- `:%s/\\.o/\\.c/g` 将 .o 替换为 .c。 `%` 表示所有行，`g` 表示全部替换\n  `:s/aaa/bbb` 只替换第一行的第一个。`1,12s/aaa/bbb/g` 替换1到12行所有的。\n- `daw` `diw` 可以更快向前删除一个单词 `aw` 比 `iw` 多删除空格。 \n- `dab` `dib` 删除小括号内中的内容. `ab`  比 `ib` 多删除括号。等于 `da(` `di(`,类似还有 `daB` `diB` 等于 `da{` `di{` 删除大括号内容。\n- `dit` `dat` 删除匹配标签栏中的内容。如 <a color=#00ff00>title</a>,输入 `dit` 会删除 title，删除掉标签中的内容。\n- `<C-a>` `<C-x>` 把当前数字加一或减一。Tips: 如果是对 007 使用 `<C-a>` 将会得到结果为 010，是因为 vim 认为 007 是8进制，在 .vimrc 中设置 `set nrformats=` 会转为十进制。\n\n---\n- <font color=#0089ff>蓝色代表插入模式下指令</font>。\n- <font color=#0089ff>\u000eCtrl+w</font> 删除一个单词。\n- <font color=#0089ff>\u000eCtrl+u</font> 删除至行首。\n- `yt,` 复制光标到 \",\" 之间所有的内容。<font color=#0089ff>Ctrl+r0</font> 在光标位置粘贴复制内容。yt 的意思是复制内容到专用寄存器中，所以 Ctrl+r0 表示取出第0个内容。\n- <font color=#0089ff>Ctrl+r=</font> 使用运算功能。例如 计算 6 \\* 35:在插入模式输入 `<C+r>=6*35`。直接获得结果210。\n\n---\n- <font color=#008900>绿色代表可视模式下指令</font>。\n- `gv` 重选上次高亮选区。\n- <font color=#008900>**o**</font> 切换高亮选区活动端。\n- <font color=#008900>**u U**</font> 对选中单词进行小写/大写切换。\n\n---\n`:[range] delete [x]` 删除指定范围内的行[到寄存器 x 中]。\n`\"[x]p` 粘贴寄存器 x 中的内容，例如粘贴寄存器 2 中的内容：`\"2p`。\n`:reg` 查看寄存器内容。\n`@:` 重复上一条命令。\n`:!` 执行 Shell 中的程序，例如：`:!ls`。\n\n---\n`<C+o>` 类似网页后退，后退到上一个打开的文本。对应的还有 `<C+i>` 前进。\n`:jumps` 打开历史文件列表。\n\n---\n`m{a-zA-z}` 把位置标记 {a-zA-Z} 设在当前光标位置 (不移动光标，这不是动作命令)。\n`'{mark}` 跳转到标记行首。 \\`\\` 跳转到上次光标位置。\n``{mark}` 跳转到标记处。 \n\n---\n`qa` (需要记录的指令) `q` 使用 `q` + 寄存器位置来记录宏操作，最后以 `q` 指令结尾。\n`@a` 执行寄存器(a)中指令。 `:reg` 查看寄存器中所有的内容。\n`~` 大小写转换，并使光标跳转到下一个字符。\n\n---\n`q/` 查看历史指令。\n\n--- \n`<C+]>` 跳转光标到关键字的定义处。 \n`<C+n>`  和 `<C+p>` 可以激活自动补全功能。\n`<C+x>` `<C+l>` 组合使用可以补全本行内容。\n`:set spell` 检查拼写错误。 通过 `[s` 和 `]s` 命令在拼写错误间进行跳转。还可以通过 `z=` 命令获取建议列表。\n\n--- \n`ZZ` 快速退出并保存。\n`dfi` 从光标处删除至i(包括i), `dti` 从光标处删除至i(不包括i)。\n\n---\n有的时候需要在单词左右添加引号括号之类的，需要在 .vimrc 中添加定义\n\n```\nfunction! s:surround()\n    let word = expand(\"<cword>\")\n    let wrap= input(\"wrap with: \")\n    let command = \"s/\".word.\"/\".wrap.word.wrap.\"/\"\n    execute command\nendfunction\nnmap cx :call <SID>surround()<CR>\n```\n\n这样在 nomal 模式下使用 `cx` + `\"` 就能在单词左右添加引号。","slug":"Vim使用技巧笔记","published":1,"updated":"2018-06-08T08:46:33.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfya5000q7sn6587938hl","content":"<p>边学习 Vim 技巧 边做笔记 学到一点就记录一点</p>\n<!--- more --->\n<p>从今天开始练习使用Vim，从最开始开始。</p>\n<ul>\n<li><p>查询： 可以在 Vi 模式下直接使用 <code>:h ctrl-w</code> 查询 <code>&lt;C-w&gt;</code> 的用法。</p>\n</li>\n<li><p>输出： :echo 指令。</p>\n<pre><code>  Vim中的printf。 :echo &quot;Hello,world!&quot; \n</code></pre>\n</li>\n<li><p>持久化消息， 使用 <code>:echom &quot;Hello again,World!&quot;</code> 指令，然后使用 <code>:messages</code> 。能够再次看到 echom打印 “Hello again,World!” 的指令</p>\n</li>\n<li><p>基本映射 <code>:map \\ dd</code> 使用 ‘&#39; 指令代表 <code>dd</code> (删除行)  </p>\n</li>\n<li><p>缩写 可以快捷输入一些类内容</p>\n<pre><code>  :iabbrev hu Copyright 2011 Steve Losh\n</code></pre>\n</li>\n</ul>\n<hr>\n<ul>\n<li>插入模式映射设置  <code>:inoremap jk &lt;esc&gt;</code>  在插入模式下按jk退出插入模式</li>\n<li><code>J</code> (大写) 讲两行拼接成一行</li>\n<li>多行注释 <code>Ctrl+v, 选中行，I（大写I）, #, ESC</code></li>\n</ul>\n<hr>\n<ul>\n<li><code>f</code> <code>F</code> 移动光标到当前行的字母 例如 <code>fc</code> 移动到光标后面第一个 c 字母上。<code>Fc</code> 移动到光标前第一个 c 字母。<br>  使用 <code>;</code> 查找本行下一个符合的字符 例如 <code>;</code> 跳转到下一个 c 字母上。使用 <code>,</code> 向前查找。</li>\n<li><code>t</code> <code>T</code> 类似 <code>f</code> <code>F</code> 。差别是移动到字母前一个位置</li>\n</ul>\n<hr>\n<ul>\n<li><code>\\</code> 或者 <code>?</code> 查找 例如 <code>\\error</code> <code>?error</code> 查找全文的error<br>按 <code>n</code> 向后查找匹配项 按 <code>N</code> 向前查找匹配项</li>\n<li><code>CTRL-O</code> 光标跳转到上一个查找对象处 <code>CTRL-I</code> 光标跳转到下一个查找处</li>\n<li>通过 <code>:set ic</code> 来忽略大小写 通过 <code>:set noic</code> 来分辨大小写 如果仅在第一次搜索时忽略大小写 直接在 搜索内容后添加 <code>\\c</code> 例如: <code>\\error\\c</code></li>\n<li>设置搜索高亮 <code>:set hls is</code>  注: 取消搜索高亮 <code>:nohlsearch</code></li>\n</ul>\n<hr>\n<p>今天终于在xcode 9 上安装了 <a href=\"https://github.com/XVimProject/XVim2\">XVim</a> 了！！！</p>\n<ul>\n<li><code>sp</code> 或 <code>Ctrl+w s</code> 水平分割窗口</li>\n<li><code>vs</code> 或 <code>Ctrl+w v</code> 垂直分割窗口</li>\n<li><code>Ctrl+w q</code> 关闭当前窗口</li>\n<li><code>Ctrl+w o</code> 关闭除当前串口外的所有窗口</li>\n<li><code>Ctrl+w w</code> 遍历切换窗口</li>\n</ul>\n<hr>\n<ul>\n<li><code>#</code> 匹配单词 寻找下一个相同的单词。</li>\n<li><code>di&quot;</code> 删除 “ 之间的内容。</li>\n</ul>\n<hr>\n<ul>\n<li><code>&gt;G</code> 使当前行到文档末尾处增加一个缩进，可以使用 <code>.</code> 继续重复命令。</li>\n<li><code>s</code> 替换当前单词 == <code>cl</code>。</li>\n<li><code>S</code> == <code>C</code> 删除整行 并重新输入。</li>\n</ul>\n<hr>\n<ul>\n<li><code>:%s/\\.o/\\.c/g</code> 将 .o 替换为 .c。 <code>%</code> 表示所有行，<code>g</code> 表示全部替换<br><code>:s/aaa/bbb</code> 只替换第一行的第一个。<code>1,12s/aaa/bbb/g</code> 替换1到12行所有的。</li>\n<li><code>daw</code> <code>diw</code> 可以更快向前删除一个单词 <code>aw</code> 比 <code>iw</code> 多删除空格。 </li>\n<li><code>dab</code> <code>dib</code> 删除小括号内中的内容. <code>ab</code>  比 <code>ib</code> 多删除括号。等于 <code>da(</code> <code>di(</code>,类似还有 <code>daB</code> <code>diB</code> 等于 <code>da&#123;</code> <code>di&#123;</code> 删除大括号内容。</li>\n<li><code>dit</code> <code>dat</code> 删除匹配标签栏中的内容。如 <a color=#00ff00>title</a>,输入 <code>dit</code> 会删除 title，删除掉标签中的内容。</li>\n<li><code>&lt;C-a&gt;</code> <code>&lt;C-x&gt;</code> 把当前数字加一或减一。Tips: 如果是对 007 使用 <code>&lt;C-a&gt;</code> 将会得到结果为 010，是因为 vim 认为 007 是8进制，在 .vimrc 中设置 <code>set nrformats=</code> 会转为十进制。</li>\n</ul>\n<hr>\n<ul>\n<li><font color=#0089ff>蓝色代表插入模式下指令</font>。</li>\n<li><font color=#0089ff>\u000eCtrl+w</font> 删除一个单词。</li>\n<li><font color=#0089ff>\u000eCtrl+u</font> 删除至行首。</li>\n<li><code>yt,</code> 复制光标到 “,” 之间所有的内容。<font color=#0089ff>Ctrl+r0</font> 在光标位置粘贴复制内容。yt 的意思是复制内容到专用寄存器中，所以 Ctrl+r0 表示取出第0个内容。</li>\n<li><font color=#0089ff>Ctrl+r=</font> 使用运算功能。例如 计算 6 * 35:在插入模式输入 <code>&lt;C+r&gt;=6*35</code>。直接获得结果210。</li>\n</ul>\n<hr>\n<ul>\n<li><font color=#008900>绿色代表可视模式下指令</font>。</li>\n<li><code>gv</code> 重选上次高亮选区。</li>\n<li><font color=#008900><strong>o</strong></font> 切换高亮选区活动端。</li>\n<li><font color=#008900><strong>u U</strong></font> 对选中单词进行小写/大写切换。</li>\n</ul>\n<hr>\n<p><code>:[range] delete [x]</code> 删除指定范围内的行[到寄存器 x 中]。<br><code>&quot;[x]p</code> 粘贴寄存器 x 中的内容，例如粘贴寄存器 2 中的内容：<code>&quot;2p</code>。<br><code>:reg</code> 查看寄存器内容。<br><code>@:</code> 重复上一条命令。<br><code>:!</code> 执行 Shell 中的程序，例如：<code>:!ls</code>。</p>\n<hr>\n<p><code>&lt;C+o&gt;</code> 类似网页后退，后退到上一个打开的文本。对应的还有 <code>&lt;C+i&gt;</code> 前进。<br><code>:jumps</code> 打开历史文件列表。</p>\n<hr>\n<p><code>m&#123;a-zA-z&#125;</code> 把位置标记 {a-zA-Z} 设在当前光标位置 (不移动光标，这不是动作命令)。<br><code>&#39;&#123;mark&#125;</code> 跳转到标记行首。 `` 跳转到上次光标位置。<br>``{mark}` 跳转到标记处。 </p>\n<hr>\n<p><code>qa</code> (需要记录的指令) <code>q</code> 使用 <code>q</code> + 寄存器位置来记录宏操作，最后以 <code>q</code> 指令结尾。<br><code>@a</code> 执行寄存器(a)中指令。 <code>:reg</code> 查看寄存器中所有的内容。<br><code>~</code> 大小写转换，并使光标跳转到下一个字符。</p>\n<hr>\n<p><code>q/</code> 查看历史指令。</p>\n<hr>\n<p><code>&lt;C+]&gt;</code> 跳转光标到关键字的定义处。<br><code>&lt;C+n&gt;</code>  和 <code>&lt;C+p&gt;</code> 可以激活自动补全功能。<br><code>&lt;C+x&gt;</code> <code>&lt;C+l&gt;</code> 组合使用可以补全本行内容。<br><code>:set spell</code> 检查拼写错误。 通过 <code>[s</code> 和 <code>]s</code> 命令在拼写错误间进行跳转。还可以通过 <code>z=</code> 命令获取建议列表。</p>\n<hr>\n<p><code>ZZ</code> 快速退出并保存。<br><code>dfi</code> 从光标处删除至i(包括i), <code>dti</code> 从光标处删除至i(不包括i)。</p>\n<hr>\n<p>有的时候需要在单词左右添加引号括号之类的，需要在 .vimrc 中添加定义</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>! <span class=\"title\">s</span>:<span class=\"title\">surround</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> word = <span class=\"built_in\">expand</span>(<span class=\"string\">&quot;&lt;cword&gt;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> wrap= <span class=\"built_in\">input</span>(<span class=\"string\">&quot;wrap with: &quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">command</span> = <span class=\"string\">&quot;s/&quot;</span>.word.<span class=\"string\">&quot;/&quot;</span>.wrap.word.wrap.<span class=\"string\">&quot;/&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">execute</span> <span class=\"keyword\">command</span></span><br><span class=\"line\"><span class=\"keyword\">endfunction</span></span><br><span class=\"line\"><span class=\"keyword\">nmap</span> cx :<span class=\"keyword\">call</span> <span class=\"symbol\">&lt;SID&gt;</span>surround()<span class=\"symbol\">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样在 nomal 模式下使用 <code>cx</code> + <code>&quot;</code> 就能在单词左右添加引号。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>边学习 Vim 技巧 边做笔记 学到一点就记录一点</p>\n<!--- more --->\n<p>从今天开始练习使用Vim，从最开始开始。</p>\n<ul>\n<li><p>查询： 可以在 Vi 模式下直接使用 <code>:h ctrl-w</code> 查询 <code>&lt;C-w&gt;</code> 的用法。</p>\n</li>\n<li><p>输出： :echo 指令。</p>\n<pre><code>  Vim中的printf。 :echo &quot;Hello,world!&quot; \n</code></pre>\n</li>\n<li><p>持久化消息， 使用 <code>:echom &quot;Hello again,World!&quot;</code> 指令，然后使用 <code>:messages</code> 。能够再次看到 echom打印 “Hello again,World!” 的指令</p>\n</li>\n<li><p>基本映射 <code>:map \\ dd</code> 使用 ‘&#39; 指令代表 <code>dd</code> (删除行)  </p>\n</li>\n<li><p>缩写 可以快捷输入一些类内容</p>\n<pre><code>  :iabbrev hu Copyright 2011 Steve Losh\n</code></pre>\n</li>\n</ul>\n<hr>\n<ul>\n<li>插入模式映射设置  <code>:inoremap jk &lt;esc&gt;</code>  在插入模式下按jk退出插入模式</li>\n<li><code>J</code> (大写) 讲两行拼接成一行</li>\n<li>多行注释 <code>Ctrl+v, 选中行，I（大写I）, #, ESC</code></li>\n</ul>\n<hr>\n<ul>\n<li><code>f</code> <code>F</code> 移动光标到当前行的字母 例如 <code>fc</code> 移动到光标后面第一个 c 字母上。<code>Fc</code> 移动到光标前第一个 c 字母。<br>  使用 <code>;</code> 查找本行下一个符合的字符 例如 <code>;</code> 跳转到下一个 c 字母上。使用 <code>,</code> 向前查找。</li>\n<li><code>t</code> <code>T</code> 类似 <code>f</code> <code>F</code> 。差别是移动到字母前一个位置</li>\n</ul>\n<hr>\n<ul>\n<li><code>\\</code> 或者 <code>?</code> 查找 例如 <code>\\error</code> <code>?error</code> 查找全文的error<br>按 <code>n</code> 向后查找匹配项 按 <code>N</code> 向前查找匹配项</li>\n<li><code>CTRL-O</code> 光标跳转到上一个查找对象处 <code>CTRL-I</code> 光标跳转到下一个查找处</li>\n<li>通过 <code>:set ic</code> 来忽略大小写 通过 <code>:set noic</code> 来分辨大小写 如果仅在第一次搜索时忽略大小写 直接在 搜索内容后添加 <code>\\c</code> 例如: <code>\\error\\c</code></li>\n<li>设置搜索高亮 <code>:set hls is</code>  注: 取消搜索高亮 <code>:nohlsearch</code></li>\n</ul>\n<hr>\n<p>今天终于在xcode 9 上安装了 <a href=\"https://github.com/XVimProject/XVim2\">XVim</a> 了！！！</p>\n<ul>\n<li><code>sp</code> 或 <code>Ctrl+w s</code> 水平分割窗口</li>\n<li><code>vs</code> 或 <code>Ctrl+w v</code> 垂直分割窗口</li>\n<li><code>Ctrl+w q</code> 关闭当前窗口</li>\n<li><code>Ctrl+w o</code> 关闭除当前串口外的所有窗口</li>\n<li><code>Ctrl+w w</code> 遍历切换窗口</li>\n</ul>\n<hr>\n<ul>\n<li><code>#</code> 匹配单词 寻找下一个相同的单词。</li>\n<li><code>di&quot;</code> 删除 “ 之间的内容。</li>\n</ul>\n<hr>\n<ul>\n<li><code>&gt;G</code> 使当前行到文档末尾处增加一个缩进，可以使用 <code>.</code> 继续重复命令。</li>\n<li><code>s</code> 替换当前单词 == <code>cl</code>。</li>\n<li><code>S</code> == <code>C</code> 删除整行 并重新输入。</li>\n</ul>\n<hr>\n<ul>\n<li><code>:%s/\\.o/\\.c/g</code> 将 .o 替换为 .c。 <code>%</code> 表示所有行，<code>g</code> 表示全部替换<br><code>:s/aaa/bbb</code> 只替换第一行的第一个。<code>1,12s/aaa/bbb/g</code> 替换1到12行所有的。</li>\n<li><code>daw</code> <code>diw</code> 可以更快向前删除一个单词 <code>aw</code> 比 <code>iw</code> 多删除空格。 </li>\n<li><code>dab</code> <code>dib</code> 删除小括号内中的内容. <code>ab</code>  比 <code>ib</code> 多删除括号。等于 <code>da(</code> <code>di(</code>,类似还有 <code>daB</code> <code>diB</code> 等于 <code>da&#123;</code> <code>di&#123;</code> 删除大括号内容。</li>\n<li><code>dit</code> <code>dat</code> 删除匹配标签栏中的内容。如 <a color=#00ff00>title</a>,输入 <code>dit</code> 会删除 title，删除掉标签中的内容。</li>\n<li><code>&lt;C-a&gt;</code> <code>&lt;C-x&gt;</code> 把当前数字加一或减一。Tips: 如果是对 007 使用 <code>&lt;C-a&gt;</code> 将会得到结果为 010，是因为 vim 认为 007 是8进制，在 .vimrc 中设置 <code>set nrformats=</code> 会转为十进制。</li>\n</ul>\n<hr>\n<ul>\n<li><font color=#0089ff>蓝色代表插入模式下指令</font>。</li>\n<li><font color=#0089ff>\u000eCtrl+w</font> 删除一个单词。</li>\n<li><font color=#0089ff>\u000eCtrl+u</font> 删除至行首。</li>\n<li><code>yt,</code> 复制光标到 “,” 之间所有的内容。<font color=#0089ff>Ctrl+r0</font> 在光标位置粘贴复制内容。yt 的意思是复制内容到专用寄存器中，所以 Ctrl+r0 表示取出第0个内容。</li>\n<li><font color=#0089ff>Ctrl+r=</font> 使用运算功能。例如 计算 6 * 35:在插入模式输入 <code>&lt;C+r&gt;=6*35</code>。直接获得结果210。</li>\n</ul>\n<hr>\n<ul>\n<li><font color=#008900>绿色代表可视模式下指令</font>。</li>\n<li><code>gv</code> 重选上次高亮选区。</li>\n<li><font color=#008900><strong>o</strong></font> 切换高亮选区活动端。</li>\n<li><font color=#008900><strong>u U</strong></font> 对选中单词进行小写/大写切换。</li>\n</ul>\n<hr>\n<p><code>:[range] delete [x]</code> 删除指定范围内的行[到寄存器 x 中]。<br><code>&quot;[x]p</code> 粘贴寄存器 x 中的内容，例如粘贴寄存器 2 中的内容：<code>&quot;2p</code>。<br><code>:reg</code> 查看寄存器内容。<br><code>@:</code> 重复上一条命令。<br><code>:!</code> 执行 Shell 中的程序，例如：<code>:!ls</code>。</p>\n<hr>\n<p><code>&lt;C+o&gt;</code> 类似网页后退，后退到上一个打开的文本。对应的还有 <code>&lt;C+i&gt;</code> 前进。<br><code>:jumps</code> 打开历史文件列表。</p>\n<hr>\n<p><code>m&#123;a-zA-z&#125;</code> 把位置标记 {a-zA-Z} 设在当前光标位置 (不移动光标，这不是动作命令)。<br><code>&#39;&#123;mark&#125;</code> 跳转到标记行首。 `` 跳转到上次光标位置。<br>``{mark}` 跳转到标记处。 </p>\n<hr>\n<p><code>qa</code> (需要记录的指令) <code>q</code> 使用 <code>q</code> + 寄存器位置来记录宏操作，最后以 <code>q</code> 指令结尾。<br><code>@a</code> 执行寄存器(a)中指令。 <code>:reg</code> 查看寄存器中所有的内容。<br><code>~</code> 大小写转换，并使光标跳转到下一个字符。</p>\n<hr>\n<p><code>q/</code> 查看历史指令。</p>\n<hr>\n<p><code>&lt;C+]&gt;</code> 跳转光标到关键字的定义处。<br><code>&lt;C+n&gt;</code>  和 <code>&lt;C+p&gt;</code> 可以激活自动补全功能。<br><code>&lt;C+x&gt;</code> <code>&lt;C+l&gt;</code> 组合使用可以补全本行内容。<br><code>:set spell</code> 检查拼写错误。 通过 <code>[s</code> 和 <code>]s</code> 命令在拼写错误间进行跳转。还可以通过 <code>z=</code> 命令获取建议列表。</p>\n<hr>\n<p><code>ZZ</code> 快速退出并保存。<br><code>dfi</code> 从光标处删除至i(包括i), <code>dti</code> 从光标处删除至i(不包括i)。</p>\n<hr>\n<p>有的时候需要在单词左右添加引号括号之类的，需要在 .vimrc 中添加定义</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>! <span class=\"title\">s</span>:<span class=\"title\">surround</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> word = <span class=\"built_in\">expand</span>(<span class=\"string\">&quot;&lt;cword&gt;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> wrap= <span class=\"built_in\">input</span>(<span class=\"string\">&quot;wrap with: &quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">command</span> = <span class=\"string\">&quot;s/&quot;</span>.word.<span class=\"string\">&quot;/&quot;</span>.wrap.word.wrap.<span class=\"string\">&quot;/&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">execute</span> <span class=\"keyword\">command</span></span><br><span class=\"line\"><span class=\"keyword\">endfunction</span></span><br><span class=\"line\"><span class=\"keyword\">nmap</span> cx :<span class=\"keyword\">call</span> <span class=\"symbol\">&lt;SID&gt;</span>surround()<span class=\"symbol\">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样在 nomal 模式下使用 <code>cx</code> + <code>&quot;</code> 就能在单词左右添加引号。</p>\n"},{"layout":"swift","title":"Xcode 单元测试","date":"2017-11-13T06:28:01.000Z","_content":"有的时候很需要进行单元测试来节省开发时间。之前一直不太熟悉这一块的知识，正好整理学习一下。\n<!--- more --->\n#### 模拟网络请求\n这里以 Sky 这个项目作为演示。模拟获取天气的网络请求方法。关键代码如下:\n\n```\nenum DataManagerError: Error {\n    case failedRequest\n    case invalidResponse\n    case unknown\n}\nstruct WeatherData: Codable {\n    let latitude: Double\n    let longitude: Double\n}\n\ntypealias CompletionHandler = (WeatherData?, DataManagerError?) -> Void\n    \nfunc weatherDataAt(latitude: Double, longtitude: Double, completion: @escaping CompletionHandler) {\n        let url = baseURL.appendingPathComponent(\"\\(latitude), \\(longtitude)\")\n        var request = URLRequest(url: url)\n        \n        request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        request.httpMethod = \"GET\"\n        \n        self.urlSession.dataTask(with: request) { (data, response, error) in\n            self.didFinishGettingWeatherData(data: data, response: response, error: error, completion: completion)\n        }.resume()\n    }\nfunc didFinishGettingWeatherData(data: Data?, response: URLResponse?, error: Error?, completion: CompletionHandler) {\n        if let _ = error {\n            completion(nil, .failedRequest)\n        }else if let data = data, let response = response as? HTTPURLResponse {\n            if response.statusCode == 200 {\n                do {\n                    let weatherData = try JSONDecoder().decode(WeatherData.self, from: data)\n                    completion(weatherData, nil)\n                }catch {\n                    completion(nil, .invalidResponse)\n                }\n            }else {\n                completion(nil, .failedRequest)\n            }\n        }else {\n            completion(nil, .unknown)\n        }\n    }\n```\n其中包括 3 个关键的可变对象： self.urlSession、request 和  completion。我们就需要单独对这 3 个数据进行模拟。\n模拟结果分为 3 种：\n1. 是否能获取到网络数据。(success)\n2. 获取网络数据失败。 (failedRequest)\n3. 无效的网络响应。 (invalidResponse)\n\n#### 准备工作\n创建好 Tests 文件。在此需要引入头文件来确保可以调用工程中的对象方法 `@testable import Sky`。在测试文件中，测试方法总是以 test 作为方法名的开头。\n#### 测试能否获取网络数据\n想要测试能否获取数据，self.urlSession 就不需要特意模拟，request 可以任意给经纬度进行拼接。最后获取 completion 中的 WeatherData,查看是否拥有数据。\n\n```\nfunc test_weatherDataAt_gets_data() {\n        let expect = expectation(description: \"Loading data form \\(API.authenticatedUrl)\")\n        var data: WeatherData? = nil\n        WeatherDataManager.shared.weatherDataAt(latitude: 52, longtitude: 100) { (response, error) in\n            data = response\n            expect.fulfill()\n        }\n        \n        waitForExpectations(timeout: 5, handler: nil)\n        XCTAssertNotNil(data)\n    }\n```\n这里使用 `expectation` 来进行异步测试，当网络回调结果时候调用 `expect.fulfill()` 表示异步完成。否则调用 `waitForExpectations(timeout: 5, handler: nil)` 表明最多等待5秒。最后 `XCTAssertNotNil(data)` 表明如果 data 为 nil，则测试失败，进入断言。\n#### 测试failedRequest\n为了节省异步获取网络资源花费的时间，需要我们自己构造一个无效的网络响应。为了不影响项目的代码，我们需要自己定一个测试用的 URLSession。\n\n```\nclass MockURLSession: URLSessionProtocol {\n    var responseData: Data?\n    var responseHeader: HTTPURLResponse?\n    var responseError: Error?\n    var sessionDataTask = MockURLSessionDataTask()\n    \n    func dataTask(with request: URLRequest, completionHandler: @escaping URLSessionProtocol.dataTaskHandler) -> URLSessionDataTaskProcol {\n        completionHandler(responseData, responseHeader, responseError)\n        return sessionDataTask\n    }\n}\n```\n通过构造 MockURLSession 中的请求 responseError 来进行模拟。\n\n```\nfunc test_weatherDataAt_handle_invalid_request() {\n        let session = MockURLSession()\n        session.responseError = NSError(domain: \"Invalid Requset\", code: 100, userInfo: nil)\n        \n        let manager = WeatherDataManager(baseURL: URL(string: \"https://darksky.net\")!, urlSession: session)\n        \n        var error: DataManagerError? = nil\n        manager.weatherDataAt(latitude: 52, longtitude: 100) { (_, e) in\n            error = e\n        }\n        \n        XCTAssertEqual(error, DataManagerError.failedRequest)\n    }\n```\n#### 测试invalidResponse\n和测试 failedRequest 的思路一样，只不过这次我们构造的错误信息应该是状态码 200 而 data 数据错误的情况。\n\n```\nfunc test_weatherDataAt_handle_invalid_response() {\n        session.responseHeader = HTTPURLResponse(url: URL(string: \"https://darksky.net\")!, statusCode: 200, httpVersion: nil, headerFields: nil)\n        \n        let data = \"{\".data(using: .utf8)!\n        session.responseData = data\n        \n        let manager = WeatherDataManager(baseURL: URL(string: \"https://darksky.net\")!, urlSession: session)\n        \n        var error: DataManagerError? = nil\n        \n        manager.weatherDataAt(latitude: 52, longtitude: 100) { (_, e) in\n            error = e\n        }\n        \n        XCTAssertEqual(error, DataManagerError.invalidResponse)\n    }\n```\n#### 性能测试\n利用 XCTest 中的 `measure()` 方法进行性能测试。可以直观的观察出方法花费时间。\n\n```\nfunc test_performance() {\n    self.measure {\n     \t// Time: 0.003 sec (100% better)\n        for i in 1...100 {\n           print(i)\n        }\n    }\n}\n```\n#####  后记 —— 2017年12月26日\n尝试在公司的项目上进行单元测试，没想到配置环境就遇到了好多问题，果然是对这个 XCode 工程的配置不是很熟悉啊。由于我的工程项目是以 Swift 为基础，加入 Objective-C 框架进行混编的，而且使用 CocoaPod 进行的配置，所以引入工程遇到了很多问题。幸好还是在网上找到了解决方案，这里就记录一下。\n###### 导入 Pods\n由于新增测试模块，所以在进行测试的使用也会用到 CocoaPod 导入的三方库，所以在 Podfile 文件也需要对测试模块进行配置。\n\n```\nplatform :ios, '8.0'\nuse_frameworks!\ndef pods\n    pod 'Alamofire', '~> 4.5.1'\n    pod 'SwiftyJSON', '~> 4.0.0'\nend\ntarget 'HiDoc' do\n    pods\nend\n\ntarget 'HiDocTests' do\n    pods\nend\n```\n重新 pod install 的时候回遇到某些文件找不到的情况。这是因为 Tests 其实也是一个工程，依旧需要重新配置 Build Settings 中的 Path。比对原来工程中的 Search Paths 添加到工程中。![](https://github.com/hGhostD/MarkDownPhotos/blob/master/XCode%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/SearchPaths.png?raw=true)\n别忘了还要修改 <font color=#d13f28>**User Header Search Paths**</font> !!!\n有的时候依旧会报找不到文件，还需要修改 Precompile Prefix Header 为 YES。\n基本的配置已经完成了，在 Tests 文件中引入 `@testable import HiDoc` 就能够进行引用。但是在实际情况中，我的工程总会报 `\"CMPopTipView.h\" file not found`。我查看了一下发现这个文件是由 Pod 导入的第三方库，是在 Objective-C 的 .h 文件中引用的，并没有放入桥接文件中。后来就将这个文件引用放到 .m 文件中就解决了。\n###### 进行登录接口单元测试\n使用测试账号进行登录，创建测试方法。\n\n```\nfunc test_login() {\n        let email = \"13600000002\"\n        let password = \"123456\"\n        \n        let expect = expectation(description: \"login\")\n        var isSuccess = false\n        var test = \"\"\n        HYLoginTool.loginWithPromise(email: email, password: password).then { (result) -> (Void) in\n            if (result[\"ret\"].stringValue == \"0\") {\n                isSuccess = true\n            }else {\n                isSuccess = false\n            }\n            test = result[\"error\"].stringValue\n            expect.fulfill()\n            }.catch { (error) in\n                isSuccess = false\n                test = error.localizedDescription\n                expect.fulfill()\n        }\n        waitForExpectations(timeout: 10, handler: nil)\n        XCTAssert(isSuccess, test)\n    }\n```\n\n#### 常用判断条件\n\n```\nXCTFail(format…) 生成一个失败的测试； \nXCTAssertNil(a1, format...)为空判断，a1为空时通过，反之不通过；\nXCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；\nXCTAssert(expression, format...)当expression求值为TRUE时通过；\nXCTAssertTrue(expression, format...)当expression求值为TRUE时通过；\nXCTAssertFalse(expression, format...)当expression求值为False时通过；\nXCTAssertEqualObjects(a1, a2, format...)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；\nXCTAssertNotEqualObjects(a1, a2, format...)判断不等，[a1 isEqual:a2]值为False时通过；\nXCTAssertEqual(a1, a2, format...)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用, 判断的是变量的地址，如果地址相同则返回TRUE，否则返回NO）；\nXCTAssertNotEqual(a1, a2, format...)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；\nXCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；\nXCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；\nXCTAssertThrows(expression, format...)异常测试，当expression发生异常时通过；反之不通过；（很变态） XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；\nXCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；\nXCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；\nXCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；\nXCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过\n```\n","source":"_posts/Xcode 单元测试.md","raw":"---\nlayout: swift\ntitle: Xcode 单元测试\ndate: 2017-11-13 14:28:01\ntags: \n- Swift\ncategories: \n- Swift\n---\n有的时候很需要进行单元测试来节省开发时间。之前一直不太熟悉这一块的知识，正好整理学习一下。\n<!--- more --->\n#### 模拟网络请求\n这里以 Sky 这个项目作为演示。模拟获取天气的网络请求方法。关键代码如下:\n\n```\nenum DataManagerError: Error {\n    case failedRequest\n    case invalidResponse\n    case unknown\n}\nstruct WeatherData: Codable {\n    let latitude: Double\n    let longitude: Double\n}\n\ntypealias CompletionHandler = (WeatherData?, DataManagerError?) -> Void\n    \nfunc weatherDataAt(latitude: Double, longtitude: Double, completion: @escaping CompletionHandler) {\n        let url = baseURL.appendingPathComponent(\"\\(latitude), \\(longtitude)\")\n        var request = URLRequest(url: url)\n        \n        request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        request.httpMethod = \"GET\"\n        \n        self.urlSession.dataTask(with: request) { (data, response, error) in\n            self.didFinishGettingWeatherData(data: data, response: response, error: error, completion: completion)\n        }.resume()\n    }\nfunc didFinishGettingWeatherData(data: Data?, response: URLResponse?, error: Error?, completion: CompletionHandler) {\n        if let _ = error {\n            completion(nil, .failedRequest)\n        }else if let data = data, let response = response as? HTTPURLResponse {\n            if response.statusCode == 200 {\n                do {\n                    let weatherData = try JSONDecoder().decode(WeatherData.self, from: data)\n                    completion(weatherData, nil)\n                }catch {\n                    completion(nil, .invalidResponse)\n                }\n            }else {\n                completion(nil, .failedRequest)\n            }\n        }else {\n            completion(nil, .unknown)\n        }\n    }\n```\n其中包括 3 个关键的可变对象： self.urlSession、request 和  completion。我们就需要单独对这 3 个数据进行模拟。\n模拟结果分为 3 种：\n1. 是否能获取到网络数据。(success)\n2. 获取网络数据失败。 (failedRequest)\n3. 无效的网络响应。 (invalidResponse)\n\n#### 准备工作\n创建好 Tests 文件。在此需要引入头文件来确保可以调用工程中的对象方法 `@testable import Sky`。在测试文件中，测试方法总是以 test 作为方法名的开头。\n#### 测试能否获取网络数据\n想要测试能否获取数据，self.urlSession 就不需要特意模拟，request 可以任意给经纬度进行拼接。最后获取 completion 中的 WeatherData,查看是否拥有数据。\n\n```\nfunc test_weatherDataAt_gets_data() {\n        let expect = expectation(description: \"Loading data form \\(API.authenticatedUrl)\")\n        var data: WeatherData? = nil\n        WeatherDataManager.shared.weatherDataAt(latitude: 52, longtitude: 100) { (response, error) in\n            data = response\n            expect.fulfill()\n        }\n        \n        waitForExpectations(timeout: 5, handler: nil)\n        XCTAssertNotNil(data)\n    }\n```\n这里使用 `expectation` 来进行异步测试，当网络回调结果时候调用 `expect.fulfill()` 表示异步完成。否则调用 `waitForExpectations(timeout: 5, handler: nil)` 表明最多等待5秒。最后 `XCTAssertNotNil(data)` 表明如果 data 为 nil，则测试失败，进入断言。\n#### 测试failedRequest\n为了节省异步获取网络资源花费的时间，需要我们自己构造一个无效的网络响应。为了不影响项目的代码，我们需要自己定一个测试用的 URLSession。\n\n```\nclass MockURLSession: URLSessionProtocol {\n    var responseData: Data?\n    var responseHeader: HTTPURLResponse?\n    var responseError: Error?\n    var sessionDataTask = MockURLSessionDataTask()\n    \n    func dataTask(with request: URLRequest, completionHandler: @escaping URLSessionProtocol.dataTaskHandler) -> URLSessionDataTaskProcol {\n        completionHandler(responseData, responseHeader, responseError)\n        return sessionDataTask\n    }\n}\n```\n通过构造 MockURLSession 中的请求 responseError 来进行模拟。\n\n```\nfunc test_weatherDataAt_handle_invalid_request() {\n        let session = MockURLSession()\n        session.responseError = NSError(domain: \"Invalid Requset\", code: 100, userInfo: nil)\n        \n        let manager = WeatherDataManager(baseURL: URL(string: \"https://darksky.net\")!, urlSession: session)\n        \n        var error: DataManagerError? = nil\n        manager.weatherDataAt(latitude: 52, longtitude: 100) { (_, e) in\n            error = e\n        }\n        \n        XCTAssertEqual(error, DataManagerError.failedRequest)\n    }\n```\n#### 测试invalidResponse\n和测试 failedRequest 的思路一样，只不过这次我们构造的错误信息应该是状态码 200 而 data 数据错误的情况。\n\n```\nfunc test_weatherDataAt_handle_invalid_response() {\n        session.responseHeader = HTTPURLResponse(url: URL(string: \"https://darksky.net\")!, statusCode: 200, httpVersion: nil, headerFields: nil)\n        \n        let data = \"{\".data(using: .utf8)!\n        session.responseData = data\n        \n        let manager = WeatherDataManager(baseURL: URL(string: \"https://darksky.net\")!, urlSession: session)\n        \n        var error: DataManagerError? = nil\n        \n        manager.weatherDataAt(latitude: 52, longtitude: 100) { (_, e) in\n            error = e\n        }\n        \n        XCTAssertEqual(error, DataManagerError.invalidResponse)\n    }\n```\n#### 性能测试\n利用 XCTest 中的 `measure()` 方法进行性能测试。可以直观的观察出方法花费时间。\n\n```\nfunc test_performance() {\n    self.measure {\n     \t// Time: 0.003 sec (100% better)\n        for i in 1...100 {\n           print(i)\n        }\n    }\n}\n```\n#####  后记 —— 2017年12月26日\n尝试在公司的项目上进行单元测试，没想到配置环境就遇到了好多问题，果然是对这个 XCode 工程的配置不是很熟悉啊。由于我的工程项目是以 Swift 为基础，加入 Objective-C 框架进行混编的，而且使用 CocoaPod 进行的配置，所以引入工程遇到了很多问题。幸好还是在网上找到了解决方案，这里就记录一下。\n###### 导入 Pods\n由于新增测试模块，所以在进行测试的使用也会用到 CocoaPod 导入的三方库，所以在 Podfile 文件也需要对测试模块进行配置。\n\n```\nplatform :ios, '8.0'\nuse_frameworks!\ndef pods\n    pod 'Alamofire', '~> 4.5.1'\n    pod 'SwiftyJSON', '~> 4.0.0'\nend\ntarget 'HiDoc' do\n    pods\nend\n\ntarget 'HiDocTests' do\n    pods\nend\n```\n重新 pod install 的时候回遇到某些文件找不到的情况。这是因为 Tests 其实也是一个工程，依旧需要重新配置 Build Settings 中的 Path。比对原来工程中的 Search Paths 添加到工程中。![](https://github.com/hGhostD/MarkDownPhotos/blob/master/XCode%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/SearchPaths.png?raw=true)\n别忘了还要修改 <font color=#d13f28>**User Header Search Paths**</font> !!!\n有的时候依旧会报找不到文件，还需要修改 Precompile Prefix Header 为 YES。\n基本的配置已经完成了，在 Tests 文件中引入 `@testable import HiDoc` 就能够进行引用。但是在实际情况中，我的工程总会报 `\"CMPopTipView.h\" file not found`。我查看了一下发现这个文件是由 Pod 导入的第三方库，是在 Objective-C 的 .h 文件中引用的，并没有放入桥接文件中。后来就将这个文件引用放到 .m 文件中就解决了。\n###### 进行登录接口单元测试\n使用测试账号进行登录，创建测试方法。\n\n```\nfunc test_login() {\n        let email = \"13600000002\"\n        let password = \"123456\"\n        \n        let expect = expectation(description: \"login\")\n        var isSuccess = false\n        var test = \"\"\n        HYLoginTool.loginWithPromise(email: email, password: password).then { (result) -> (Void) in\n            if (result[\"ret\"].stringValue == \"0\") {\n                isSuccess = true\n            }else {\n                isSuccess = false\n            }\n            test = result[\"error\"].stringValue\n            expect.fulfill()\n            }.catch { (error) in\n                isSuccess = false\n                test = error.localizedDescription\n                expect.fulfill()\n        }\n        waitForExpectations(timeout: 10, handler: nil)\n        XCTAssert(isSuccess, test)\n    }\n```\n\n#### 常用判断条件\n\n```\nXCTFail(format…) 生成一个失败的测试； \nXCTAssertNil(a1, format...)为空判断，a1为空时通过，反之不通过；\nXCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；\nXCTAssert(expression, format...)当expression求值为TRUE时通过；\nXCTAssertTrue(expression, format...)当expression求值为TRUE时通过；\nXCTAssertFalse(expression, format...)当expression求值为False时通过；\nXCTAssertEqualObjects(a1, a2, format...)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；\nXCTAssertNotEqualObjects(a1, a2, format...)判断不等，[a1 isEqual:a2]值为False时通过；\nXCTAssertEqual(a1, a2, format...)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用, 判断的是变量的地址，如果地址相同则返回TRUE，否则返回NO）；\nXCTAssertNotEqual(a1, a2, format...)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；\nXCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；\nXCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；\nXCTAssertThrows(expression, format...)异常测试，当expression发生异常时通过；反之不通过；（很变态） XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；\nXCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；\nXCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；\nXCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；\nXCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过\n```\n","slug":"Xcode 单元测试","published":1,"updated":"2018-01-06T02:57:32.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfya7000r7sn6dzxdgh0p","content":"<p>有的时候很需要进行单元测试来节省开发时间。之前一直不太熟悉这一块的知识，正好整理学习一下。</p>\n<!--- more --->\n<h4 id=\"模拟网络请求\"><a href=\"#模拟网络请求\" class=\"headerlink\" title=\"模拟网络请求\"></a>模拟网络请求</h4><p>这里以 Sky 这个项目作为演示。模拟获取天气的网络请求方法。关键代码如下:</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum DataManagerError: Error &#123;</span><br><span class=\"line\">    case failedRequest</span><br><span class=\"line\">    case invalidResponse</span><br><span class=\"line\">    case unknown</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> WeatherData: Codable &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> latitude: Double</span><br><span class=\"line\">    <span class=\"keyword\">let</span> longitude: Double</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typealias CompletionHandler = (WeatherData?, DataManagerError?) -&gt; Void</span><br><span class=\"line\">    </span><br><span class=\"line\">func weather<span class=\"constructor\">DataAt(<span class=\"params\">latitude</span>: Double, <span class=\"params\">longtitude</span>: Double, <span class=\"params\">completion</span>: @<span class=\"params\">escaping</span> CompletionHandler)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> url = baseURL.appending<span class=\"constructor\">PathComponent(<span class=\"string\">&quot;\\(latitude), \\(longtitude)&quot;</span>)</span></span><br><span class=\"line\">        var request = <span class=\"constructor\">URLRequest(<span class=\"params\">url</span>: <span class=\"params\">url</span>)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        request.set<span class=\"constructor\">Value(<span class=\"string\">&quot;application/json&quot;</span>, <span class=\"params\">forHTTPHeaderField</span>: <span class=\"string\">&quot;Content-Type&quot;</span>)</span></span><br><span class=\"line\">        request.httpMethod = <span class=\"string\">&quot;GET&quot;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        self.urlSession.data<span class=\"constructor\">Task(<span class=\"params\">with</span>: <span class=\"params\">request</span>)</span> &#123; (data, response, error) <span class=\"keyword\">in</span></span><br><span class=\"line\">            self.did<span class=\"constructor\">FinishGettingWeatherData(<span class=\"params\">data</span>: <span class=\"params\">data</span>, <span class=\"params\">response</span>: <span class=\"params\">response</span>, <span class=\"params\">error</span>: <span class=\"params\">error</span>, <span class=\"params\">completion</span>: <span class=\"params\">completion</span>)</span></span><br><span class=\"line\">        &#125;.resume<span class=\"literal\">()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">func did<span class=\"constructor\">FinishGettingWeatherData(<span class=\"params\">data</span>: Data?, <span class=\"params\">response</span>: URLResponse?, <span class=\"params\">error</span>: Error?, <span class=\"params\">completion</span>: CompletionHandler)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> _ = error &#123;</span><br><span class=\"line\">            completion(nil, .failedRequest)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data = data, <span class=\"keyword\">let</span> response = response <span class=\"keyword\">as</span>? HTTPURLResponse &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> response.statusCode<span class=\"operator\"> == </span><span class=\"number\">200</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">let</span> weatherData = <span class=\"keyword\">try</span> <span class=\"constructor\">JSONDecoder()</span>.decode(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">WeatherData</span>.</span></span>self, from: data)</span><br><span class=\"line\">                    completion(weatherData, nil)</span><br><span class=\"line\">                &#125;catch &#123;</span><br><span class=\"line\">                    completion(nil, .invalidResponse)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                completion(nil, .failedRequest)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            completion(nil, .unknown)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其中包括 3 个关键的可变对象： self.urlSession、request 和  completion。我们就需要单独对这 3 个数据进行模拟。<br>模拟结果分为 3 种：</p>\n<ol>\n<li>是否能获取到网络数据。(success)</li>\n<li>获取网络数据失败。 (failedRequest)</li>\n<li>无效的网络响应。 (invalidResponse)</li>\n</ol>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>创建好 Tests 文件。在此需要引入头文件来确保可以调用工程中的对象方法 <code>@testable import Sky</code>。在测试文件中，测试方法总是以 test 作为方法名的开头。</p>\n<h4 id=\"测试能否获取网络数据\"><a href=\"#测试能否获取网络数据\" class=\"headerlink\" title=\"测试能否获取网络数据\"></a>测试能否获取网络数据</h4><p>想要测试能否获取数据，self.urlSession 就不需要特意模拟，request 可以任意给经纬度进行拼接。最后获取 completion 中的 WeatherData,查看是否拥有数据。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func test<span class=\"constructor\">_weatherDataAt_gets_data()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> expect = expectation(description: <span class=\"string\">&quot;Loading data form \\(API.authenticatedUrl)&quot;</span>)</span><br><span class=\"line\">        var data: WeatherData? = nil</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">WeatherDataManager</span>.</span></span>shared.weather<span class=\"constructor\">DataAt(<span class=\"params\">latitude</span>: 52, <span class=\"params\">longtitude</span>: 100)</span> &#123; (response, error) <span class=\"keyword\">in</span></span><br><span class=\"line\">            data = response</span><br><span class=\"line\">            expect.fulfill<span class=\"literal\">()</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        wait<span class=\"constructor\">ForExpectations(<span class=\"params\">timeout</span>: 5, <span class=\"params\">handler</span>: <span class=\"params\">nil</span>)</span></span><br><span class=\"line\">        <span class=\"constructor\">XCTAssertNotNil(<span class=\"params\">data</span>)</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这里使用 <code>expectation</code> 来进行异步测试，当网络回调结果时候调用 <code>expect.fulfill()</code> 表示异步完成。否则调用 <code>waitForExpectations(timeout: 5, handler: nil)</code> 表明最多等待5秒。最后 <code>XCTAssertNotNil(data)</code> 表明如果 data 为 nil，则测试失败，进入断言。</p>\n<h4 id=\"测试failedRequest\"><a href=\"#测试failedRequest\" class=\"headerlink\" title=\"测试failedRequest\"></a>测试failedRequest</h4><p>为了节省异步获取网络资源花费的时间，需要我们自己构造一个无效的网络响应。为了不影响项目的代码，我们需要自己定一个测试用的 URLSession。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MockURLSession</span>: <span class=\"title\">URLSessionProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> responseData: <span class=\"type\">Data</span>?</span><br><span class=\"line\">    <span class=\"keyword\">var</span> responseHeader: <span class=\"type\">HTTPURLResponse</span>?</span><br><span class=\"line\">    <span class=\"keyword\">var</span> responseError: <span class=\"type\">Error</span>?</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sessionDataTask <span class=\"operator\">=</span> <span class=\"type\">MockURLSessionDataTask</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dataTask</span>(<span class=\"params\">with</span> <span class=\"params\">request</span>: <span class=\"type\">URLRequest</span>, <span class=\"params\">completionHandler</span>: <span class=\"keyword\">@escaping</span> <span class=\"type\">URLSessionProtocol</span>.dataTaskHandler)</span> -&gt; <span class=\"type\">URLSessionDataTaskProcol</span> &#123;</span><br><span class=\"line\">        completionHandler(responseData, responseHeader, responseError)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sessionDataTask</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过构造 MockURLSession 中的请求 responseError 来进行模拟。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func test<span class=\"constructor\">_weatherDataAt_handle_invalid_request()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> session = <span class=\"constructor\">MockURLSession()</span></span><br><span class=\"line\">        session.responseError = <span class=\"constructor\">NSError(<span class=\"params\">domain</span>: <span class=\"string\">&quot;Invalid Requset&quot;</span>, <span class=\"params\">code</span>: 100, <span class=\"params\">userInfo</span>: <span class=\"params\">nil</span>)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> manager = <span class=\"constructor\">WeatherDataManager(<span class=\"params\">baseURL</span>: URL(<span class=\"params\">string</span>: <span class=\"string\">&quot;https://darksky.net&quot;</span>)</span>!, urlSession: session)</span><br><span class=\"line\">        </span><br><span class=\"line\">        var error: DataManagerError? = nil</span><br><span class=\"line\">        manager.weather<span class=\"constructor\">DataAt(<span class=\"params\">latitude</span>: 52, <span class=\"params\">longtitude</span>: 100)</span> &#123; (_, e) <span class=\"keyword\">in</span></span><br><span class=\"line\">            error = e</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"constructor\">XCTAssertEqual(<span class=\"params\">error</span>, DataManagerError.<span class=\"params\">failedRequest</span>)</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"测试invalidResponse\"><a href=\"#测试invalidResponse\" class=\"headerlink\" title=\"测试invalidResponse\"></a>测试invalidResponse</h4><p>和测试 failedRequest 的思路一样，只不过这次我们构造的错误信息应该是状态码 200 而 data 数据错误的情况。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func test<span class=\"constructor\">_weatherDataAt_handle_invalid_response()</span> &#123;</span><br><span class=\"line\">        session.responseHeader = <span class=\"constructor\">HTTPURLResponse(<span class=\"params\">url</span>: URL(<span class=\"params\">string</span>: <span class=\"string\">&quot;https://darksky.net&quot;</span>)</span>!, statusCode: <span class=\"number\">200</span>, httpVersion: nil, headerFields: nil)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = <span class=\"string\">&quot;&#123;&quot;</span>.data(using: .utf8)!</span><br><span class=\"line\">        session.responseData = data</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> manager = <span class=\"constructor\">WeatherDataManager(<span class=\"params\">baseURL</span>: URL(<span class=\"params\">string</span>: <span class=\"string\">&quot;https://darksky.net&quot;</span>)</span>!, urlSession: session)</span><br><span class=\"line\">        </span><br><span class=\"line\">        var error: DataManagerError? = nil</span><br><span class=\"line\">        </span><br><span class=\"line\">        manager.weather<span class=\"constructor\">DataAt(<span class=\"params\">latitude</span>: 52, <span class=\"params\">longtitude</span>: 100)</span> &#123; (_, e) <span class=\"keyword\">in</span></span><br><span class=\"line\">            error = e</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"constructor\">XCTAssertEqual(<span class=\"params\">error</span>, DataManagerError.<span class=\"params\">invalidResponse</span>)</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h4><p>利用 XCTest 中的 <code>measure()</code> 方法进行性能测试。可以直观的观察出方法花费时间。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test_performance</span>()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.measure &#123;</span><br><span class=\"line\">     \t<span class=\"comment\">// Time: 0.003 sec (100% better)</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">100</span> &#123;</span><br><span class=\"line\">           <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"后记-——-2017年12月26日\"><a href=\"#后记-——-2017年12月26日\" class=\"headerlink\" title=\"后记 —— 2017年12月26日\"></a>后记 —— 2017年12月26日</h5><p>尝试在公司的项目上进行单元测试，没想到配置环境就遇到了好多问题，果然是对这个 XCode 工程的配置不是很熟悉啊。由于我的工程项目是以 Swift 为基础，加入 Objective-C 框架进行混编的，而且使用 CocoaPod 进行的配置，所以引入工程遇到了很多问题。幸好还是在网上找到了解决方案，这里就记录一下。</p>\n<h6 id=\"导入-Pods\"><a href=\"#导入-Pods\" class=\"headerlink\" title=\"导入 Pods\"></a>导入 Pods</h6><p>由于新增测试模块，所以在进行测试的使用也会用到 CocoaPod 导入的三方库，所以在 Podfile 文件也需要对测试模块进行配置。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">&#x27;8.0&#x27;</span></span><br><span class=\"line\">use_frameworks!</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pods</span></span></span><br><span class=\"line\">    pod <span class=\"string\">&#x27;Alamofire&#x27;</span>, <span class=\"string\">&#x27;~&gt; 4.5.1&#x27;</span></span><br><span class=\"line\">    pod <span class=\"string\">&#x27;SwiftyJSON&#x27;</span>, <span class=\"string\">&#x27;~&gt; 4.0.0&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\">target <span class=\"string\">&#x27;HiDoc&#x27;</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    pods</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">target <span class=\"string\">&#x27;HiDocTests&#x27;</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    pods</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>重新 pod install 的时候回遇到某些文件找不到的情况。这是因为 Tests 其实也是一个工程，依旧需要重新配置 Build Settings 中的 Path。比对原来工程中的 Search Paths 添加到工程中。<img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/XCode%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/SearchPaths.png?raw=true\"><br>别忘了还要修改 <font color=#d13f28><strong>User Header Search Paths</strong></font> !!!<br>有的时候依旧会报找不到文件，还需要修改 Precompile Prefix Header 为 YES。<br>基本的配置已经完成了，在 Tests 文件中引入 <code>@testable import HiDoc</code> 就能够进行引用。但是在实际情况中，我的工程总会报 <code>&quot;CMPopTipView.h&quot; file not found</code>。我查看了一下发现这个文件是由 Pod 导入的第三方库，是在 Objective-C 的 .h 文件中引用的，并没有放入桥接文件中。后来就将这个文件引用放到 .m 文件中就解决了。</p>\n<h6 id=\"进行登录接口单元测试\"><a href=\"#进行登录接口单元测试\" class=\"headerlink\" title=\"进行登录接口单元测试\"></a>进行登录接口单元测试</h6><p>使用测试账号进行登录，创建测试方法。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func test<span class=\"constructor\">_login()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> email = <span class=\"string\">&quot;13600000002&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> password = <span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> expect = expectation(description: <span class=\"string\">&quot;login&quot;</span>)</span><br><span class=\"line\">        var isSuccess = <span class=\"literal\">false</span></span><br><span class=\"line\">        var test = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">HYLoginTool</span>.</span></span>login<span class=\"constructor\">WithPromise(<span class=\"params\">email</span>: <span class=\"params\">email</span>, <span class=\"params\">password</span>: <span class=\"params\">password</span>)</span>.<span class=\"keyword\">then</span> &#123; (result) -&gt; (Void) <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result<span class=\"literal\">[&quot;<span class=\"identifier\">ret</span>&quot;]</span>.stringValue<span class=\"operator\"> == </span><span class=\"string\">&quot;0&quot;</span>) &#123;</span><br><span class=\"line\">                isSuccess = <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                isSuccess = <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            test = result<span class=\"literal\">[&quot;<span class=\"identifier\">error</span>&quot;]</span>.stringValue</span><br><span class=\"line\">            expect.fulfill<span class=\"literal\">()</span></span><br><span class=\"line\">            &#125;.catch &#123; (error) <span class=\"keyword\">in</span></span><br><span class=\"line\">                isSuccess = <span class=\"literal\">false</span></span><br><span class=\"line\">                test = error.localizedDescription</span><br><span class=\"line\">                expect.fulfill<span class=\"literal\">()</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        wait<span class=\"constructor\">ForExpectations(<span class=\"params\">timeout</span>: 10, <span class=\"params\">handler</span>: <span class=\"params\">nil</span>)</span></span><br><span class=\"line\">        <span class=\"constructor\">XCTAssert(<span class=\"params\">isSuccess</span>, <span class=\"params\">test</span>)</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常用判断条件\"><a href=\"#常用判断条件\" class=\"headerlink\" title=\"常用判断条件\"></a>常用判断条件</h4><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"constructor\">XCTFail(<span class=\"params\">format</span>…)</span> 生成一个失败的测试； </span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNil(<span class=\"params\">a1</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>为空判断，a1为空时通过，反之不通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNotNil(<span class=\"params\">a1</span>, <span class=\"params\">format</span>…)</span>不为空判断，a1不为空时通过，反之不通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssert(<span class=\"params\">expression</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>当expression求值为TRUE时通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertTrue(<span class=\"params\">expression</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>当expression求值为TRUE时通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertFalse(<span class=\"params\">expression</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>当expression求值为False时通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertEqualObjects(<span class=\"params\">a1</span>, <span class=\"params\">a2</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>判断相等，<span class=\"literal\">[<span class=\"identifier\">a1</span> <span class=\"identifier\">isEqual</span>:<span class=\"identifier\">a2</span>]</span>值为TRUE时通过，其中一个不为空时，不通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNotEqualObjects(<span class=\"params\">a1</span>, <span class=\"params\">a2</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>判断不等，<span class=\"literal\">[<span class=\"identifier\">a1</span> <span class=\"identifier\">isEqual</span>:<span class=\"identifier\">a2</span>]</span>值为False时通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertEqual(<span class=\"params\">a1</span>, <span class=\"params\">a2</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>判断相等（当a1和a2是 C语言标量、结构体或联合体时使用, 判断的是变量的地址，如果地址相同则返回TRUE，否则返回NO）；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNotEqual(<span class=\"params\">a1</span>, <span class=\"params\">a2</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertEqualWithAccuracy(<span class=\"params\">a1</span>, <span class=\"params\">a2</span>, <span class=\"params\">accuracy</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>判断相等，（double或<span class=\"built_in\">float</span>类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNotEqualWithAccuracy(<span class=\"params\">a1</span>, <span class=\"params\">a2</span>, <span class=\"params\">accuracy</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span> 判断不等，（double或<span class=\"built_in\">float</span>类型）提供一个误差范围，当在误差范围以内不等时通过测试；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertThrows(<span class=\"params\">expression</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>异常测试，当expression发生异常时通过；反之不通过；（很变态） <span class=\"constructor\">XCTAssertThrowsSpecific(<span class=\"params\">expression</span>, <span class=\"params\">specificException</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span> 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertThrowsSpecificNamed(<span class=\"params\">expression</span>, <span class=\"params\">specificException</span>, <span class=\"params\">exception_name</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNoThrow(<span class=\"params\">expression</span>, <span class=\"params\">format</span>…)</span>异常测试，当expression没有发生异常时通过测试；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNoThrowSpecific(<span class=\"params\">expression</span>, <span class=\"params\">specificException</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNoThrowSpecificNamed(<span class=\"params\">expression</span>, <span class=\"params\">specificException</span>, <span class=\"params\">exception_name</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>有的时候很需要进行单元测试来节省开发时间。之前一直不太熟悉这一块的知识，正好整理学习一下。</p>\n<!--- more --->\n<h4 id=\"模拟网络请求\"><a href=\"#模拟网络请求\" class=\"headerlink\" title=\"模拟网络请求\"></a>模拟网络请求</h4><p>这里以 Sky 这个项目作为演示。模拟获取天气的网络请求方法。关键代码如下:</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum DataManagerError: Error &#123;</span><br><span class=\"line\">    case failedRequest</span><br><span class=\"line\">    case invalidResponse</span><br><span class=\"line\">    case unknown</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> WeatherData: Codable &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> latitude: Double</span><br><span class=\"line\">    <span class=\"keyword\">let</span> longitude: Double</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typealias CompletionHandler = (WeatherData?, DataManagerError?) -&gt; Void</span><br><span class=\"line\">    </span><br><span class=\"line\">func weather<span class=\"constructor\">DataAt(<span class=\"params\">latitude</span>: Double, <span class=\"params\">longtitude</span>: Double, <span class=\"params\">completion</span>: @<span class=\"params\">escaping</span> CompletionHandler)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> url = baseURL.appending<span class=\"constructor\">PathComponent(<span class=\"string\">&quot;\\(latitude), \\(longtitude)&quot;</span>)</span></span><br><span class=\"line\">        var request = <span class=\"constructor\">URLRequest(<span class=\"params\">url</span>: <span class=\"params\">url</span>)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        request.set<span class=\"constructor\">Value(<span class=\"string\">&quot;application/json&quot;</span>, <span class=\"params\">forHTTPHeaderField</span>: <span class=\"string\">&quot;Content-Type&quot;</span>)</span></span><br><span class=\"line\">        request.httpMethod = <span class=\"string\">&quot;GET&quot;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        self.urlSession.data<span class=\"constructor\">Task(<span class=\"params\">with</span>: <span class=\"params\">request</span>)</span> &#123; (data, response, error) <span class=\"keyword\">in</span></span><br><span class=\"line\">            self.did<span class=\"constructor\">FinishGettingWeatherData(<span class=\"params\">data</span>: <span class=\"params\">data</span>, <span class=\"params\">response</span>: <span class=\"params\">response</span>, <span class=\"params\">error</span>: <span class=\"params\">error</span>, <span class=\"params\">completion</span>: <span class=\"params\">completion</span>)</span></span><br><span class=\"line\">        &#125;.resume<span class=\"literal\">()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">func did<span class=\"constructor\">FinishGettingWeatherData(<span class=\"params\">data</span>: Data?, <span class=\"params\">response</span>: URLResponse?, <span class=\"params\">error</span>: Error?, <span class=\"params\">completion</span>: CompletionHandler)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> _ = error &#123;</span><br><span class=\"line\">            completion(nil, .failedRequest)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data = data, <span class=\"keyword\">let</span> response = response <span class=\"keyword\">as</span>? HTTPURLResponse &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> response.statusCode<span class=\"operator\"> == </span><span class=\"number\">200</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">let</span> weatherData = <span class=\"keyword\">try</span> <span class=\"constructor\">JSONDecoder()</span>.decode(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">WeatherData</span>.</span></span>self, from: data)</span><br><span class=\"line\">                    completion(weatherData, nil)</span><br><span class=\"line\">                &#125;catch &#123;</span><br><span class=\"line\">                    completion(nil, .invalidResponse)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                completion(nil, .failedRequest)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            completion(nil, .unknown)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其中包括 3 个关键的可变对象： self.urlSession、request 和  completion。我们就需要单独对这 3 个数据进行模拟。<br>模拟结果分为 3 种：</p>\n<ol>\n<li>是否能获取到网络数据。(success)</li>\n<li>获取网络数据失败。 (failedRequest)</li>\n<li>无效的网络响应。 (invalidResponse)</li>\n</ol>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>创建好 Tests 文件。在此需要引入头文件来确保可以调用工程中的对象方法 <code>@testable import Sky</code>。在测试文件中，测试方法总是以 test 作为方法名的开头。</p>\n<h4 id=\"测试能否获取网络数据\"><a href=\"#测试能否获取网络数据\" class=\"headerlink\" title=\"测试能否获取网络数据\"></a>测试能否获取网络数据</h4><p>想要测试能否获取数据，self.urlSession 就不需要特意模拟，request 可以任意给经纬度进行拼接。最后获取 completion 中的 WeatherData,查看是否拥有数据。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func test<span class=\"constructor\">_weatherDataAt_gets_data()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> expect = expectation(description: <span class=\"string\">&quot;Loading data form \\(API.authenticatedUrl)&quot;</span>)</span><br><span class=\"line\">        var data: WeatherData? = nil</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">WeatherDataManager</span>.</span></span>shared.weather<span class=\"constructor\">DataAt(<span class=\"params\">latitude</span>: 52, <span class=\"params\">longtitude</span>: 100)</span> &#123; (response, error) <span class=\"keyword\">in</span></span><br><span class=\"line\">            data = response</span><br><span class=\"line\">            expect.fulfill<span class=\"literal\">()</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        wait<span class=\"constructor\">ForExpectations(<span class=\"params\">timeout</span>: 5, <span class=\"params\">handler</span>: <span class=\"params\">nil</span>)</span></span><br><span class=\"line\">        <span class=\"constructor\">XCTAssertNotNil(<span class=\"params\">data</span>)</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这里使用 <code>expectation</code> 来进行异步测试，当网络回调结果时候调用 <code>expect.fulfill()</code> 表示异步完成。否则调用 <code>waitForExpectations(timeout: 5, handler: nil)</code> 表明最多等待5秒。最后 <code>XCTAssertNotNil(data)</code> 表明如果 data 为 nil，则测试失败，进入断言。</p>\n<h4 id=\"测试failedRequest\"><a href=\"#测试failedRequest\" class=\"headerlink\" title=\"测试failedRequest\"></a>测试failedRequest</h4><p>为了节省异步获取网络资源花费的时间，需要我们自己构造一个无效的网络响应。为了不影响项目的代码，我们需要自己定一个测试用的 URLSession。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MockURLSession</span>: <span class=\"title\">URLSessionProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> responseData: <span class=\"type\">Data</span>?</span><br><span class=\"line\">    <span class=\"keyword\">var</span> responseHeader: <span class=\"type\">HTTPURLResponse</span>?</span><br><span class=\"line\">    <span class=\"keyword\">var</span> responseError: <span class=\"type\">Error</span>?</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sessionDataTask <span class=\"operator\">=</span> <span class=\"type\">MockURLSessionDataTask</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dataTask</span>(<span class=\"params\">with</span> <span class=\"params\">request</span>: <span class=\"type\">URLRequest</span>, <span class=\"params\">completionHandler</span>: <span class=\"keyword\">@escaping</span> <span class=\"type\">URLSessionProtocol</span>.dataTaskHandler)</span> -&gt; <span class=\"type\">URLSessionDataTaskProcol</span> &#123;</span><br><span class=\"line\">        completionHandler(responseData, responseHeader, responseError)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sessionDataTask</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过构造 MockURLSession 中的请求 responseError 来进行模拟。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func test<span class=\"constructor\">_weatherDataAt_handle_invalid_request()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> session = <span class=\"constructor\">MockURLSession()</span></span><br><span class=\"line\">        session.responseError = <span class=\"constructor\">NSError(<span class=\"params\">domain</span>: <span class=\"string\">&quot;Invalid Requset&quot;</span>, <span class=\"params\">code</span>: 100, <span class=\"params\">userInfo</span>: <span class=\"params\">nil</span>)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> manager = <span class=\"constructor\">WeatherDataManager(<span class=\"params\">baseURL</span>: URL(<span class=\"params\">string</span>: <span class=\"string\">&quot;https://darksky.net&quot;</span>)</span>!, urlSession: session)</span><br><span class=\"line\">        </span><br><span class=\"line\">        var error: DataManagerError? = nil</span><br><span class=\"line\">        manager.weather<span class=\"constructor\">DataAt(<span class=\"params\">latitude</span>: 52, <span class=\"params\">longtitude</span>: 100)</span> &#123; (_, e) <span class=\"keyword\">in</span></span><br><span class=\"line\">            error = e</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"constructor\">XCTAssertEqual(<span class=\"params\">error</span>, DataManagerError.<span class=\"params\">failedRequest</span>)</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"测试invalidResponse\"><a href=\"#测试invalidResponse\" class=\"headerlink\" title=\"测试invalidResponse\"></a>测试invalidResponse</h4><p>和测试 failedRequest 的思路一样，只不过这次我们构造的错误信息应该是状态码 200 而 data 数据错误的情况。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func test<span class=\"constructor\">_weatherDataAt_handle_invalid_response()</span> &#123;</span><br><span class=\"line\">        session.responseHeader = <span class=\"constructor\">HTTPURLResponse(<span class=\"params\">url</span>: URL(<span class=\"params\">string</span>: <span class=\"string\">&quot;https://darksky.net&quot;</span>)</span>!, statusCode: <span class=\"number\">200</span>, httpVersion: nil, headerFields: nil)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = <span class=\"string\">&quot;&#123;&quot;</span>.data(using: .utf8)!</span><br><span class=\"line\">        session.responseData = data</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> manager = <span class=\"constructor\">WeatherDataManager(<span class=\"params\">baseURL</span>: URL(<span class=\"params\">string</span>: <span class=\"string\">&quot;https://darksky.net&quot;</span>)</span>!, urlSession: session)</span><br><span class=\"line\">        </span><br><span class=\"line\">        var error: DataManagerError? = nil</span><br><span class=\"line\">        </span><br><span class=\"line\">        manager.weather<span class=\"constructor\">DataAt(<span class=\"params\">latitude</span>: 52, <span class=\"params\">longtitude</span>: 100)</span> &#123; (_, e) <span class=\"keyword\">in</span></span><br><span class=\"line\">            error = e</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"constructor\">XCTAssertEqual(<span class=\"params\">error</span>, DataManagerError.<span class=\"params\">invalidResponse</span>)</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"性能测试\"><a href=\"#性能测试\" class=\"headerlink\" title=\"性能测试\"></a>性能测试</h4><p>利用 XCTest 中的 <code>measure()</code> 方法进行性能测试。可以直观的观察出方法花费时间。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test_performance</span>()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.measure &#123;</span><br><span class=\"line\">     \t<span class=\"comment\">// Time: 0.003 sec (100% better)</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">100</span> &#123;</span><br><span class=\"line\">           <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"后记-——-2017年12月26日\"><a href=\"#后记-——-2017年12月26日\" class=\"headerlink\" title=\"后记 —— 2017年12月26日\"></a>后记 —— 2017年12月26日</h5><p>尝试在公司的项目上进行单元测试，没想到配置环境就遇到了好多问题，果然是对这个 XCode 工程的配置不是很熟悉啊。由于我的工程项目是以 Swift 为基础，加入 Objective-C 框架进行混编的，而且使用 CocoaPod 进行的配置，所以引入工程遇到了很多问题。幸好还是在网上找到了解决方案，这里就记录一下。</p>\n<h6 id=\"导入-Pods\"><a href=\"#导入-Pods\" class=\"headerlink\" title=\"导入 Pods\"></a>导入 Pods</h6><p>由于新增测试模块，所以在进行测试的使用也会用到 CocoaPod 导入的三方库，所以在 Podfile 文件也需要对测试模块进行配置。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">platform <span class=\"symbol\">:ios</span>, <span class=\"string\">&#x27;8.0&#x27;</span></span><br><span class=\"line\">use_frameworks!</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pods</span></span></span><br><span class=\"line\">    pod <span class=\"string\">&#x27;Alamofire&#x27;</span>, <span class=\"string\">&#x27;~&gt; 4.5.1&#x27;</span></span><br><span class=\"line\">    pod <span class=\"string\">&#x27;SwiftyJSON&#x27;</span>, <span class=\"string\">&#x27;~&gt; 4.0.0&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\">target <span class=\"string\">&#x27;HiDoc&#x27;</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    pods</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">target <span class=\"string\">&#x27;HiDocTests&#x27;</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    pods</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>重新 pod install 的时候回遇到某些文件找不到的情况。这是因为 Tests 其实也是一个工程，依旧需要重新配置 Build Settings 中的 Path。比对原来工程中的 Search Paths 添加到工程中。<img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/XCode%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/SearchPaths.png?raw=true\"><br>别忘了还要修改 <font color=#d13f28><strong>User Header Search Paths</strong></font> !!!<br>有的时候依旧会报找不到文件，还需要修改 Precompile Prefix Header 为 YES。<br>基本的配置已经完成了，在 Tests 文件中引入 <code>@testable import HiDoc</code> 就能够进行引用。但是在实际情况中，我的工程总会报 <code>&quot;CMPopTipView.h&quot; file not found</code>。我查看了一下发现这个文件是由 Pod 导入的第三方库，是在 Objective-C 的 .h 文件中引用的，并没有放入桥接文件中。后来就将这个文件引用放到 .m 文件中就解决了。</p>\n<h6 id=\"进行登录接口单元测试\"><a href=\"#进行登录接口单元测试\" class=\"headerlink\" title=\"进行登录接口单元测试\"></a>进行登录接口单元测试</h6><p>使用测试账号进行登录，创建测试方法。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func test<span class=\"constructor\">_login()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> email = <span class=\"string\">&quot;13600000002&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> password = <span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> expect = expectation(description: <span class=\"string\">&quot;login&quot;</span>)</span><br><span class=\"line\">        var isSuccess = <span class=\"literal\">false</span></span><br><span class=\"line\">        var test = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">HYLoginTool</span>.</span></span>login<span class=\"constructor\">WithPromise(<span class=\"params\">email</span>: <span class=\"params\">email</span>, <span class=\"params\">password</span>: <span class=\"params\">password</span>)</span>.<span class=\"keyword\">then</span> &#123; (result) -&gt; (Void) <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result<span class=\"literal\">[&quot;<span class=\"identifier\">ret</span>&quot;]</span>.stringValue<span class=\"operator\"> == </span><span class=\"string\">&quot;0&quot;</span>) &#123;</span><br><span class=\"line\">                isSuccess = <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                isSuccess = <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            test = result<span class=\"literal\">[&quot;<span class=\"identifier\">error</span>&quot;]</span>.stringValue</span><br><span class=\"line\">            expect.fulfill<span class=\"literal\">()</span></span><br><span class=\"line\">            &#125;.catch &#123; (error) <span class=\"keyword\">in</span></span><br><span class=\"line\">                isSuccess = <span class=\"literal\">false</span></span><br><span class=\"line\">                test = error.localizedDescription</span><br><span class=\"line\">                expect.fulfill<span class=\"literal\">()</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        wait<span class=\"constructor\">ForExpectations(<span class=\"params\">timeout</span>: 10, <span class=\"params\">handler</span>: <span class=\"params\">nil</span>)</span></span><br><span class=\"line\">        <span class=\"constructor\">XCTAssert(<span class=\"params\">isSuccess</span>, <span class=\"params\">test</span>)</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常用判断条件\"><a href=\"#常用判断条件\" class=\"headerlink\" title=\"常用判断条件\"></a>常用判断条件</h4><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"constructor\">XCTFail(<span class=\"params\">format</span>…)</span> 生成一个失败的测试； </span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNil(<span class=\"params\">a1</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>为空判断，a1为空时通过，反之不通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNotNil(<span class=\"params\">a1</span>, <span class=\"params\">format</span>…)</span>不为空判断，a1不为空时通过，反之不通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssert(<span class=\"params\">expression</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>当expression求值为TRUE时通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertTrue(<span class=\"params\">expression</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>当expression求值为TRUE时通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertFalse(<span class=\"params\">expression</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>当expression求值为False时通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertEqualObjects(<span class=\"params\">a1</span>, <span class=\"params\">a2</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>判断相等，<span class=\"literal\">[<span class=\"identifier\">a1</span> <span class=\"identifier\">isEqual</span>:<span class=\"identifier\">a2</span>]</span>值为TRUE时通过，其中一个不为空时，不通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNotEqualObjects(<span class=\"params\">a1</span>, <span class=\"params\">a2</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>判断不等，<span class=\"literal\">[<span class=\"identifier\">a1</span> <span class=\"identifier\">isEqual</span>:<span class=\"identifier\">a2</span>]</span>值为False时通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertEqual(<span class=\"params\">a1</span>, <span class=\"params\">a2</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>判断相等（当a1和a2是 C语言标量、结构体或联合体时使用, 判断的是变量的地址，如果地址相同则返回TRUE，否则返回NO）；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNotEqual(<span class=\"params\">a1</span>, <span class=\"params\">a2</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertEqualWithAccuracy(<span class=\"params\">a1</span>, <span class=\"params\">a2</span>, <span class=\"params\">accuracy</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>判断相等，（double或<span class=\"built_in\">float</span>类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNotEqualWithAccuracy(<span class=\"params\">a1</span>, <span class=\"params\">a2</span>, <span class=\"params\">accuracy</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span> 判断不等，（double或<span class=\"built_in\">float</span>类型）提供一个误差范围，当在误差范围以内不等时通过测试；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertThrows(<span class=\"params\">expression</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>异常测试，当expression发生异常时通过；反之不通过；（很变态） <span class=\"constructor\">XCTAssertThrowsSpecific(<span class=\"params\">expression</span>, <span class=\"params\">specificException</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span> 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertThrowsSpecificNamed(<span class=\"params\">expression</span>, <span class=\"params\">specificException</span>, <span class=\"params\">exception_name</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNoThrow(<span class=\"params\">expression</span>, <span class=\"params\">format</span>…)</span>异常测试，当expression没有发生异常时通过测试；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNoThrowSpecific(<span class=\"params\">expression</span>, <span class=\"params\">specificException</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</span><br><span class=\"line\"><span class=\"constructor\">XCTAssertNoThrowSpecificNamed(<span class=\"params\">expression</span>, <span class=\"params\">specificException</span>, <span class=\"params\">exception_name</span>, <span class=\"params\">format</span><span class=\"operator\">...</span>)</span>异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</span><br></pre></td></tr></table></figure>\n"},{"layout":"swift","title":"fastlane自动打包脚本","date":"2018-03-19T14:31:13.000Z","_content":"\n> Fastlane是麻省理工学院批准的开源项目，可以将Mac、iOS、android项目的自动打包、发布等一系列繁琐的任务自动化。\n\n使用 fastlane 可以极大的节约打包上架的时间。\n<!--- more --->\n#### 准备工作\n关于 fastlane 的安装初始化，就不做说明了，网上很容易搜索到。当环境搭建完成后，我们可以在自己的项目工程中会看到多出来一个 fastlane 的文件。关于打包的配置在这个文件夹里面都可以进行配置。\n\n首先，我们需要使用 fastlane 来完成我们的打包工作，我们需要弄清楚我们脚本的工作流程，简单整理一下需求。\n\n我们需要执行一个脚本，脚本填写我们的<font color=#d13f28>**项目路径**</font>，输入我们想要修改的<font color=#d13f28>**版本号**</font>。然后用时间戳设置项目的<font color=#0277BD>**build号**</font>。在脚本的当前路径创建一个build文件夹，并且在里面创建一个 archive 文件夹用来放置 .xcarive 文件。在 build 文件夹下将打包出来的 ipa 文件放置在以自己 scheme 名命名的文件夹中。\n简单总结下：\n输入： 项目路径、版本号。\n生成：build 号、xcarchive 文件 和 ipa 文件。\n上传：自动上传 ipa 文件到 fir。\n#### 编写脚本\n创建一个 .sh 文件，第一次执行 .sh 文件的时候可能会报 `zsh: permission denied:` 警告。这需要我们允许一下脚本执行权限 `chmod -R 777 XXX.sh`。再次执行不会报错。\n\n我们需要接受第一个参数为路径地址，和第二个参数为版本号。\n\n```\n# 参数传递目标工程 和 版本号\nrootPath=$1\nversion=$2\n```\n然后处理一下当前时间作为 build 号，并获取一下工程文件夹的名称\n\n```\n# 工程名默认与文件夹同名\nproject_name=$(basename $rootPath)\n# scheme 默认与工程名同名\nscheme_name=$project_name\n# 打包时间 设置为 build 号码\nBuildDate=$(date +%Y%m%d%H%M)\n```\n如果需要打包不同的 scheme 可以再对脚本做修改。\n\n接下来需要指定打包输出文件的位置\n\n```\n# 指定项目地址\nworkspace_path=\"$rootPath/$scheme_name.xcworkspace\"\n# 指定输出路径\noutput_path=$(pwd)/build\n# 指定输出归档文件地址\narchive_path=\"$output_path/archive/${scheme_name}_${BuildDate}.xcarchive\"\n# 指定输出ipa地址\nipa_path=\"$output_path/$scheme_name\"\n# 指定输出ipa名称\nipa_name=\"${scheme_name}_${BuildDate}.ipa\"\n```\n\n#### 修改 版本号、build号\n由于我们用到了 fastlan 进行打包，这里就有2个思路来解决修改版本号的问题。第一种就是直接在脚本上找到工程的 Info.plist 文件修改 `CFBundleShortVersionString` 和 `CFBundleVersion` 的值。第二种就是使用 fastlane 的插件修改，在 Fastfile 中安装 versioning 插件来修改。工程目录下执行 `fastlane add_plugin versioning` 安装。注：之前使用 fastlane 自带的修改方法，由于苹果有设置，所以修改不了，使用插件才可以。\n\n##### 直接修改 Info.plist 文件\n需要找到 Info.plist 位置直接进行修改。可能每个工程的 Info.plist 文件位置不同，所以需要指定一下文件位置\n\n```\n# Info.plist 文件路径\ninfoPath=$project_name/Info.plist\necho \"============================ 正在 修改Build ============================\"\ncd $rootPath\n/usr/libexec/PlistBuddy -c \"Set :CFBundleShortVersionString $version\" $infoPath || exit\n/usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $BuildDate\" $infoPath || exit\necho \"!!!!!!!!!!!!!!!!!!!!!!!!!!!! 修改 完成 ${version} ${BuildDate}   !!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n```\n##### 在 Fastfile 修改\n插件安装成功后，可以使用插件的方法来修改。\n\n```\n# 修改版本号和build号函数 例: version:1.1.1 build:123\n\tdef prepare_version(options)\n    increment_build_number_in_plist(\n  \t\t# target: [target_name],\n  \t\tbuild_number: options[:build]\n  \t)\n  \tincrement_version_number_in_plist(\n    \tversion_number: options[:version]\n    ) \n```\n这样调用的时候只需要将 version 和 bild 作为参数传递过去就可以。\n\n#### 打包成 ipa 文件\n打包使用 fastlane 很方便，需要自定义 lane，将参数传递过去就可以。\n在 Fastfile 文件中编写\n\n```\ndesc \"打包上传到 Fir\"\n\tlane :fir do |options|\n\t\t#sigh(adhoc:true)  #如果要使用ad-hoc打包, 则需打开此项配置\n\t\tgym(scheme: options[:scheme],\n\t\t# workspace: \"xxx.xcworkspace\", # 可省略\n\t\tconfiguration: \"Debug\",         # Debug or Release\n\t\tarchive_path: options[:archive_path],\n\t\tclean: true,                 #清空上次打包信息\n\t\toutput_directory: options[:outPath],\n\t\toutput_name: options[:ipa_name],\n\t\texport_method:\"development\"  # app-store, ad-hoc, package, enterprise, development, developer-id\n\t\t)\t\n\t\tfirim(firim_api_token:\"554c539d32252425f397dbf39e1831d9\")\n\t\t#使用自动证书管理\n\t\t# enable_automatic_code_signing(path: \"HUIpaTest.xcodeproj\")\n\tend\n```\n在脚本中只需要将关键信息传递过去就可以了调用了\n\n```\necho \"============================ 开始打包 ipa 文件 ============================\"\necho ${scheme_name}\nfastlane fir scheme:\"${scheme_name}\" \\\n\t\t\t buildDate:\"${BuildDate}\" \\\n\t\t\t archive_path:\"${archive_path}\" \\\n\t\t\t outPath:\"${ipa_path}\" \\\n\t\t\t ipa_name:\"${ipa_name}\"\necho \"!!!!!!!!!!!!!!!!!!!!!!!!!!!! 打包完成 !!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n```\n至此，打包的流程就可以实现了，我们会在脚本的根目录下看到一个 build 文件夹，其中包括一个 archive 文件夹，用来存放 .xcarchive 文件。还有一个以 scheme 命名的文件夹，其中放置我们上传需要的 ipa 文件。\n\n#### 上传 ipa 文件到 \n很多时候需要将打包出来的 ipa 文件进行发布测试，这些工作脚本也可以替我们完成。这里还是有2个方法来处理，第一种还是使用 fir 提供的脚本指令直径进行上传。第二种就是使用 fastlane 的插件来完成。注：安装指令为 `fastlane add_plugin firim`。\n##### sh 指令上传\n指令很简单，安装好 fir 的脚本环境后，直接使用。\n\n```\n上传到fir\necho \"============================ 开始上传 ipa 文件 ============================\"\nfir publish \"${ipa_path}/${ipa_name}\" -T \"${Fir_token}\" -c\necho \"!!!!!!!!!!!!!!!!!!!!!!!!!!!! 上传完成 !!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n```\n##### fastlane 指令\n在 fastfile 文件中直接在打包完成后添加指令即可。\n\n```\n\tfirim(firim_api_token:\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\")\n```\n如果需要上传到 testflight，大概的思路也差不多，不过 fastlane 已经提供了对应的方法，不需要在导入插件了。\n#### 最后\n至此，打包测试脚本就可以使用了。fastlane 还有很多功能需要慢慢去学习掌握，后面如果用到了，再来做一些更新吧。完整的 sh 文件在[这里](https://github.com/hGhostD/Shell/blob/master/ipa%E6%89%93%E5%8C%85/ipa.sh)。\n<br>\n<br>\n> [fastlane 官方网文档](https://docs.fastlane.tools/getting-started/ios/appstore-deployment/)\n> [小团队的自动化发布－Fastlane带来的全自动化部署](https://zhuanlan.zhihu.com/p/23180455)","source":"_posts/fastlane自动打包脚本.md","raw":"---\nlayout: swift\ntitle: fastlane自动打包脚本\ndate: 2018-03-19 22:31:13\ntags:\n- Swift\ncategories: \n- Swift\n---\n\n> Fastlane是麻省理工学院批准的开源项目，可以将Mac、iOS、android项目的自动打包、发布等一系列繁琐的任务自动化。\n\n使用 fastlane 可以极大的节约打包上架的时间。\n<!--- more --->\n#### 准备工作\n关于 fastlane 的安装初始化，就不做说明了，网上很容易搜索到。当环境搭建完成后，我们可以在自己的项目工程中会看到多出来一个 fastlane 的文件。关于打包的配置在这个文件夹里面都可以进行配置。\n\n首先，我们需要使用 fastlane 来完成我们的打包工作，我们需要弄清楚我们脚本的工作流程，简单整理一下需求。\n\n我们需要执行一个脚本，脚本填写我们的<font color=#d13f28>**项目路径**</font>，输入我们想要修改的<font color=#d13f28>**版本号**</font>。然后用时间戳设置项目的<font color=#0277BD>**build号**</font>。在脚本的当前路径创建一个build文件夹，并且在里面创建一个 archive 文件夹用来放置 .xcarive 文件。在 build 文件夹下将打包出来的 ipa 文件放置在以自己 scheme 名命名的文件夹中。\n简单总结下：\n输入： 项目路径、版本号。\n生成：build 号、xcarchive 文件 和 ipa 文件。\n上传：自动上传 ipa 文件到 fir。\n#### 编写脚本\n创建一个 .sh 文件，第一次执行 .sh 文件的时候可能会报 `zsh: permission denied:` 警告。这需要我们允许一下脚本执行权限 `chmod -R 777 XXX.sh`。再次执行不会报错。\n\n我们需要接受第一个参数为路径地址，和第二个参数为版本号。\n\n```\n# 参数传递目标工程 和 版本号\nrootPath=$1\nversion=$2\n```\n然后处理一下当前时间作为 build 号，并获取一下工程文件夹的名称\n\n```\n# 工程名默认与文件夹同名\nproject_name=$(basename $rootPath)\n# scheme 默认与工程名同名\nscheme_name=$project_name\n# 打包时间 设置为 build 号码\nBuildDate=$(date +%Y%m%d%H%M)\n```\n如果需要打包不同的 scheme 可以再对脚本做修改。\n\n接下来需要指定打包输出文件的位置\n\n```\n# 指定项目地址\nworkspace_path=\"$rootPath/$scheme_name.xcworkspace\"\n# 指定输出路径\noutput_path=$(pwd)/build\n# 指定输出归档文件地址\narchive_path=\"$output_path/archive/${scheme_name}_${BuildDate}.xcarchive\"\n# 指定输出ipa地址\nipa_path=\"$output_path/$scheme_name\"\n# 指定输出ipa名称\nipa_name=\"${scheme_name}_${BuildDate}.ipa\"\n```\n\n#### 修改 版本号、build号\n由于我们用到了 fastlan 进行打包，这里就有2个思路来解决修改版本号的问题。第一种就是直接在脚本上找到工程的 Info.plist 文件修改 `CFBundleShortVersionString` 和 `CFBundleVersion` 的值。第二种就是使用 fastlane 的插件修改，在 Fastfile 中安装 versioning 插件来修改。工程目录下执行 `fastlane add_plugin versioning` 安装。注：之前使用 fastlane 自带的修改方法，由于苹果有设置，所以修改不了，使用插件才可以。\n\n##### 直接修改 Info.plist 文件\n需要找到 Info.plist 位置直接进行修改。可能每个工程的 Info.plist 文件位置不同，所以需要指定一下文件位置\n\n```\n# Info.plist 文件路径\ninfoPath=$project_name/Info.plist\necho \"============================ 正在 修改Build ============================\"\ncd $rootPath\n/usr/libexec/PlistBuddy -c \"Set :CFBundleShortVersionString $version\" $infoPath || exit\n/usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $BuildDate\" $infoPath || exit\necho \"!!!!!!!!!!!!!!!!!!!!!!!!!!!! 修改 完成 ${version} ${BuildDate}   !!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n```\n##### 在 Fastfile 修改\n插件安装成功后，可以使用插件的方法来修改。\n\n```\n# 修改版本号和build号函数 例: version:1.1.1 build:123\n\tdef prepare_version(options)\n    increment_build_number_in_plist(\n  \t\t# target: [target_name],\n  \t\tbuild_number: options[:build]\n  \t)\n  \tincrement_version_number_in_plist(\n    \tversion_number: options[:version]\n    ) \n```\n这样调用的时候只需要将 version 和 bild 作为参数传递过去就可以。\n\n#### 打包成 ipa 文件\n打包使用 fastlane 很方便，需要自定义 lane，将参数传递过去就可以。\n在 Fastfile 文件中编写\n\n```\ndesc \"打包上传到 Fir\"\n\tlane :fir do |options|\n\t\t#sigh(adhoc:true)  #如果要使用ad-hoc打包, 则需打开此项配置\n\t\tgym(scheme: options[:scheme],\n\t\t# workspace: \"xxx.xcworkspace\", # 可省略\n\t\tconfiguration: \"Debug\",         # Debug or Release\n\t\tarchive_path: options[:archive_path],\n\t\tclean: true,                 #清空上次打包信息\n\t\toutput_directory: options[:outPath],\n\t\toutput_name: options[:ipa_name],\n\t\texport_method:\"development\"  # app-store, ad-hoc, package, enterprise, development, developer-id\n\t\t)\t\n\t\tfirim(firim_api_token:\"554c539d32252425f397dbf39e1831d9\")\n\t\t#使用自动证书管理\n\t\t# enable_automatic_code_signing(path: \"HUIpaTest.xcodeproj\")\n\tend\n```\n在脚本中只需要将关键信息传递过去就可以了调用了\n\n```\necho \"============================ 开始打包 ipa 文件 ============================\"\necho ${scheme_name}\nfastlane fir scheme:\"${scheme_name}\" \\\n\t\t\t buildDate:\"${BuildDate}\" \\\n\t\t\t archive_path:\"${archive_path}\" \\\n\t\t\t outPath:\"${ipa_path}\" \\\n\t\t\t ipa_name:\"${ipa_name}\"\necho \"!!!!!!!!!!!!!!!!!!!!!!!!!!!! 打包完成 !!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n```\n至此，打包的流程就可以实现了，我们会在脚本的根目录下看到一个 build 文件夹，其中包括一个 archive 文件夹，用来存放 .xcarchive 文件。还有一个以 scheme 命名的文件夹，其中放置我们上传需要的 ipa 文件。\n\n#### 上传 ipa 文件到 \n很多时候需要将打包出来的 ipa 文件进行发布测试，这些工作脚本也可以替我们完成。这里还是有2个方法来处理，第一种还是使用 fir 提供的脚本指令直径进行上传。第二种就是使用 fastlane 的插件来完成。注：安装指令为 `fastlane add_plugin firim`。\n##### sh 指令上传\n指令很简单，安装好 fir 的脚本环境后，直接使用。\n\n```\n上传到fir\necho \"============================ 开始上传 ipa 文件 ============================\"\nfir publish \"${ipa_path}/${ipa_name}\" -T \"${Fir_token}\" -c\necho \"!!!!!!!!!!!!!!!!!!!!!!!!!!!! 上传完成 !!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n```\n##### fastlane 指令\n在 fastfile 文件中直接在打包完成后添加指令即可。\n\n```\n\tfirim(firim_api_token:\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\")\n```\n如果需要上传到 testflight，大概的思路也差不多，不过 fastlane 已经提供了对应的方法，不需要在导入插件了。\n#### 最后\n至此，打包测试脚本就可以使用了。fastlane 还有很多功能需要慢慢去学习掌握，后面如果用到了，再来做一些更新吧。完整的 sh 文件在[这里](https://github.com/hGhostD/Shell/blob/master/ipa%E6%89%93%E5%8C%85/ipa.sh)。\n<br>\n<br>\n> [fastlane 官方网文档](https://docs.fastlane.tools/getting-started/ios/appstore-deployment/)\n> [小团队的自动化发布－Fastlane带来的全自动化部署](https://zhuanlan.zhihu.com/p/23180455)","slug":"fastlane自动打包脚本","published":1,"updated":"2018-03-20T08:59:54.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyaa000v7sn6as007cow","content":"<blockquote>\n<p>Fastlane是麻省理工学院批准的开源项目，可以将Mac、iOS、android项目的自动打包、发布等一系列繁琐的任务自动化。</p>\n</blockquote>\n<p>使用 fastlane 可以极大的节约打包上架的时间。</p>\n<!--- more --->\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>关于 fastlane 的安装初始化，就不做说明了，网上很容易搜索到。当环境搭建完成后，我们可以在自己的项目工程中会看到多出来一个 fastlane 的文件。关于打包的配置在这个文件夹里面都可以进行配置。</p>\n<p>首先，我们需要使用 fastlane 来完成我们的打包工作，我们需要弄清楚我们脚本的工作流程，简单整理一下需求。</p>\n<p>我们需要执行一个脚本，脚本填写我们的<font color=#d13f28><strong>项目路径</strong></font>，输入我们想要修改的<font color=#d13f28><strong>版本号</strong></font>。然后用时间戳设置项目的<font color=#0277BD><strong>build号</strong></font>。在脚本的当前路径创建一个build文件夹，并且在里面创建一个 archive 文件夹用来放置 .xcarive 文件。在 build 文件夹下将打包出来的 ipa 文件放置在以自己 scheme 名命名的文件夹中。<br>简单总结下：<br>输入： 项目路径、版本号。<br>生成：build 号、xcarchive 文件 和 ipa 文件。<br>上传：自动上传 ipa 文件到 fir。</p>\n<h4 id=\"编写脚本\"><a href=\"#编写脚本\" class=\"headerlink\" title=\"编写脚本\"></a>编写脚本</h4><p>创建一个 .sh 文件，第一次执行 .sh 文件的时候可能会报 <code>zsh: permission denied:</code> 警告。这需要我们允许一下脚本执行权限 <code>chmod -R 777 XXX.sh</code>。再次执行不会报错。</p>\n<p>我们需要接受第一个参数为路径地址，和第二个参数为版本号。</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 参数传递目标工程 和 版本号</span></span><br><span class=\"line\"><span class=\"attr\">rootPath</span>=<span class=\"variable\">$1</span></span><br><span class=\"line\"><span class=\"attr\">version</span>=<span class=\"variable\">$2</span></span><br></pre></td></tr></table></figure>\n<p>然后处理一下当前时间作为 build 号，并获取一下工程文件夹的名称</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 工程名默认与文件夹同名</span></span><br><span class=\"line\"><span class=\"attr\">project_name</span>=$(basename <span class=\"variable\">$rootPath</span>)</span><br><span class=\"line\"><span class=\"comment\"># scheme 默认与工程名同名</span></span><br><span class=\"line\"><span class=\"attr\">scheme_name</span>=<span class=\"variable\">$project_name</span></span><br><span class=\"line\"><span class=\"comment\"># 打包时间 设置为 build 号码</span></span><br><span class=\"line\"><span class=\"attr\">BuildDate</span>=$(date +%Y%m%d%H%M)</span><br></pre></td></tr></table></figure>\n<p>如果需要打包不同的 scheme 可以再对脚本做修改。</p>\n<p>接下来需要指定打包输出文件的位置</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定项目地址</span></span><br><span class=\"line\"><span class=\"attribute\">workspace_path</span>=<span class=\"string\">&quot;<span class=\"variable\">$rootPath</span>/<span class=\"variable\">$scheme_name</span>.xcworkspace&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定输出路径</span></span><br><span class=\"line\"><span class=\"attribute\">output_path</span>=$(pwd)/build</span><br><span class=\"line\"><span class=\"comment\"># 指定输出归档文件地址</span></span><br><span class=\"line\"><span class=\"attribute\">archive_path</span>=<span class=\"string\">&quot;<span class=\"variable\">$output_path</span>/archive/<span class=\"variable\">$&#123;scheme_name&#125;</span>_<span class=\"variable\">$&#123;BuildDate&#125;</span>.xcarchive&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定输出ipa地址</span></span><br><span class=\"line\"><span class=\"attribute\">ipa_path</span>=<span class=\"string\">&quot;<span class=\"variable\">$output_path</span>/<span class=\"variable\">$scheme_name</span>&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定输出ipa名称</span></span><br><span class=\"line\"><span class=\"attribute\">ipa_name</span>=<span class=\"string\">&quot;<span class=\"variable\">$&#123;scheme_name&#125;</span>_<span class=\"variable\">$&#123;BuildDate&#125;</span>.ipa&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"修改-版本号、build号\"><a href=\"#修改-版本号、build号\" class=\"headerlink\" title=\"修改 版本号、build号\"></a>修改 版本号、build号</h4><p>由于我们用到了 fastlan 进行打包，这里就有2个思路来解决修改版本号的问题。第一种就是直接在脚本上找到工程的 Info.plist 文件修改 <code>CFBundleShortVersionString</code> 和 <code>CFBundleVersion</code> 的值。第二种就是使用 fastlane 的插件修改，在 Fastfile 中安装 versioning 插件来修改。工程目录下执行 <code>fastlane add_plugin versioning</code> 安装。注：之前使用 fastlane 自带的修改方法，由于苹果有设置，所以修改不了，使用插件才可以。</p>\n<h5 id=\"直接修改-Info-plist-文件\"><a href=\"#直接修改-Info-plist-文件\" class=\"headerlink\" title=\"直接修改 Info.plist 文件\"></a>直接修改 Info.plist 文件</h5><p>需要找到 Info.plist 位置直接进行修改。可能每个工程的 Info.plist 文件位置不同，所以需要指定一下文件位置</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Info.plist 文件路径</span></span><br><span class=\"line\">infoPath=<span class=\"variable\">$project_name</span>/Info.plist</span><br><span class=\"line\">echo <span class=\"string\">&quot;============================ 正在 修改Build ============================&quot;</span></span><br><span class=\"line\">cd <span class=\"variable\">$rootPath</span></span><br><span class=\"line\"><span class=\"regexp\">/usr/</span>libexec/PlistBuddy -c <span class=\"string\">&quot;Set :CFBundleShortVersionString $version&quot;</span> <span class=\"variable\">$infoPath</span> || <span class=\"keyword\">exit</span></span><br><span class=\"line\"><span class=\"regexp\">/usr/</span>libexec/PlistBuddy -c <span class=\"string\">&quot;Set :CFBundleVersion $BuildDate&quot;</span> <span class=\"variable\">$infoPath</span> || <span class=\"keyword\">exit</span></span><br><span class=\"line\">echo <span class=\"string\">&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!! 修改 完成 $&#123;version&#125; $&#123;BuildDate&#125;   !!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"在-Fastfile-修改\"><a href=\"#在-Fastfile-修改\" class=\"headerlink\" title=\"在 Fastfile 修改\"></a>在 Fastfile 修改</h5><p>插件安装成功后，可以使用插件的方法来修改。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改版本号和build号函数 例: version:1.1.1 build:123</span></span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">prepare_version</span><span class=\"params\">(options)</span></span></span><br><span class=\"line\">    increment_build_number_in_plist(</span><br><span class=\"line\">  \t\t<span class=\"comment\"># target: [target_name],</span></span><br><span class=\"line\">  \t\t<span class=\"symbol\">build_number:</span> options[<span class=\"symbol\">:build</span>]</span><br><span class=\"line\">  \t)</span><br><span class=\"line\">  \tincrement_version_number_in_plist(</span><br><span class=\"line\">    \t<span class=\"symbol\">version_number:</span> options[<span class=\"symbol\">:version</span>]</span><br><span class=\"line\">    ) </span><br></pre></td></tr></table></figure>\n<p>这样调用的时候只需要将 version 和 bild 作为参数传递过去就可以。</p>\n<h4 id=\"打包成-ipa-文件\"><a href=\"#打包成-ipa-文件\" class=\"headerlink\" title=\"打包成 ipa 文件\"></a>打包成 ipa 文件</h4><p>打包使用 fastlane 很方便，需要自定义 lane，将参数传递过去就可以。<br>在 Fastfile 文件中编写</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">desc</span> &quot;打包上传到 Fir&quot;</span><br><span class=\"line\">truelane :fir <span class=\"keyword\">do</span> |<span class=\"keyword\">options</span>|</span><br><span class=\"line\">truetrue#sigh(adhoc:<span class=\"keyword\">true</span>)  #如果要使用ad-hoc打包, 则需打开此项配置</span><br><span class=\"line\">truetruegym(scheme: <span class=\"keyword\">options</span>[:scheme],</span><br><span class=\"line\">truetrue# workspace: &quot;xxx.xcworkspace&quot;, # 可省略</span><br><span class=\"line\">truetrue<span class=\"keyword\">configuration</span>: &quot;Debug&quot;,         # <span class=\"keyword\">Debug</span> <span class=\"keyword\">or</span> <span class=\"keyword\">Release</span></span><br><span class=\"line\">truetruearchive_path: <span class=\"keyword\">options</span>[:archive_path],</span><br><span class=\"line\">truetrueclean: <span class=\"keyword\">true</span>,                 #清空上次打包信息</span><br><span class=\"line\">truetrueoutput_directory: <span class=\"keyword\">options</span>[:outPath],</span><br><span class=\"line\">truetrueoutput_name: <span class=\"keyword\">options</span>[:ipa_name],</span><br><span class=\"line\">truetrueexport_method:&quot;development&quot;  # app-store, ad-hoc, package, enterprise, development, developer-id</span><br><span class=\"line\">truetrue)\t</span><br><span class=\"line\">truetruefirim(firim_api_token:&quot;554c539d32252425f397dbf39e1831d9&quot;)</span><br><span class=\"line\">truetrue#使用自动证书管理</span><br><span class=\"line\">truetrue# enable_automatic_code_signing(<span class=\"type\">path</span>: &quot;HUIpaTest.xcodeproj&quot;)</span><br><span class=\"line\">true<span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>在脚本中只需要将关键信息传递过去就可以了调用了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;============================ 开始打包 ipa 文件 ============================&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;scheme_name&#125;</span></span><br><span class=\"line\">fastlane fir scheme:<span class=\"string\">&quot;<span class=\"variable\">$&#123;scheme_name&#125;</span>&quot;</span> \\</span><br><span class=\"line\">truetruetrue buildDate:<span class=\"string\">&quot;<span class=\"variable\">$&#123;BuildDate&#125;</span>&quot;</span> \\</span><br><span class=\"line\">truetruetrue archive_path:<span class=\"string\">&quot;<span class=\"variable\">$&#123;archive_path&#125;</span>&quot;</span> \\</span><br><span class=\"line\">truetruetrue outPath:<span class=\"string\">&quot;<span class=\"variable\">$&#123;ipa_path&#125;</span>&quot;</span> \\</span><br><span class=\"line\">truetruetrue ipa_name:<span class=\"string\">&quot;<span class=\"variable\">$&#123;ipa_name&#125;</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!! 打包完成 !!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>至此，打包的流程就可以实现了，我们会在脚本的根目录下看到一个 build 文件夹，其中包括一个 archive 文件夹，用来存放 .xcarchive 文件。还有一个以 scheme 命名的文件夹，其中放置我们上传需要的 ipa 文件。</p>\n<h4 id=\"上传-ipa-文件到\"><a href=\"#上传-ipa-文件到\" class=\"headerlink\" title=\"上传 ipa 文件到\"></a>上传 ipa 文件到</h4><p>很多时候需要将打包出来的 ipa 文件进行发布测试，这些工作脚本也可以替我们完成。这里还是有2个方法来处理，第一种还是使用 fir 提供的脚本指令直径进行上传。第二种就是使用 fastlane 的插件来完成。注：安装指令为 <code>fastlane add_plugin firim</code>。</p>\n<h5 id=\"sh-指令上传\"><a href=\"#sh-指令上传\" class=\"headerlink\" title=\"sh 指令上传\"></a>sh 指令上传</h5><p>指令很简单，安装好 fir 的脚本环境后，直接使用。</p>\n<figure class=\"highlight dos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上传到fir</span><br><span class=\"line\"><span class=\"built_in\">echo</span> &quot;============================ 开始上传 ipa 文件 ============================&quot;</span><br><span class=\"line\">fir publish &quot;$&#123;ipa_path&#125;/$&#123;ipa_name&#125;&quot; -T &quot;$&#123;Fir_token&#125;&quot; -c</span><br><span class=\"line\"><span class=\"built_in\">echo</span> &quot;<span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span>! 上传完成 <span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span>!&quot;</span><br></pre></td></tr></table></figure>\n<h5 id=\"fastlane-指令\"><a href=\"#fastlane-指令\" class=\"headerlink\" title=\"fastlane 指令\"></a>fastlane 指令</h5><p>在 fastfile 文件中直接在打包完成后添加指令即可。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">firim</span><span class=\"params\">(firim_api_token:<span class=\"string\">&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>\n<p>如果需要上传到 testflight，大概的思路也差不多，不过 fastlane 已经提供了对应的方法，不需要在导入插件了。</p>\n<h4 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h4><p>至此，打包测试脚本就可以使用了。fastlane 还有很多功能需要慢慢去学习掌握，后面如果用到了，再来做一些更新吧。完整的 sh 文件在<a href=\"https://github.com/hGhostD/Shell/blob/master/ipa%E6%89%93%E5%8C%85/ipa.sh\">这里</a>。<br><br><br><br></p>\n<blockquote>\n<p><a href=\"https://docs.fastlane.tools/getting-started/ios/appstore-deployment/\">fastlane 官方网文档</a><br><a href=\"https://zhuanlan.zhihu.com/p/23180455\">小团队的自动化发布－Fastlane带来的全自动化部署</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Fastlane是麻省理工学院批准的开源项目，可以将Mac、iOS、android项目的自动打包、发布等一系列繁琐的任务自动化。</p>\n</blockquote>\n<p>使用 fastlane 可以极大的节约打包上架的时间。</p>\n<!--- more --->\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>关于 fastlane 的安装初始化，就不做说明了，网上很容易搜索到。当环境搭建完成后，我们可以在自己的项目工程中会看到多出来一个 fastlane 的文件。关于打包的配置在这个文件夹里面都可以进行配置。</p>\n<p>首先，我们需要使用 fastlane 来完成我们的打包工作，我们需要弄清楚我们脚本的工作流程，简单整理一下需求。</p>\n<p>我们需要执行一个脚本，脚本填写我们的<font color=#d13f28><strong>项目路径</strong></font>，输入我们想要修改的<font color=#d13f28><strong>版本号</strong></font>。然后用时间戳设置项目的<font color=#0277BD><strong>build号</strong></font>。在脚本的当前路径创建一个build文件夹，并且在里面创建一个 archive 文件夹用来放置 .xcarive 文件。在 build 文件夹下将打包出来的 ipa 文件放置在以自己 scheme 名命名的文件夹中。<br>简单总结下：<br>输入： 项目路径、版本号。<br>生成：build 号、xcarchive 文件 和 ipa 文件。<br>上传：自动上传 ipa 文件到 fir。</p>\n<h4 id=\"编写脚本\"><a href=\"#编写脚本\" class=\"headerlink\" title=\"编写脚本\"></a>编写脚本</h4><p>创建一个 .sh 文件，第一次执行 .sh 文件的时候可能会报 <code>zsh: permission denied:</code> 警告。这需要我们允许一下脚本执行权限 <code>chmod -R 777 XXX.sh</code>。再次执行不会报错。</p>\n<p>我们需要接受第一个参数为路径地址，和第二个参数为版本号。</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 参数传递目标工程 和 版本号</span></span><br><span class=\"line\"><span class=\"attr\">rootPath</span>=<span class=\"variable\">$1</span></span><br><span class=\"line\"><span class=\"attr\">version</span>=<span class=\"variable\">$2</span></span><br></pre></td></tr></table></figure>\n<p>然后处理一下当前时间作为 build 号，并获取一下工程文件夹的名称</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 工程名默认与文件夹同名</span></span><br><span class=\"line\"><span class=\"attr\">project_name</span>=$(basename <span class=\"variable\">$rootPath</span>)</span><br><span class=\"line\"><span class=\"comment\"># scheme 默认与工程名同名</span></span><br><span class=\"line\"><span class=\"attr\">scheme_name</span>=<span class=\"variable\">$project_name</span></span><br><span class=\"line\"><span class=\"comment\"># 打包时间 设置为 build 号码</span></span><br><span class=\"line\"><span class=\"attr\">BuildDate</span>=$(date +%Y%m%d%H%M)</span><br></pre></td></tr></table></figure>\n<p>如果需要打包不同的 scheme 可以再对脚本做修改。</p>\n<p>接下来需要指定打包输出文件的位置</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 指定项目地址</span></span><br><span class=\"line\"><span class=\"attribute\">workspace_path</span>=<span class=\"string\">&quot;<span class=\"variable\">$rootPath</span>/<span class=\"variable\">$scheme_name</span>.xcworkspace&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定输出路径</span></span><br><span class=\"line\"><span class=\"attribute\">output_path</span>=$(pwd)/build</span><br><span class=\"line\"><span class=\"comment\"># 指定输出归档文件地址</span></span><br><span class=\"line\"><span class=\"attribute\">archive_path</span>=<span class=\"string\">&quot;<span class=\"variable\">$output_path</span>/archive/<span class=\"variable\">$&#123;scheme_name&#125;</span>_<span class=\"variable\">$&#123;BuildDate&#125;</span>.xcarchive&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定输出ipa地址</span></span><br><span class=\"line\"><span class=\"attribute\">ipa_path</span>=<span class=\"string\">&quot;<span class=\"variable\">$output_path</span>/<span class=\"variable\">$scheme_name</span>&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 指定输出ipa名称</span></span><br><span class=\"line\"><span class=\"attribute\">ipa_name</span>=<span class=\"string\">&quot;<span class=\"variable\">$&#123;scheme_name&#125;</span>_<span class=\"variable\">$&#123;BuildDate&#125;</span>.ipa&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"修改-版本号、build号\"><a href=\"#修改-版本号、build号\" class=\"headerlink\" title=\"修改 版本号、build号\"></a>修改 版本号、build号</h4><p>由于我们用到了 fastlan 进行打包，这里就有2个思路来解决修改版本号的问题。第一种就是直接在脚本上找到工程的 Info.plist 文件修改 <code>CFBundleShortVersionString</code> 和 <code>CFBundleVersion</code> 的值。第二种就是使用 fastlane 的插件修改，在 Fastfile 中安装 versioning 插件来修改。工程目录下执行 <code>fastlane add_plugin versioning</code> 安装。注：之前使用 fastlane 自带的修改方法，由于苹果有设置，所以修改不了，使用插件才可以。</p>\n<h5 id=\"直接修改-Info-plist-文件\"><a href=\"#直接修改-Info-plist-文件\" class=\"headerlink\" title=\"直接修改 Info.plist 文件\"></a>直接修改 Info.plist 文件</h5><p>需要找到 Info.plist 位置直接进行修改。可能每个工程的 Info.plist 文件位置不同，所以需要指定一下文件位置</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Info.plist 文件路径</span></span><br><span class=\"line\">infoPath=<span class=\"variable\">$project_name</span>/Info.plist</span><br><span class=\"line\">echo <span class=\"string\">&quot;============================ 正在 修改Build ============================&quot;</span></span><br><span class=\"line\">cd <span class=\"variable\">$rootPath</span></span><br><span class=\"line\"><span class=\"regexp\">/usr/</span>libexec/PlistBuddy -c <span class=\"string\">&quot;Set :CFBundleShortVersionString $version&quot;</span> <span class=\"variable\">$infoPath</span> || <span class=\"keyword\">exit</span></span><br><span class=\"line\"><span class=\"regexp\">/usr/</span>libexec/PlistBuddy -c <span class=\"string\">&quot;Set :CFBundleVersion $BuildDate&quot;</span> <span class=\"variable\">$infoPath</span> || <span class=\"keyword\">exit</span></span><br><span class=\"line\">echo <span class=\"string\">&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!! 修改 完成 $&#123;version&#125; $&#123;BuildDate&#125;   !!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"在-Fastfile-修改\"><a href=\"#在-Fastfile-修改\" class=\"headerlink\" title=\"在 Fastfile 修改\"></a>在 Fastfile 修改</h5><p>插件安装成功后，可以使用插件的方法来修改。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改版本号和build号函数 例: version:1.1.1 build:123</span></span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">prepare_version</span><span class=\"params\">(options)</span></span></span><br><span class=\"line\">    increment_build_number_in_plist(</span><br><span class=\"line\">  \t\t<span class=\"comment\"># target: [target_name],</span></span><br><span class=\"line\">  \t\t<span class=\"symbol\">build_number:</span> options[<span class=\"symbol\">:build</span>]</span><br><span class=\"line\">  \t)</span><br><span class=\"line\">  \tincrement_version_number_in_plist(</span><br><span class=\"line\">    \t<span class=\"symbol\">version_number:</span> options[<span class=\"symbol\">:version</span>]</span><br><span class=\"line\">    ) </span><br></pre></td></tr></table></figure>\n<p>这样调用的时候只需要将 version 和 bild 作为参数传递过去就可以。</p>\n<h4 id=\"打包成-ipa-文件\"><a href=\"#打包成-ipa-文件\" class=\"headerlink\" title=\"打包成 ipa 文件\"></a>打包成 ipa 文件</h4><p>打包使用 fastlane 很方便，需要自定义 lane，将参数传递过去就可以。<br>在 Fastfile 文件中编写</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">desc</span> &quot;打包上传到 Fir&quot;</span><br><span class=\"line\">truelane :fir <span class=\"keyword\">do</span> |<span class=\"keyword\">options</span>|</span><br><span class=\"line\">truetrue#sigh(adhoc:<span class=\"keyword\">true</span>)  #如果要使用ad-hoc打包, 则需打开此项配置</span><br><span class=\"line\">truetruegym(scheme: <span class=\"keyword\">options</span>[:scheme],</span><br><span class=\"line\">truetrue# workspace: &quot;xxx.xcworkspace&quot;, # 可省略</span><br><span class=\"line\">truetrue<span class=\"keyword\">configuration</span>: &quot;Debug&quot;,         # <span class=\"keyword\">Debug</span> <span class=\"keyword\">or</span> <span class=\"keyword\">Release</span></span><br><span class=\"line\">truetruearchive_path: <span class=\"keyword\">options</span>[:archive_path],</span><br><span class=\"line\">truetrueclean: <span class=\"keyword\">true</span>,                 #清空上次打包信息</span><br><span class=\"line\">truetrueoutput_directory: <span class=\"keyword\">options</span>[:outPath],</span><br><span class=\"line\">truetrueoutput_name: <span class=\"keyword\">options</span>[:ipa_name],</span><br><span class=\"line\">truetrueexport_method:&quot;development&quot;  # app-store, ad-hoc, package, enterprise, development, developer-id</span><br><span class=\"line\">truetrue)\t</span><br><span class=\"line\">truetruefirim(firim_api_token:&quot;554c539d32252425f397dbf39e1831d9&quot;)</span><br><span class=\"line\">truetrue#使用自动证书管理</span><br><span class=\"line\">truetrue# enable_automatic_code_signing(<span class=\"type\">path</span>: &quot;HUIpaTest.xcodeproj&quot;)</span><br><span class=\"line\">true<span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>在脚本中只需要将关键信息传递过去就可以了调用了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;============================ 开始打包 ipa 文件 ============================&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"variable\">$&#123;scheme_name&#125;</span></span><br><span class=\"line\">fastlane fir scheme:<span class=\"string\">&quot;<span class=\"variable\">$&#123;scheme_name&#125;</span>&quot;</span> \\</span><br><span class=\"line\">truetruetrue buildDate:<span class=\"string\">&quot;<span class=\"variable\">$&#123;BuildDate&#125;</span>&quot;</span> \\</span><br><span class=\"line\">truetruetrue archive_path:<span class=\"string\">&quot;<span class=\"variable\">$&#123;archive_path&#125;</span>&quot;</span> \\</span><br><span class=\"line\">truetruetrue outPath:<span class=\"string\">&quot;<span class=\"variable\">$&#123;ipa_path&#125;</span>&quot;</span> \\</span><br><span class=\"line\">truetruetrue ipa_name:<span class=\"string\">&quot;<span class=\"variable\">$&#123;ipa_name&#125;</span>&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!! 打包完成 !!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span></span><br></pre></td></tr></table></figure>\n<p>至此，打包的流程就可以实现了，我们会在脚本的根目录下看到一个 build 文件夹，其中包括一个 archive 文件夹，用来存放 .xcarchive 文件。还有一个以 scheme 命名的文件夹，其中放置我们上传需要的 ipa 文件。</p>\n<h4 id=\"上传-ipa-文件到\"><a href=\"#上传-ipa-文件到\" class=\"headerlink\" title=\"上传 ipa 文件到\"></a>上传 ipa 文件到</h4><p>很多时候需要将打包出来的 ipa 文件进行发布测试，这些工作脚本也可以替我们完成。这里还是有2个方法来处理，第一种还是使用 fir 提供的脚本指令直径进行上传。第二种就是使用 fastlane 的插件来完成。注：安装指令为 <code>fastlane add_plugin firim</code>。</p>\n<h5 id=\"sh-指令上传\"><a href=\"#sh-指令上传\" class=\"headerlink\" title=\"sh 指令上传\"></a>sh 指令上传</h5><p>指令很简单，安装好 fir 的脚本环境后，直接使用。</p>\n<figure class=\"highlight dos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上传到fir</span><br><span class=\"line\"><span class=\"built_in\">echo</span> &quot;============================ 开始上传 ipa 文件 ============================&quot;</span><br><span class=\"line\">fir publish &quot;$&#123;ipa_path&#125;/$&#123;ipa_name&#125;&quot; -T &quot;$&#123;Fir_token&#125;&quot; -c</span><br><span class=\"line\"><span class=\"built_in\">echo</span> &quot;<span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span>! 上传完成 <span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span><span class=\"variable\">!!!</span>!&quot;</span><br></pre></td></tr></table></figure>\n<h5 id=\"fastlane-指令\"><a href=\"#fastlane-指令\" class=\"headerlink\" title=\"fastlane 指令\"></a>fastlane 指令</h5><p>在 fastfile 文件中直接在打包完成后添加指令即可。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">firim</span><span class=\"params\">(firim_api_token:<span class=\"string\">&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>\n<p>如果需要上传到 testflight，大概的思路也差不多，不过 fastlane 已经提供了对应的方法，不需要在导入插件了。</p>\n<h4 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h4><p>至此，打包测试脚本就可以使用了。fastlane 还有很多功能需要慢慢去学习掌握，后面如果用到了，再来做一些更新吧。完整的 sh 文件在<a href=\"https://github.com/hGhostD/Shell/blob/master/ipa%E6%89%93%E5%8C%85/ipa.sh\">这里</a>。<br><br><br><br></p>\n<blockquote>\n<p><a href=\"https://docs.fastlane.tools/getting-started/ios/appstore-deployment/\">fastlane 官方网文档</a><br><a href=\"https://zhuanlan.zhihu.com/p/23180455\">小团队的自动化发布－Fastlane带来的全自动化部署</a></p>\n</blockquote>\n"},{"layout":"待续","title":"hexo 指令","date":"2019-02-24T12:18:05.000Z","_content":"#### 记录 hexo 常用指令\n\n##### hexo 安装\n\n关于搭建和环境 npm 安装就不做过多说明，可以再[官网](https://hexo.io/zh-cn/)上查到相内容。\n<!--- more --->\n##### 创建文件\n\n```\n$ hexo new [layout] <title>\n```\n\n新建一篇文章。如果没有设置 `layout` 的话，默认使用 [_config.yml](https://hexo.io/zh-cn/docs/configuration) 中的 `default_layout` 参数代替。如果标题包含空格的话，请使用引号括起来。\n\n##### 发布草稿\n$ hexo server\n启动服务器。默认情况下，访问网址为： http://localhost:4000/。\n\n选项\t描述\n-p, --port\t重设端口\n-s, --static\t只使用静态文件\n-l, --log\t启动日记记录，使用覆盖记录格式\n\n##### 生产\n\n```\n$ hexo generate\n```\n\n生成静态文件。\n\n| 选项             | 描述                   |\n| ---------------- | ---------------------- |\n| `-d`, `--deploy` | 文件生成后立即部署网站 |\n| `-w`, `--watch`  | 监视文件变动           |\n\n该命令可以简写为\n\n```\n$ hexo g\n```\n\n##### 部署\n\n```\n$ hexo publish [layout] <filename>\n```\n\n该命令可以简写为：\n\n```\n$ hexo d\n```","source":"_posts/hexo 指令.md","raw":"---\nlayout: 待续\ntitle: hexo 指令\ndate: 2019-02-24 20:18:05\ntags: \n- 待续\ncategories: \n- 待续\n---\n#### 记录 hexo 常用指令\n\n##### hexo 安装\n\n关于搭建和环境 npm 安装就不做过多说明，可以再[官网](https://hexo.io/zh-cn/)上查到相内容。\n<!--- more --->\n##### 创建文件\n\n```\n$ hexo new [layout] <title>\n```\n\n新建一篇文章。如果没有设置 `layout` 的话，默认使用 [_config.yml](https://hexo.io/zh-cn/docs/configuration) 中的 `default_layout` 参数代替。如果标题包含空格的话，请使用引号括起来。\n\n##### 发布草稿\n$ hexo server\n启动服务器。默认情况下，访问网址为： http://localhost:4000/。\n\n选项\t描述\n-p, --port\t重设端口\n-s, --static\t只使用静态文件\n-l, --log\t启动日记记录，使用覆盖记录格式\n\n##### 生产\n\n```\n$ hexo generate\n```\n\n生成静态文件。\n\n| 选项             | 描述                   |\n| ---------------- | ---------------------- |\n| `-d`, `--deploy` | 文件生成后立即部署网站 |\n| `-w`, `--watch`  | 监视文件变动           |\n\n该命令可以简写为\n\n```\n$ hexo g\n```\n\n##### 部署\n\n```\n$ hexo publish [layout] <filename>\n```\n\n该命令可以简写为：\n\n```\n$ hexo d\n```","slug":"hexo 指令","published":1,"updated":"2019-02-27T14:24:05.051Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyac000y7sn66ynhdqte","content":"<h4 id=\"记录-hexo-常用指令\"><a href=\"#记录-hexo-常用指令\" class=\"headerlink\" title=\"记录 hexo 常用指令\"></a>记录 hexo 常用指令</h4><h5 id=\"hexo-安装\"><a href=\"#hexo-安装\" class=\"headerlink\" title=\"hexo 安装\"></a>hexo 安装</h5><p>关于搭建和环境 npm 安装就不做过多说明，可以再<a href=\"https://hexo.io/zh-cn/\">官网</a>上查到相内容。</p>\n<!--- more --->\n<h5 id=\"创建文件\"><a href=\"#创建文件\" class=\"headerlink\" title=\"创建文件\"></a>创建文件</h5><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo <span class=\"keyword\">new</span> [layout] &lt;<span class=\"built_in\">title</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href=\"https://hexo.io/zh-cn/docs/configuration\">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>\n<h5 id=\"发布草稿\"><a href=\"#发布草稿\" class=\"headerlink\" title=\"发布草稿\"></a>发布草稿</h5><p>$ hexo server<br>启动服务器。默认情况下，访问网址为： <a href=\"http://localhost:4000/%E3%80%82\">http://localhost:4000/。</a></p>\n<p>选项    描述<br>-p, –port    重设端口<br>-s, –static    只使用静态文件<br>-l, –log    启动日记记录，使用覆盖记录格式</p>\n<h5 id=\"生产\"><a href=\"#生产\" class=\"headerlink\" title=\"生产\"></a>生产</h5><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo <span class=\"keyword\">generate</span></span><br></pre></td></tr></table></figure>\n\n<p>生成静态文件。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>-d</code>, <code>--deploy</code></td>\n<td>文件生成后立即部署网站</td>\n</tr>\n<tr>\n<td><code>-w</code>, <code>--watch</code></td>\n<td>监视文件变动</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>hexo g</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h5><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo publish [layout] <span class=\"tag\">&lt;<span class=\"name\">filename</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>该命令可以简写为：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>hexo d</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"记录-hexo-常用指令\"><a href=\"#记录-hexo-常用指令\" class=\"headerlink\" title=\"记录 hexo 常用指令\"></a>记录 hexo 常用指令</h4><h5 id=\"hexo-安装\"><a href=\"#hexo-安装\" class=\"headerlink\" title=\"hexo 安装\"></a>hexo 安装</h5><p>关于搭建和环境 npm 安装就不做过多说明，可以再<a href=\"https://hexo.io/zh-cn/\">官网</a>上查到相内容。</p>\n<!--- more --->\n<h5 id=\"创建文件\"><a href=\"#创建文件\" class=\"headerlink\" title=\"创建文件\"></a>创建文件</h5><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo <span class=\"keyword\">new</span> [layout] &lt;<span class=\"built_in\">title</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href=\"https://hexo.io/zh-cn/docs/configuration\">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>\n<h5 id=\"发布草稿\"><a href=\"#发布草稿\" class=\"headerlink\" title=\"发布草稿\"></a>发布草稿</h5><p>$ hexo server<br>启动服务器。默认情况下，访问网址为： <a href=\"http://localhost:4000/%E3%80%82\">http://localhost:4000/。</a></p>\n<p>选项    描述<br>-p, –port    重设端口<br>-s, –static    只使用静态文件<br>-l, –log    启动日记记录，使用覆盖记录格式</p>\n<h5 id=\"生产\"><a href=\"#生产\" class=\"headerlink\" title=\"生产\"></a>生产</h5><figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo <span class=\"keyword\">generate</span></span><br></pre></td></tr></table></figure>\n\n<p>生成静态文件。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>-d</code>, <code>--deploy</code></td>\n<td>文件生成后立即部署网站</td>\n</tr>\n<tr>\n<td><code>-w</code>, <code>--watch</code></td>\n<td>监视文件变动</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>hexo g</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h5><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo publish [layout] <span class=\"tag\">&lt;<span class=\"name\">filename</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>该命令可以简写为：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>hexo d</span><br></pre></td></tr></table></figure>"},{"layout":"《Swift 进阶》读书笔记","title":"《Swift 进阶》读书笔记","date":"2017-12-18T09:26:04.000Z","_content":"\tSwift 既是一门高层级语言，又是一门低层级语言。Swift 是一门多范式语言。 \n\n使用 Swift 也有一段时间了，这本书作为一门进阶用书写的十分优秀，翻译也十分浅显易懂。把学到内容作为笔记记录下来，也方便以后查看。\n<!---more--->\n##### 第一章 介绍\n这一章倒是并没有介绍太过深奥的内容，知识介绍了一些对 Swift 语言的整体印象，以及在使用过程中经常会遇到的术语，这些和其他编程语言都是通用的，就不一一列举出来了。就列出一些平常自己不知道的内容了。\n             \n> 在程序语言的论文里，`==` 有时候被称为结构相等，而 `===` 则被称为**指针相等**或者**引用相等**。\n\n高阶函数：\n> 如果一个函数接受别的函数作为参数，或者一个函数的返回值是函数，那么这样的函数就叫作**高阶函数**。\n\n##### 第二章 内建集合类型\n###### reduce\n**运算符也是函数**\n所以:\n`let sum = fibs.reduce(0) { totle, num in totle + num}`\n完全等价于\n`let sum = fibs.reduce(0, +)`\nreduce 的具体实现是:\n\n```\nextension Array {\n    func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) -> Result) -> Result {\n        var result = initialResult\n        for x in self {\n            result = try nextPartialResult(result, x)\n        }\n        return result\n    }\n}\n```\n###### flatMap\nflatMap 和 map 类似，但是它们直接的区别是 faltMap 返回的是另一个数组，而不是单独的元素。\nflatMap 的具体实现是:\n\n```\nextension Array {\n    public func flatMap<SegmentOfResult : Sequence>(\n        _ transform: (Element) throws -> SegmentOfResult\n        ) rethrows -> [SegmentOfResult.Element] {\n        var result: [SegmentOfResult.Element] = []\n        for element in self {\n            result.append(contentsOf: try transform(element))\n        }\n        return result\n    }\n}\n```\n###### 常用的函数参数\n* map 和 flatMap 对元素进行变换。\n* filter 元素是否应该被包含在结果中。\n* reduce 将元素河滨到一个总和的值中。\n* sequence 序列中下一个元素。\n* forEach 对每一个元素进行操作。\n* sort 对元素进行排序。\n* index, contains 元素符合某个条件。\n* min max 元素中最小值和最大值。\n* starts 元素是否相等。\n* split 切割元素。\n\n##### 第三章 集合类型协议\n\n###### Sequence\nSequence 协议是集合类型结构中的基础。一个序列（Sequence）代表的是一系列具有相同类型的值，你可以对这些值进行迭代。遍历一个序列最简单的方式是使用 for 循环。\n这个函数有两个版本：\n第一种方法：`sequence(first: next:)`。将使用第一个参数的值作为序列的首个元素，并使用 `next` 参数传入的闭包生成序列的后续元素。这里先定义一个 next 的闭包，用来生成一个随机数且要比前一个数小，到零为止:\n\n```\nlet calculte = { (previouse: UInt32) -> UInt32? in\n    let newValue = arc4random_uniform(previouse)\n    guard newValue > 0 else {return nil}\n    return newValue\n}\n```\n定义好这个 next 闭包，就能够直接构建好一个 Sequence。`let randomNumbsers = sequence(first: 100, next: calculte)`。其中定义好初始化数据 first 为 100。\n`Array(randomNumbsers) // [100, 56, 9, 6, 3, 2]`\n第二个方法：`sequence(state: next:)`。因为它可以在两次 next 闭包被调用之间保存任意的可变状态，所以它更强大一些。这里我们通过它来创建一个[斐波那契序列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97):\n\n```\nlet calculte2 = { (state: inout (Int, Int)) -> Int? in\n    let result = state.0\n    state = (state.1, state.0 + state.1)\n    return result\n}\n```\n定义初始数据为一个元组 (0, 1)，再将这个元素传递给 next，然后取出元组中第一个数据，并修改元组数据:第一个数据 -> 第二个数据，第二个数据 -> 第一个与第二个数据的和。\n`fibs = sequence(state: (0, 1), next: calculte2)`。\n`Array(fibs.prefix(10)) // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]`\n> `sequence(first:next:)` 和 `sequence(state:next:)` 的返回值类型是 `UnfoldSequence`。这个术语来自函数式编程，在函数式编程中，这种操作为成为展开(unfold)。sequence 是和 reduce 对应的(在函数式编程中 reduce 有常被叫做 fold)。reduce 将一个序列缩减(或者说折叠)为一个单一的返回值，而 sequence 则将一个单一的值展开形成一个序列。\n\n##### 第四章 可选值\n###### if let\n使用 `if let` 来进行可选绑定(optional binding)要比使用 `switch` 语句稍好一些。\n\n```\nlet urlString = \"http://www.objc.io/logo.png\"\nif let url = URL(string: urlString),\n\tlet data = try? Data(contentsOf: url),\n\tlet image = UIImage(data: data) \n{\t\n\tlet view = UIImageView(image: image)\n\tPlaygroundPage.current.liveView = view\n}\n```\n\n###### while let\n`while let ` 和 `if let` 非常相似，它代表一个当遇到 nil 时终止的循环。注意，一旦条件为 false，循环就会停止(也许你错误地认为 where 条件会像 filter 那样工作，其实不然)。\n\n###### nil 合并运算\n`??` 和 Objective-C 中的 `?:` 十分相似，但是它们还是有不同的地方，那就是 Swift 中的可选值**不是指针**。 \n我们可以对 Array 进行扩展来包含检查索引值是否在数组边界内:\n\n```\nextension Array {\n    subscript(safe idx: Int) -> Element? {\n        return idx < endIndex ? self[idx] : nil\n    }\n}\n// 现在就可以这样写\narray[safe: 5] ?? 0 // 0\n```\n合并操作也能够进行链接----如果有多个可能的可选值，并且想要选择第一个非 nil 的值，则可以将他们按顺序合并:\n\n```\nlet i: Int? = nil\nlet j: Int? = nil\nlet k: Int? = 42\ni ?? j ?? k // Optional(42)\n\n```\n\n##### 第五章 结构体和类\n###### 值类型\n结构体(和枚举)是**值类型**，而类是**引用类型**。因为结构体只有一个持有者，所以它不可能造成引用循环。而对于类和函数这样的引用类型，我们需要特别小心，避免造成引用循环的问题。\n如果想要将两个 Point 相加，则可以对 + 操作符进行重载。在方法中，我们可以将成员相加，并返回新的 Point:\n\n```\nfunc +(lhs: Point, rhs: Point) -> Point {\n\treturn Point(x: lhs.x + rhs.x, y: lhs.y + rhs.y)\n}\nscreen.origin + Point(x: 10, y: 10) // (x: 20, y: 20)\n```\n如果想要改变 self，或者嵌套的(比如 self.origin.x)任何属性，就需要将方法标记为 `mutating`。只有使用了这个关键字，我们才能在方法内部进行改变。\nSwift 的结构体一般被存储在栈上，而非堆上。如果结构体太大，它也会被存储在堆上。\n###### 捕获列表\n为了打破循环引用，需要保证闭包不去引用视图。通过使用**捕获列表**并将捕获变量 view 标记为 weak 或者 unowned 来达到这个目的。\n\n```\nwindow?onRotate = { [weak view] in\n\tprint(\"We now also need to update the view: \\(view)\")\n}\n```\n\n##### 第六章 函数\n\n1. 函数可以像 Int 或者 String 那样被赋值给变量，也可以作为另一个函数的输入参数，或者另一个函数的返回值来使用。\n2. 函数能够**捕获**存在于其作用域之外的变量。\n3. 有两种方法可以创建函数，一种是使用 func 关键字，另一种是 { }。在 Swift 中，后一种被称为闭包表达式。\n\n##### 第七章 字符串\n这一章主要介绍了 String，但是书中还是介绍 Swift3.0 的版本，而最新的 Swift4.0 对此更改了很多。我就直接记录一些 String 的变化吧。\nString 现在已经更改为一个集合类型了，所以现在直接废除了 `.characters` 这个属性了。其他的操作也都遵循了 Collection 协议了。\n\n##### 第八章 错误处理\n###### 抛出和捕获\nSwift 没有使用返回 Result 的方法来表示失败，而是将方法标记为 throws。Result 是作用于类型上的，而 throw 是作用于函数的。\n\n如果我们想要在错误中给出更多的信息，则可以使用带有关联值的枚举。(任何遵循 Error 协议的类型都可以被抛出函数作为错误抛出。)\n\n```\nenum LoginError: Error {\n    case wrongUser\n    case passwordError(user: String)\n}\n```\n> 你可以指定你的函数可能抛出的具体错误类型，但这并不是必须的。因为现在 Swift 中的**错误类型是无类型的**，所以通过文档来说明你的函数会抛出怎样的错误是非常重要的。\n\n```\nfunc login(user: String, passWord: String) throws {\n    if user.isEmpty {\n        throw LoginError.wrongUser\n    }\n    \n    if passWord != \"123\" {\n        throw LoginError.passwordError(user: user)\n    }\n    print(\"登录成功！！！\")\n}\n\ndo {\n    try login(user: \"hu\", passWord: \"111\")\n}catch LoginError.wrongUser {\n    print(\"用户不存在\")\n}catch LoginError.passwordError(let id) {\n    print(\"\\(id)的密码输入错误！！！\") // hu的密码输入错误！！！\n}catch {\n    print(error.localizedDescription)\n}\n```\n可以看出，在 Swift 中，我们虽然把这块内容叫做“异常”，但是实质上它更多的还是“错误”而非真正意义上的异常。\n\n###### 使用 defer 进行清理\nSwift 中的 `defer` ，围绕的代码块一定会在函数返回时被执行（就是相当于在 return 之后再执行一些操作）。\n`defer` 类似于其他语言的 `finally`，但是 `defer` 不只是用于错误处理，可以将 `defer` 放在代码块的任意地方。\n如果同一个作用域里使用多个 `defer`，那么它们会被逆序执行，可以把它想象成一个栈。用意在于，比如我们开启数据库然后连接，用 `defer` 就能自然的先关闭连接，再关闭数据库。\n\n###### 高阶函数和错误\n刚才我们就已经看出来了，在实际使用 Swift 中，经常能遇到网络请求这种异步处理错误的情况，如果按照刚才的写法，就是使用 `throws` 来捕获异常进行处理，这并不是一个好的方法，通常也不建议这么使用，因为可选值和 `Result` 作用于类型，而 `throws` 只对函数类型起效。将一个函数标注为 throws 意味着这个函数可能会失败。所以为了解决异步处理产生的问题，默认的规则就是定义 `Result<T>`：\n\n```\nenum Result<T> {\n    case success(T)\n    case fail(LoginError)\n}\n```\nResult 是异步错误处理的正确道路。不好的地方在于，如果你已经在同步函数中使用 throws 了，那么再在异步函数中转为使用 Result 将会在两种接口之间导入差异。\n\n##### 第九章 泛型\n###### 使用闭包对行为进行参数化\n对 Array 进行判断，标准库中提供的 `contains` 是这么做的:\n\n```\nextension Sequence {\n\t/// 根据序列是否包含满足给定断言的元素，返回一个布尔值。\n\tfunc contains(where predicate: (Iterator.Element) throws -> Bool)\n\t\treturn -> Bool\n}\n```\n也就是说，它接受一个函数，这个函数从序列中取出一个元素，并对他进行一些检查。\n\n```\nlet isEven = { $0 % 2 == 0}\n(0...5).contains(where: isEven)  // ture\n[1,3,99].contains(where: isEven) //false\n```\n\n###### 使用泛型进行代码设计\n让我们来写一些与网络服务交互的函数。比如获取用户列表的数据，并解析为 User 数据类型。\n\n```\nfunc loadUsers(callback: ([User]?) -> ()) {\n\tlet usersURL = webserviceURL.appendingPathComponent(\"/users\")\n\tlet data = try? Data(contentsOf: usersURL)\n\tlet json = data.flatMap {\n\t\ttry? JSONSerialization.jsonObject(with: $0, options: [])\n\t}\n\tlet users = (json as? [Any]).flatMap { jsonObject in\n\t\tjsonObject.flatMap(User.init)\n\t}\n\tcallback(users)\n}\n```\n这个函数会发生三种错误情况：URL 加载可能失败，JOSN解析可能失败，通过 JSON 数组构建用户对象也可能失败。\n\n现在，如果我们想要写一个相同的函数来加载其他资源。比如，我们需要一个加载博客文章的函数，它看起来是这样的：\n\n`func loadBlogPosts(callback: ([BlogPost])? -> ())`\n此函数的实现和前面的用户函数几乎相同。相比于复制和粘贴，将函数中 User 相关的部分提取出来，将其他部分进行重用，会是更好的方式。\n##### 第十章 协议\n###### 面向协议编程和协议拓展\n假设我们有一个只有 String 属性的 结构体 Obj\n\n```\nstruct Obj {\n    var value = \"0\"\n    mutating func add(str: String) {\n        let num = Int(value) ?? 0 + 1\n        value = String(num)\n    }\n}\n```\n现在我们想通过协议的方式对一个 String 进行加一操作：\n\n```\nprotocol transform {\n    mutating func addOne(str: String)\n}\n```\n\n只要对结构体 Obj 进拓展并具体实现加一方法，来满足协议:\n\n```\nextension Obj: transform {\n    mutating func addOne(str: String) {\n        let n1 = Int(str) ?? 0\n        let n2 = Int(value) ?? 0\n        let tmp = n1 + n2\n        value = String(tmp)\n    }\n}\n```\n现在只需要假设 content 是满足协议的，就可以实现独立的方法：\n\n```\nvar content: transform = Obj(value: \"1\")\ncontent.addOne(str: \"2\") \t\t// Obj(value: \"3\")\n```\n除此之外，同样可以通过协议拓展的方式。\n###### 协议内幕\n当我们通过协议类型创建一个变量时，这个变量会被包装到一个叫存在容器的盒子中。\n使用泛型参数确实要比使用协议类型高效的多。通过使用泛型参数，可以避免隐式的泛型封装。\n\n```\n// 隐式打包\nfunc printProtocol(array: [CustomStringConvertible]) {\n\tprint(array)\n}\n// 没有打包\nfunc printGeneric<A: CustomStringConvertible>(array: [A]) {\n\tprint(array)\n}\n```","source":"_posts/《Swift 进阶》读书笔记.md","raw":"---\nlayout: 《Swift 进阶》读书笔记\ntitle: 《Swift 进阶》读书笔记\ndate: 2017-12-18 17:26:04\ntags: \n- Swift\n- 读书\ncategories: \n- Swift\n---\n\tSwift 既是一门高层级语言，又是一门低层级语言。Swift 是一门多范式语言。 \n\n使用 Swift 也有一段时间了，这本书作为一门进阶用书写的十分优秀，翻译也十分浅显易懂。把学到内容作为笔记记录下来，也方便以后查看。\n<!---more--->\n##### 第一章 介绍\n这一章倒是并没有介绍太过深奥的内容，知识介绍了一些对 Swift 语言的整体印象，以及在使用过程中经常会遇到的术语，这些和其他编程语言都是通用的，就不一一列举出来了。就列出一些平常自己不知道的内容了。\n             \n> 在程序语言的论文里，`==` 有时候被称为结构相等，而 `===` 则被称为**指针相等**或者**引用相等**。\n\n高阶函数：\n> 如果一个函数接受别的函数作为参数，或者一个函数的返回值是函数，那么这样的函数就叫作**高阶函数**。\n\n##### 第二章 内建集合类型\n###### reduce\n**运算符也是函数**\n所以:\n`let sum = fibs.reduce(0) { totle, num in totle + num}`\n完全等价于\n`let sum = fibs.reduce(0, +)`\nreduce 的具体实现是:\n\n```\nextension Array {\n    func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) -> Result) -> Result {\n        var result = initialResult\n        for x in self {\n            result = try nextPartialResult(result, x)\n        }\n        return result\n    }\n}\n```\n###### flatMap\nflatMap 和 map 类似，但是它们直接的区别是 faltMap 返回的是另一个数组，而不是单独的元素。\nflatMap 的具体实现是:\n\n```\nextension Array {\n    public func flatMap<SegmentOfResult : Sequence>(\n        _ transform: (Element) throws -> SegmentOfResult\n        ) rethrows -> [SegmentOfResult.Element] {\n        var result: [SegmentOfResult.Element] = []\n        for element in self {\n            result.append(contentsOf: try transform(element))\n        }\n        return result\n    }\n}\n```\n###### 常用的函数参数\n* map 和 flatMap 对元素进行变换。\n* filter 元素是否应该被包含在结果中。\n* reduce 将元素河滨到一个总和的值中。\n* sequence 序列中下一个元素。\n* forEach 对每一个元素进行操作。\n* sort 对元素进行排序。\n* index, contains 元素符合某个条件。\n* min max 元素中最小值和最大值。\n* starts 元素是否相等。\n* split 切割元素。\n\n##### 第三章 集合类型协议\n\n###### Sequence\nSequence 协议是集合类型结构中的基础。一个序列（Sequence）代表的是一系列具有相同类型的值，你可以对这些值进行迭代。遍历一个序列最简单的方式是使用 for 循环。\n这个函数有两个版本：\n第一种方法：`sequence(first: next:)`。将使用第一个参数的值作为序列的首个元素，并使用 `next` 参数传入的闭包生成序列的后续元素。这里先定义一个 next 的闭包，用来生成一个随机数且要比前一个数小，到零为止:\n\n```\nlet calculte = { (previouse: UInt32) -> UInt32? in\n    let newValue = arc4random_uniform(previouse)\n    guard newValue > 0 else {return nil}\n    return newValue\n}\n```\n定义好这个 next 闭包，就能够直接构建好一个 Sequence。`let randomNumbsers = sequence(first: 100, next: calculte)`。其中定义好初始化数据 first 为 100。\n`Array(randomNumbsers) // [100, 56, 9, 6, 3, 2]`\n第二个方法：`sequence(state: next:)`。因为它可以在两次 next 闭包被调用之间保存任意的可变状态，所以它更强大一些。这里我们通过它来创建一个[斐波那契序列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97):\n\n```\nlet calculte2 = { (state: inout (Int, Int)) -> Int? in\n    let result = state.0\n    state = (state.1, state.0 + state.1)\n    return result\n}\n```\n定义初始数据为一个元组 (0, 1)，再将这个元素传递给 next，然后取出元组中第一个数据，并修改元组数据:第一个数据 -> 第二个数据，第二个数据 -> 第一个与第二个数据的和。\n`fibs = sequence(state: (0, 1), next: calculte2)`。\n`Array(fibs.prefix(10)) // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]`\n> `sequence(first:next:)` 和 `sequence(state:next:)` 的返回值类型是 `UnfoldSequence`。这个术语来自函数式编程，在函数式编程中，这种操作为成为展开(unfold)。sequence 是和 reduce 对应的(在函数式编程中 reduce 有常被叫做 fold)。reduce 将一个序列缩减(或者说折叠)为一个单一的返回值，而 sequence 则将一个单一的值展开形成一个序列。\n\n##### 第四章 可选值\n###### if let\n使用 `if let` 来进行可选绑定(optional binding)要比使用 `switch` 语句稍好一些。\n\n```\nlet urlString = \"http://www.objc.io/logo.png\"\nif let url = URL(string: urlString),\n\tlet data = try? Data(contentsOf: url),\n\tlet image = UIImage(data: data) \n{\t\n\tlet view = UIImageView(image: image)\n\tPlaygroundPage.current.liveView = view\n}\n```\n\n###### while let\n`while let ` 和 `if let` 非常相似，它代表一个当遇到 nil 时终止的循环。注意，一旦条件为 false，循环就会停止(也许你错误地认为 where 条件会像 filter 那样工作，其实不然)。\n\n###### nil 合并运算\n`??` 和 Objective-C 中的 `?:` 十分相似，但是它们还是有不同的地方，那就是 Swift 中的可选值**不是指针**。 \n我们可以对 Array 进行扩展来包含检查索引值是否在数组边界内:\n\n```\nextension Array {\n    subscript(safe idx: Int) -> Element? {\n        return idx < endIndex ? self[idx] : nil\n    }\n}\n// 现在就可以这样写\narray[safe: 5] ?? 0 // 0\n```\n合并操作也能够进行链接----如果有多个可能的可选值，并且想要选择第一个非 nil 的值，则可以将他们按顺序合并:\n\n```\nlet i: Int? = nil\nlet j: Int? = nil\nlet k: Int? = 42\ni ?? j ?? k // Optional(42)\n\n```\n\n##### 第五章 结构体和类\n###### 值类型\n结构体(和枚举)是**值类型**，而类是**引用类型**。因为结构体只有一个持有者，所以它不可能造成引用循环。而对于类和函数这样的引用类型，我们需要特别小心，避免造成引用循环的问题。\n如果想要将两个 Point 相加，则可以对 + 操作符进行重载。在方法中，我们可以将成员相加，并返回新的 Point:\n\n```\nfunc +(lhs: Point, rhs: Point) -> Point {\n\treturn Point(x: lhs.x + rhs.x, y: lhs.y + rhs.y)\n}\nscreen.origin + Point(x: 10, y: 10) // (x: 20, y: 20)\n```\n如果想要改变 self，或者嵌套的(比如 self.origin.x)任何属性，就需要将方法标记为 `mutating`。只有使用了这个关键字，我们才能在方法内部进行改变。\nSwift 的结构体一般被存储在栈上，而非堆上。如果结构体太大，它也会被存储在堆上。\n###### 捕获列表\n为了打破循环引用，需要保证闭包不去引用视图。通过使用**捕获列表**并将捕获变量 view 标记为 weak 或者 unowned 来达到这个目的。\n\n```\nwindow?onRotate = { [weak view] in\n\tprint(\"We now also need to update the view: \\(view)\")\n}\n```\n\n##### 第六章 函数\n\n1. 函数可以像 Int 或者 String 那样被赋值给变量，也可以作为另一个函数的输入参数，或者另一个函数的返回值来使用。\n2. 函数能够**捕获**存在于其作用域之外的变量。\n3. 有两种方法可以创建函数，一种是使用 func 关键字，另一种是 { }。在 Swift 中，后一种被称为闭包表达式。\n\n##### 第七章 字符串\n这一章主要介绍了 String，但是书中还是介绍 Swift3.0 的版本，而最新的 Swift4.0 对此更改了很多。我就直接记录一些 String 的变化吧。\nString 现在已经更改为一个集合类型了，所以现在直接废除了 `.characters` 这个属性了。其他的操作也都遵循了 Collection 协议了。\n\n##### 第八章 错误处理\n###### 抛出和捕获\nSwift 没有使用返回 Result 的方法来表示失败，而是将方法标记为 throws。Result 是作用于类型上的，而 throw 是作用于函数的。\n\n如果我们想要在错误中给出更多的信息，则可以使用带有关联值的枚举。(任何遵循 Error 协议的类型都可以被抛出函数作为错误抛出。)\n\n```\nenum LoginError: Error {\n    case wrongUser\n    case passwordError(user: String)\n}\n```\n> 你可以指定你的函数可能抛出的具体错误类型，但这并不是必须的。因为现在 Swift 中的**错误类型是无类型的**，所以通过文档来说明你的函数会抛出怎样的错误是非常重要的。\n\n```\nfunc login(user: String, passWord: String) throws {\n    if user.isEmpty {\n        throw LoginError.wrongUser\n    }\n    \n    if passWord != \"123\" {\n        throw LoginError.passwordError(user: user)\n    }\n    print(\"登录成功！！！\")\n}\n\ndo {\n    try login(user: \"hu\", passWord: \"111\")\n}catch LoginError.wrongUser {\n    print(\"用户不存在\")\n}catch LoginError.passwordError(let id) {\n    print(\"\\(id)的密码输入错误！！！\") // hu的密码输入错误！！！\n}catch {\n    print(error.localizedDescription)\n}\n```\n可以看出，在 Swift 中，我们虽然把这块内容叫做“异常”，但是实质上它更多的还是“错误”而非真正意义上的异常。\n\n###### 使用 defer 进行清理\nSwift 中的 `defer` ，围绕的代码块一定会在函数返回时被执行（就是相当于在 return 之后再执行一些操作）。\n`defer` 类似于其他语言的 `finally`，但是 `defer` 不只是用于错误处理，可以将 `defer` 放在代码块的任意地方。\n如果同一个作用域里使用多个 `defer`，那么它们会被逆序执行，可以把它想象成一个栈。用意在于，比如我们开启数据库然后连接，用 `defer` 就能自然的先关闭连接，再关闭数据库。\n\n###### 高阶函数和错误\n刚才我们就已经看出来了，在实际使用 Swift 中，经常能遇到网络请求这种异步处理错误的情况，如果按照刚才的写法，就是使用 `throws` 来捕获异常进行处理，这并不是一个好的方法，通常也不建议这么使用，因为可选值和 `Result` 作用于类型，而 `throws` 只对函数类型起效。将一个函数标注为 throws 意味着这个函数可能会失败。所以为了解决异步处理产生的问题，默认的规则就是定义 `Result<T>`：\n\n```\nenum Result<T> {\n    case success(T)\n    case fail(LoginError)\n}\n```\nResult 是异步错误处理的正确道路。不好的地方在于，如果你已经在同步函数中使用 throws 了，那么再在异步函数中转为使用 Result 将会在两种接口之间导入差异。\n\n##### 第九章 泛型\n###### 使用闭包对行为进行参数化\n对 Array 进行判断，标准库中提供的 `contains` 是这么做的:\n\n```\nextension Sequence {\n\t/// 根据序列是否包含满足给定断言的元素，返回一个布尔值。\n\tfunc contains(where predicate: (Iterator.Element) throws -> Bool)\n\t\treturn -> Bool\n}\n```\n也就是说，它接受一个函数，这个函数从序列中取出一个元素，并对他进行一些检查。\n\n```\nlet isEven = { $0 % 2 == 0}\n(0...5).contains(where: isEven)  // ture\n[1,3,99].contains(where: isEven) //false\n```\n\n###### 使用泛型进行代码设计\n让我们来写一些与网络服务交互的函数。比如获取用户列表的数据，并解析为 User 数据类型。\n\n```\nfunc loadUsers(callback: ([User]?) -> ()) {\n\tlet usersURL = webserviceURL.appendingPathComponent(\"/users\")\n\tlet data = try? Data(contentsOf: usersURL)\n\tlet json = data.flatMap {\n\t\ttry? JSONSerialization.jsonObject(with: $0, options: [])\n\t}\n\tlet users = (json as? [Any]).flatMap { jsonObject in\n\t\tjsonObject.flatMap(User.init)\n\t}\n\tcallback(users)\n}\n```\n这个函数会发生三种错误情况：URL 加载可能失败，JOSN解析可能失败，通过 JSON 数组构建用户对象也可能失败。\n\n现在，如果我们想要写一个相同的函数来加载其他资源。比如，我们需要一个加载博客文章的函数，它看起来是这样的：\n\n`func loadBlogPosts(callback: ([BlogPost])? -> ())`\n此函数的实现和前面的用户函数几乎相同。相比于复制和粘贴，将函数中 User 相关的部分提取出来，将其他部分进行重用，会是更好的方式。\n##### 第十章 协议\n###### 面向协议编程和协议拓展\n假设我们有一个只有 String 属性的 结构体 Obj\n\n```\nstruct Obj {\n    var value = \"0\"\n    mutating func add(str: String) {\n        let num = Int(value) ?? 0 + 1\n        value = String(num)\n    }\n}\n```\n现在我们想通过协议的方式对一个 String 进行加一操作：\n\n```\nprotocol transform {\n    mutating func addOne(str: String)\n}\n```\n\n只要对结构体 Obj 进拓展并具体实现加一方法，来满足协议:\n\n```\nextension Obj: transform {\n    mutating func addOne(str: String) {\n        let n1 = Int(str) ?? 0\n        let n2 = Int(value) ?? 0\n        let tmp = n1 + n2\n        value = String(tmp)\n    }\n}\n```\n现在只需要假设 content 是满足协议的，就可以实现独立的方法：\n\n```\nvar content: transform = Obj(value: \"1\")\ncontent.addOne(str: \"2\") \t\t// Obj(value: \"3\")\n```\n除此之外，同样可以通过协议拓展的方式。\n###### 协议内幕\n当我们通过协议类型创建一个变量时，这个变量会被包装到一个叫存在容器的盒子中。\n使用泛型参数确实要比使用协议类型高效的多。通过使用泛型参数，可以避免隐式的泛型封装。\n\n```\n// 隐式打包\nfunc printProtocol(array: [CustomStringConvertible]) {\n\tprint(array)\n}\n// 没有打包\nfunc printGeneric<A: CustomStringConvertible>(array: [A]) {\n\tprint(array)\n}\n```","slug":"《Swift 进阶》读书笔记","published":1,"updated":"2018-01-15T09:19:37.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyaf00137sn66gr61iax","content":"<pre><code>Swift 既是一门高层级语言，又是一门低层级语言。Swift 是一门多范式语言。 \n</code></pre>\n<p>使用 Swift 也有一段时间了，这本书作为一门进阶用书写的十分优秀，翻译也十分浅显易懂。把学到内容作为笔记记录下来，也方便以后查看。</p>\n<!---more--->\n<h5 id=\"第一章-介绍\"><a href=\"#第一章-介绍\" class=\"headerlink\" title=\"第一章 介绍\"></a>第一章 介绍</h5><p>这一章倒是并没有介绍太过深奥的内容，知识介绍了一些对 Swift 语言的整体印象，以及在使用过程中经常会遇到的术语，这些和其他编程语言都是通用的，就不一一列举出来了。就列出一些平常自己不知道的内容了。</p>\n<blockquote>\n<p>在程序语言的论文里，<code>==</code> 有时候被称为结构相等，而 <code>===</code> 则被称为<strong>指针相等</strong>或者<strong>引用相等</strong>。</p>\n</blockquote>\n<p>高阶函数：</p>\n<blockquote>\n<p>如果一个函数接受别的函数作为参数，或者一个函数的返回值是函数，那么这样的函数就叫作<strong>高阶函数</strong>。</p>\n</blockquote>\n<h5 id=\"第二章-内建集合类型\"><a href=\"#第二章-内建集合类型\" class=\"headerlink\" title=\"第二章 内建集合类型\"></a>第二章 内建集合类型</h5><h6 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h6><p><strong>运算符也是函数</strong><br>所以:<br><code>let sum = fibs.reduce(0) &#123; totle, num in totle + num&#125;</code><br>完全等价于<br><code>let sum = fibs.reduce(0, +)</code><br>reduce 的具体实现是:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reduce</span>&lt;<span class=\"type\">Result</span>&gt;(<span class=\"keyword\">_</span> <span class=\"params\">initialResult</span>: <span class=\"type\">Result</span>, <span class=\"keyword\">_</span> <span class=\"params\">nextPartialResult</span>: (<span class=\"type\">Result</span>, <span class=\"type\">Element</span>) -&gt; <span class=\"type\">Result</span>)</span> -&gt; <span class=\"type\">Result</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result <span class=\"operator\">=</span> initialResult</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">            result <span class=\"operator\">=</span> <span class=\"keyword\">try</span> nextPartialResult(result, x)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"flatMap\"><a href=\"#flatMap\" class=\"headerlink\" title=\"flatMap\"></a>flatMap</h6><p>flatMap 和 map 类似，但是它们直接的区别是 faltMap 返回的是另一个数组，而不是单独的元素。<br>flatMap 的具体实现是:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flatMap</span>&lt;<span class=\"type\">SegmentOfResult</span> : <span class=\"type\">Sequence</span>&gt;(</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">_</span> <span class=\"params\">transform</span>: (<span class=\"type\">Element</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">SegmentOfResult</span></span></span><br><span class=\"line\"><span class=\"function\">        )</span> <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">SegmentOfResult</span>.<span class=\"type\">Element</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result: [<span class=\"type\">SegmentOfResult</span>.<span class=\"type\">Element</span>] <span class=\"operator\">=</span> []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">            result.append(contentsOf: <span class=\"keyword\">try</span> transform(element))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"常用的函数参数\"><a href=\"#常用的函数参数\" class=\"headerlink\" title=\"常用的函数参数\"></a>常用的函数参数</h6><ul>\n<li>map 和 flatMap 对元素进行变换。</li>\n<li>filter 元素是否应该被包含在结果中。</li>\n<li>reduce 将元素河滨到一个总和的值中。</li>\n<li>sequence 序列中下一个元素。</li>\n<li>forEach 对每一个元素进行操作。</li>\n<li>sort 对元素进行排序。</li>\n<li>index, contains 元素符合某个条件。</li>\n<li>min max 元素中最小值和最大值。</li>\n<li>starts 元素是否相等。</li>\n<li>split 切割元素。</li>\n</ul>\n<h5 id=\"第三章-集合类型协议\"><a href=\"#第三章-集合类型协议\" class=\"headerlink\" title=\"第三章 集合类型协议\"></a>第三章 集合类型协议</h5><h6 id=\"Sequence\"><a href=\"#Sequence\" class=\"headerlink\" title=\"Sequence\"></a>Sequence</h6><p>Sequence 协议是集合类型结构中的基础。一个序列（Sequence）代表的是一系列具有相同类型的值，你可以对这些值进行迭代。遍历一个序列最简单的方式是使用 for 循环。<br>这个函数有两个版本：<br>第一种方法：<code>sequence(first: next:)</code>。将使用第一个参数的值作为序列的首个元素，并使用 <code>next</code> 参数传入的闭包生成序列的后续元素。这里先定义一个 next 的闭包，用来生成一个随机数且要比前一个数小，到零为止:</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let calculte = &#123; (previouse: <span class=\"type\">UInt32</span>) -&gt; UInt32? <span class=\"keyword\">in</span></span><br><span class=\"line\">    let <span class=\"keyword\">new</span><span class=\"type\">Value</span> = arc4random_uniform(previouse)</span><br><span class=\"line\">    guard <span class=\"keyword\">new</span><span class=\"type\">Value</span> &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;<span class=\"keyword\">return</span> nil&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span><span class=\"type\">Value</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义好这个 next 闭包，就能够直接构建好一个 Sequence。<code>let randomNumbsers = sequence(first: 100, next: calculte)</code>。其中定义好初始化数据 first 为 100。<br><code>Array(randomNumbsers) // [100, 56, 9, 6, 3, 2]</code><br>第二个方法：<code>sequence(state: next:)</code>。因为它可以在两次 next 闭包被调用之间保存任意的可变状态，所以它更强大一些。这里我们通过它来创建一个<a href=\"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97\">斐波那契序列</a>:</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let calculte2 = &#123; (<span class=\"keyword\">state</span>: inout (Int, Int)) -&gt; Int? <span class=\"keyword\">in</span></span><br><span class=\"line\">    let result = <span class=\"keyword\">state</span>.<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">state</span> = (<span class=\"keyword\">state</span>.<span class=\"number\">1</span>, <span class=\"keyword\">state</span>.<span class=\"number\">0</span> + <span class=\"keyword\">state</span>.<span class=\"number\">1</span>)</span><br><span class=\"line\">    return result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义初始数据为一个元组 (0, 1)，再将这个元素传递给 next，然后取出元组中第一个数据，并修改元组数据:第一个数据 -&gt; 第二个数据，第二个数据 -&gt; 第一个与第二个数据的和。<br><code>fibs = sequence(state: (0, 1), next: calculte2)</code>。<br><code>Array(fibs.prefix(10)) // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</code></p>\n<blockquote>\n<p><code>sequence(first:next:)</code> 和 <code>sequence(state:next:)</code> 的返回值类型是 <code>UnfoldSequence</code>。这个术语来自函数式编程，在函数式编程中，这种操作为成为展开(unfold)。sequence 是和 reduce 对应的(在函数式编程中 reduce 有常被叫做 fold)。reduce 将一个序列缩减(或者说折叠)为一个单一的返回值，而 sequence 则将一个单一的值展开形成一个序列。</p>\n</blockquote>\n<h5 id=\"第四章-可选值\"><a href=\"#第四章-可选值\" class=\"headerlink\" title=\"第四章 可选值\"></a>第四章 可选值</h5><h6 id=\"if-let\"><a href=\"#if-let\" class=\"headerlink\" title=\"if let\"></a>if let</h6><p>使用 <code>if let</code> 来进行可选绑定(optional binding)要比使用 <code>switch</code> 语句稍好一些。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> urlString = <span class=\"string\">&quot;http://www.objc.io/logo.png&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> url = <span class=\"constructor\">URL(<span class=\"params\">string</span>: <span class=\"params\">urlString</span>)</span>,</span><br><span class=\"line\">true<span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span>? <span class=\"constructor\">Data(<span class=\"params\">contentsOf</span>: <span class=\"params\">url</span>)</span>,</span><br><span class=\"line\">true<span class=\"keyword\">let</span> image = <span class=\"constructor\">UIImage(<span class=\"params\">data</span>: <span class=\"params\">data</span>)</span> </span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">true<span class=\"keyword\">let</span> view = <span class=\"constructor\">UIImageView(<span class=\"params\">image</span>: <span class=\"params\">image</span>)</span></span><br><span class=\"line\">true<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">PlaygroundPage</span>.</span></span>current.liveView = view</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"while-let\"><a href=\"#while-let\" class=\"headerlink\" title=\"while let\"></a>while let</h6><p><code>while let </code> 和 <code>if let</code> 非常相似，它代表一个当遇到 nil 时终止的循环。注意，一旦条件为 false，循环就会停止(也许你错误地认为 where 条件会像 filter 那样工作，其实不然)。</p>\n<h6 id=\"nil-合并运算\"><a href=\"#nil-合并运算\" class=\"headerlink\" title=\"nil 合并运算\"></a>nil 合并运算</h6><p><code>??</code> 和 Objective-C 中的 <code>?:</code> 十分相似，但是它们还是有不同的地方，那就是 Swift 中的可选值<strong>不是指针</strong>。<br>我们可以对 Array 进行扩展来包含检查索引值是否在数组边界内:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">subscript</span>(<span class=\"params\">safe</span> <span class=\"params\">idx</span>: <span class=\"type\">Int</span>)</span> -&gt; <span class=\"type\">Element</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> idx <span class=\"operator\">&lt;</span> endIndex <span class=\"operator\">?</span> <span class=\"keyword\">self</span>[idx] : <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 现在就可以这样写</span></span><br><span class=\"line\">array[safe: <span class=\"number\">5</span>] <span class=\"operator\">??</span> <span class=\"number\">0</span> <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<p>合并操作也能够进行链接—-如果有多个可能的可选值，并且想要选择第一个非 nil 的值，则可以将他们按顺序合并:</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i: <span class=\"built_in\">Int</span>? = nil</span><br><span class=\"line\"><span class=\"keyword\">let</span> j: <span class=\"built_in\">Int</span>? = nil</span><br><span class=\"line\"><span class=\"keyword\">let</span> k: <span class=\"built_in\">Int</span>? = <span class=\"number\">42</span></span><br><span class=\"line\">i ?? j ?? k <span class=\"comment\">// Optional(42)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"第五章-结构体和类\"><a href=\"#第五章-结构体和类\" class=\"headerlink\" title=\"第五章 结构体和类\"></a>第五章 结构体和类</h5><h6 id=\"值类型\"><a href=\"#值类型\" class=\"headerlink\" title=\"值类型\"></a>值类型</h6><p>结构体(和枚举)是<strong>值类型</strong>，而类是<strong>引用类型</strong>。因为结构体只有一个持有者，所以它不可能造成引用循环。而对于类和函数这样的引用类型，我们需要特别小心，避免造成引用循环的问题。<br>如果想要将两个 Point 相加，则可以对 + 操作符进行重载。在方法中，我们可以将成员相加，并返回新的 Point:</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func +(lhs: Point, rhs: Point) -&gt; Point &#123;</span><br><span class=\"line\">truereturn <span class=\"constructor\">Point(<span class=\"params\">x</span>: <span class=\"params\">lhs</span>.<span class=\"params\">x</span> + <span class=\"params\">rhs</span>.<span class=\"params\">x</span>, <span class=\"params\">y</span>: <span class=\"params\">lhs</span>.<span class=\"params\">y</span> + <span class=\"params\">rhs</span>.<span class=\"params\">y</span>)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">screen.origin + <span class=\"constructor\">Point(<span class=\"params\">x</span>: 10, <span class=\"params\">y</span>: 10)</span> <span class=\"comment\">// (x: 20, y: 20)</span></span><br></pre></td></tr></table></figure>\n<p>如果想要改变 self，或者嵌套的(比如 self.origin.x)任何属性，就需要将方法标记为 <code>mutating</code>。只有使用了这个关键字，我们才能在方法内部进行改变。<br>Swift 的结构体一般被存储在栈上，而非堆上。如果结构体太大，它也会被存储在堆上。</p>\n<h6 id=\"捕获列表\"><a href=\"#捕获列表\" class=\"headerlink\" title=\"捕获列表\"></a>捕获列表</h6><p>为了打破循环引用，需要保证闭包不去引用视图。通过使用<strong>捕获列表</strong>并将捕获变量 view 标记为 weak 或者 unowned 来达到这个目的。</p>\n<figure class=\"highlight sas\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">window</span>?onRotate = &#123; [weak <span class=\"meta\">view</span>] <span class=\"meta\">in</span></span><br><span class=\"line\">truep<span class=\"meta\">rint(</span><span class=\"string\">&quot;We now also need to update the view: \\(view)&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"第六章-函数\"><a href=\"#第六章-函数\" class=\"headerlink\" title=\"第六章 函数\"></a>第六章 函数</h5><ol>\n<li>函数可以像 Int 或者 String 那样被赋值给变量，也可以作为另一个函数的输入参数，或者另一个函数的返回值来使用。</li>\n<li>函数能够<strong>捕获</strong>存在于其作用域之外的变量。</li>\n<li>有两种方法可以创建函数，一种是使用 func 关键字，另一种是 { }。在 Swift 中，后一种被称为闭包表达式。</li>\n</ol>\n<h5 id=\"第七章-字符串\"><a href=\"#第七章-字符串\" class=\"headerlink\" title=\"第七章 字符串\"></a>第七章 字符串</h5><p>这一章主要介绍了 String，但是书中还是介绍 Swift3.0 的版本，而最新的 Swift4.0 对此更改了很多。我就直接记录一些 String 的变化吧。<br>String 现在已经更改为一个集合类型了，所以现在直接废除了 <code>.characters</code> 这个属性了。其他的操作也都遵循了 Collection 协议了。</p>\n<h5 id=\"第八章-错误处理\"><a href=\"#第八章-错误处理\" class=\"headerlink\" title=\"第八章 错误处理\"></a>第八章 错误处理</h5><h6 id=\"抛出和捕获\"><a href=\"#抛出和捕获\" class=\"headerlink\" title=\"抛出和捕获\"></a>抛出和捕获</h6><p>Swift 没有使用返回 Result 的方法来表示失败，而是将方法标记为 throws。Result 是作用于类型上的，而 throw 是作用于函数的。</p>\n<p>如果我们想要在错误中给出更多的信息，则可以使用带有关联值的枚举。(任何遵循 Error 协议的类型都可以被抛出函数作为错误抛出。)</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> LoginError: <span class=\"built_in\">Error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> wrongUser</span><br><span class=\"line\">    <span class=\"keyword\">case</span> passwordError(user: <span class=\"built_in\">String</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>你可以指定你的函数可能抛出的具体错误类型，但这并不是必须的。因为现在 Swift 中的<strong>错误类型是无类型的</strong>，所以通过文档来说明你的函数会抛出怎样的错误是非常重要的。</p>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">login</span>(<span class=\"params\">user</span>: <span class=\"type\">String</span>, <span class=\"params\">passWord</span>: <span class=\"type\">String</span>)</span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> user.isEmpty &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"type\">LoginError</span>.wrongUser</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> passWord <span class=\"operator\">!=</span> <span class=\"string\">&quot;123&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"type\">LoginError</span>.passwordError(user: user)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;登录成功！！！&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> login(user: <span class=\"string\">&quot;hu&quot;</span>, passWord: <span class=\"string\">&quot;111&quot;</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> <span class=\"type\">LoginError</span>.wrongUser &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;用户不存在&quot;</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> <span class=\"type\">LoginError</span>.passwordError(<span class=\"keyword\">let</span> id) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;<span class=\"subst\">\\(id)</span>的密码输入错误！！！&quot;</span>) <span class=\"comment\">// hu的密码输入错误！！！</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(error.localizedDescription)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，在 Swift 中，我们虽然把这块内容叫做“异常”，但是实质上它更多的还是“错误”而非真正意义上的异常。</p>\n<h6 id=\"使用-defer-进行清理\"><a href=\"#使用-defer-进行清理\" class=\"headerlink\" title=\"使用 defer 进行清理\"></a>使用 defer 进行清理</h6><p>Swift 中的 <code>defer</code> ，围绕的代码块一定会在函数返回时被执行（就是相当于在 return 之后再执行一些操作）。<br><code>defer</code> 类似于其他语言的 <code>finally</code>，但是 <code>defer</code> 不只是用于错误处理，可以将 <code>defer</code> 放在代码块的任意地方。<br>如果同一个作用域里使用多个 <code>defer</code>，那么它们会被逆序执行，可以把它想象成一个栈。用意在于，比如我们开启数据库然后连接，用 <code>defer</code> 就能自然的先关闭连接，再关闭数据库。</p>\n<h6 id=\"高阶函数和错误\"><a href=\"#高阶函数和错误\" class=\"headerlink\" title=\"高阶函数和错误\"></a>高阶函数和错误</h6><p>刚才我们就已经看出来了，在实际使用 Swift 中，经常能遇到网络请求这种异步处理错误的情况，如果按照刚才的写法，就是使用 <code>throws</code> 来捕获异常进行处理，这并不是一个好的方法，通常也不建议这么使用，因为可选值和 <code>Result</code> 作用于类型，而 <code>throws</code> 只对函数类型起效。将一个函数标注为 throws 意味着这个函数可能会失败。所以为了解决异步处理产生的问题，默认的规则就是定义 <code>Result&lt;T&gt;</code>：</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">enum</span> <span class=\"variable\"><span class=\"class\">Result</span></span>&lt;<span class=\"variable\">T</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"variable\">case</span> <span class=\"function\"><span class=\"title\">success</span>(<span class=\"variable\">T</span>)</span></span><br><span class=\"line\">    <span class=\"variable\">case</span> <span class=\"function\"><span class=\"title\">fail</span>(<span class=\"variable\">LoginError</span>)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Result 是异步错误处理的正确道路。不好的地方在于，如果你已经在同步函数中使用 throws 了，那么再在异步函数中转为使用 Result 将会在两种接口之间导入差异。</p>\n<h5 id=\"第九章-泛型\"><a href=\"#第九章-泛型\" class=\"headerlink\" title=\"第九章 泛型\"></a>第九章 泛型</h5><h6 id=\"使用闭包对行为进行参数化\"><a href=\"#使用闭包对行为进行参数化\" class=\"headerlink\" title=\"使用闭包对行为进行参数化\"></a>使用闭包对行为进行参数化</h6><p>对 Array 进行判断，标准库中提供的 <code>contains</code> 是这么做的:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Sequence</span> </span>&#123;</span><br><span class=\"line\">true<span class=\"comment\">/// 根据序列是否包含满足给定断言的元素，返回一个布尔值。</span></span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">contains</span>(<span class=\"params\">where</span> <span class=\"params\">predicate</span>: (<span class=\"type\">Iterator</span>.<span class=\"type\">Element</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Bool</span>)</span></span><br><span class=\"line\">truetrue<span class=\"keyword\">return</span> -&gt; <span class=\"type\">Bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，它接受一个函数，这个函数从序列中取出一个元素，并对他进行一些检查。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isEven = &#123; $<span class=\"number\">0</span> % <span class=\"number\">2</span> == <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">(<span class=\"number\">0.</span>.<span class=\"number\">.5</span>).contains(<span class=\"keyword\">where</span>: isEven)  <span class=\"comment\">// ture</span></span><br><span class=\"line\">[<span class=\"meta\">1,3,99</span>].contains(<span class=\"keyword\">where</span>: isEven) <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用泛型进行代码设计\"><a href=\"#使用泛型进行代码设计\" class=\"headerlink\" title=\"使用泛型进行代码设计\"></a>使用泛型进行代码设计</h6><p>让我们来写一些与网络服务交互的函数。比如获取用户列表的数据，并解析为 User 数据类型。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func load<span class=\"constructor\">Users(<span class=\"params\">callback</span>: ([User]?)</span> -&gt; <span class=\"literal\">()</span>) &#123;</span><br><span class=\"line\">true<span class=\"keyword\">let</span> usersURL = webserviceURL.appending<span class=\"constructor\">PathComponent(<span class=\"string\">&quot;/users&quot;</span>)</span></span><br><span class=\"line\">true<span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span>? <span class=\"constructor\">Data(<span class=\"params\">contentsOf</span>: <span class=\"params\">usersURL</span>)</span></span><br><span class=\"line\">true<span class=\"keyword\">let</span> json = data.flatMap &#123;</span><br><span class=\"line\">truetrue<span class=\"keyword\">try</span>? <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">JSONSerialization</span>.</span></span>json<span class=\"constructor\">Object(<span class=\"params\">with</span>: $0, <span class=\"params\">options</span>: [])</span></span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">true<span class=\"keyword\">let</span> users = (json <span class=\"keyword\">as</span>? <span class=\"literal\">[A<span class=\"identifier\">ny</span>]</span>).flatMap &#123; jsonObject <span class=\"keyword\">in</span></span><br><span class=\"line\">truetruejsonObject.flat<span class=\"constructor\">Map(User.<span class=\"params\">init</span>)</span></span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">truecallback(users)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数会发生三种错误情况：URL 加载可能失败，JOSN解析可能失败，通过 JSON 数组构建用户对象也可能失败。</p>\n<p>现在，如果我们想要写一个相同的函数来加载其他资源。比如，我们需要一个加载博客文章的函数，它看起来是这样的：</p>\n<p><code>func loadBlogPosts(callback: ([BlogPost])? -&gt; ())</code><br>此函数的实现和前面的用户函数几乎相同。相比于复制和粘贴，将函数中 User 相关的部分提取出来，将其他部分进行重用，会是更好的方式。</p>\n<h5 id=\"第十章-协议\"><a href=\"#第十章-协议\" class=\"headerlink\" title=\"第十章 协议\"></a>第十章 协议</h5><h6 id=\"面向协议编程和协议拓展\"><a href=\"#面向协议编程和协议拓展\" class=\"headerlink\" title=\"面向协议编程和协议拓展\"></a>面向协议编程和协议拓展</h6><p>假设我们有一个只有 String 属性的 结构体 Obj</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Obj</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value <span class=\"operator\">=</span> <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span>(<span class=\"params\">str</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> num <span class=\"operator\">=</span> <span class=\"type\">Int</span>(value) <span class=\"operator\">??</span> <span class=\"number\">0</span> <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\">        value <span class=\"operator\">=</span> <span class=\"type\">String</span>(num)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们想通过协议的方式对一个 String 进行加一操作：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">transform</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addOne</span>(<span class=\"params\">str</span>: <span class=\"type\">String</span>)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只要对结构体 Obj 进拓展并具体实现加一方法，来满足协议:</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Obj: transform &#123;</span><br><span class=\"line\">    mutating func add<span class=\"constructor\">One(<span class=\"params\">str</span>: String)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n1 = <span class=\"constructor\">Int(<span class=\"params\">str</span>)</span> ?? <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> n2 = <span class=\"constructor\">Int(<span class=\"params\">value</span>)</span> ?? <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> tmp = n1 + n2</span><br><span class=\"line\">        value = <span class=\"constructor\">String(<span class=\"params\">tmp</span>)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在只需要假设 content 是满足协议的，就可以实现独立的方法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">var</span> <span class=\"attribute\">content</span>: transform = <span class=\"built_in\">Obj</span>(value: <span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">content.<span class=\"built_in\">addOne</span>(str: <span class=\"string\">&quot;2&quot;</span>) \t\t// <span class=\"built_in\">Obj</span>(value: <span class=\"string\">&quot;3&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>除此之外，同样可以通过协议拓展的方式。</p>\n<h6 id=\"协议内幕\"><a href=\"#协议内幕\" class=\"headerlink\" title=\"协议内幕\"></a>协议内幕</h6><p>当我们通过协议类型创建一个变量时，这个变量会被包装到一个叫存在容器的盒子中。<br>使用泛型参数确实要比使用协议类型高效的多。通过使用泛型参数，可以避免隐式的泛型封装。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隐式打包</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printProtocol</span>(<span class=\"params\">array</span>: [<span class=\"type\">CustomStringConvertible</span>])</span> &#123;</span><br><span class=\"line\">true<span class=\"built_in\">print</span>(array)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 没有打包</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printGeneric</span>&lt;<span class=\"type\">A</span>: <span class=\"type\">CustomStringConvertible</span>&gt;(<span class=\"params\">array</span>: [<span class=\"type\">A</span>])</span> &#123;</span><br><span class=\"line\">true<span class=\"built_in\">print</span>(array)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<pre><code>Swift 既是一门高层级语言，又是一门低层级语言。Swift 是一门多范式语言。 \n</code></pre>\n<p>使用 Swift 也有一段时间了，这本书作为一门进阶用书写的十分优秀，翻译也十分浅显易懂。把学到内容作为笔记记录下来，也方便以后查看。</p>\n<!---more--->\n<h5 id=\"第一章-介绍\"><a href=\"#第一章-介绍\" class=\"headerlink\" title=\"第一章 介绍\"></a>第一章 介绍</h5><p>这一章倒是并没有介绍太过深奥的内容，知识介绍了一些对 Swift 语言的整体印象，以及在使用过程中经常会遇到的术语，这些和其他编程语言都是通用的，就不一一列举出来了。就列出一些平常自己不知道的内容了。</p>\n<blockquote>\n<p>在程序语言的论文里，<code>==</code> 有时候被称为结构相等，而 <code>===</code> 则被称为<strong>指针相等</strong>或者<strong>引用相等</strong>。</p>\n</blockquote>\n<p>高阶函数：</p>\n<blockquote>\n<p>如果一个函数接受别的函数作为参数，或者一个函数的返回值是函数，那么这样的函数就叫作<strong>高阶函数</strong>。</p>\n</blockquote>\n<h5 id=\"第二章-内建集合类型\"><a href=\"#第二章-内建集合类型\" class=\"headerlink\" title=\"第二章 内建集合类型\"></a>第二章 内建集合类型</h5><h6 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h6><p><strong>运算符也是函数</strong><br>所以:<br><code>let sum = fibs.reduce(0) &#123; totle, num in totle + num&#125;</code><br>完全等价于<br><code>let sum = fibs.reduce(0, +)</code><br>reduce 的具体实现是:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reduce</span>&lt;<span class=\"type\">Result</span>&gt;(<span class=\"keyword\">_</span> <span class=\"params\">initialResult</span>: <span class=\"type\">Result</span>, <span class=\"keyword\">_</span> <span class=\"params\">nextPartialResult</span>: (<span class=\"type\">Result</span>, <span class=\"type\">Element</span>) -&gt; <span class=\"type\">Result</span>)</span> -&gt; <span class=\"type\">Result</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result <span class=\"operator\">=</span> initialResult</span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">            result <span class=\"operator\">=</span> <span class=\"keyword\">try</span> nextPartialResult(result, x)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"flatMap\"><a href=\"#flatMap\" class=\"headerlink\" title=\"flatMap\"></a>flatMap</h6><p>flatMap 和 map 类似，但是它们直接的区别是 faltMap 返回的是另一个数组，而不是单独的元素。<br>flatMap 的具体实现是:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">flatMap</span>&lt;<span class=\"type\">SegmentOfResult</span> : <span class=\"type\">Sequence</span>&gt;(</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">_</span> <span class=\"params\">transform</span>: (<span class=\"type\">Element</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">SegmentOfResult</span></span></span><br><span class=\"line\"><span class=\"function\">        )</span> <span class=\"keyword\">rethrows</span> -&gt; [<span class=\"type\">SegmentOfResult</span>.<span class=\"type\">Element</span>] &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result: [<span class=\"type\">SegmentOfResult</span>.<span class=\"type\">Element</span>] <span class=\"operator\">=</span> []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">            result.append(contentsOf: <span class=\"keyword\">try</span> transform(element))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"常用的函数参数\"><a href=\"#常用的函数参数\" class=\"headerlink\" title=\"常用的函数参数\"></a>常用的函数参数</h6><ul>\n<li>map 和 flatMap 对元素进行变换。</li>\n<li>filter 元素是否应该被包含在结果中。</li>\n<li>reduce 将元素河滨到一个总和的值中。</li>\n<li>sequence 序列中下一个元素。</li>\n<li>forEach 对每一个元素进行操作。</li>\n<li>sort 对元素进行排序。</li>\n<li>index, contains 元素符合某个条件。</li>\n<li>min max 元素中最小值和最大值。</li>\n<li>starts 元素是否相等。</li>\n<li>split 切割元素。</li>\n</ul>\n<h5 id=\"第三章-集合类型协议\"><a href=\"#第三章-集合类型协议\" class=\"headerlink\" title=\"第三章 集合类型协议\"></a>第三章 集合类型协议</h5><h6 id=\"Sequence\"><a href=\"#Sequence\" class=\"headerlink\" title=\"Sequence\"></a>Sequence</h6><p>Sequence 协议是集合类型结构中的基础。一个序列（Sequence）代表的是一系列具有相同类型的值，你可以对这些值进行迭代。遍历一个序列最简单的方式是使用 for 循环。<br>这个函数有两个版本：<br>第一种方法：<code>sequence(first: next:)</code>。将使用第一个参数的值作为序列的首个元素，并使用 <code>next</code> 参数传入的闭包生成序列的后续元素。这里先定义一个 next 的闭包，用来生成一个随机数且要比前一个数小，到零为止:</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let calculte = &#123; (previouse: <span class=\"type\">UInt32</span>) -&gt; UInt32? <span class=\"keyword\">in</span></span><br><span class=\"line\">    let <span class=\"keyword\">new</span><span class=\"type\">Value</span> = arc4random_uniform(previouse)</span><br><span class=\"line\">    guard <span class=\"keyword\">new</span><span class=\"type\">Value</span> &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;<span class=\"keyword\">return</span> nil&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span><span class=\"type\">Value</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义好这个 next 闭包，就能够直接构建好一个 Sequence。<code>let randomNumbsers = sequence(first: 100, next: calculte)</code>。其中定义好初始化数据 first 为 100。<br><code>Array(randomNumbsers) // [100, 56, 9, 6, 3, 2]</code><br>第二个方法：<code>sequence(state: next:)</code>。因为它可以在两次 next 闭包被调用之间保存任意的可变状态，所以它更强大一些。这里我们通过它来创建一个<a href=\"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97\">斐波那契序列</a>:</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let calculte2 = &#123; (<span class=\"keyword\">state</span>: inout (Int, Int)) -&gt; Int? <span class=\"keyword\">in</span></span><br><span class=\"line\">    let result = <span class=\"keyword\">state</span>.<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">state</span> = (<span class=\"keyword\">state</span>.<span class=\"number\">1</span>, <span class=\"keyword\">state</span>.<span class=\"number\">0</span> + <span class=\"keyword\">state</span>.<span class=\"number\">1</span>)</span><br><span class=\"line\">    return result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义初始数据为一个元组 (0, 1)，再将这个元素传递给 next，然后取出元组中第一个数据，并修改元组数据:第一个数据 -&gt; 第二个数据，第二个数据 -&gt; 第一个与第二个数据的和。<br><code>fibs = sequence(state: (0, 1), next: calculte2)</code>。<br><code>Array(fibs.prefix(10)) // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</code></p>\n<blockquote>\n<p><code>sequence(first:next:)</code> 和 <code>sequence(state:next:)</code> 的返回值类型是 <code>UnfoldSequence</code>。这个术语来自函数式编程，在函数式编程中，这种操作为成为展开(unfold)。sequence 是和 reduce 对应的(在函数式编程中 reduce 有常被叫做 fold)。reduce 将一个序列缩减(或者说折叠)为一个单一的返回值，而 sequence 则将一个单一的值展开形成一个序列。</p>\n</blockquote>\n<h5 id=\"第四章-可选值\"><a href=\"#第四章-可选值\" class=\"headerlink\" title=\"第四章 可选值\"></a>第四章 可选值</h5><h6 id=\"if-let\"><a href=\"#if-let\" class=\"headerlink\" title=\"if let\"></a>if let</h6><p>使用 <code>if let</code> 来进行可选绑定(optional binding)要比使用 <code>switch</code> 语句稍好一些。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> urlString = <span class=\"string\">&quot;http://www.objc.io/logo.png&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> url = <span class=\"constructor\">URL(<span class=\"params\">string</span>: <span class=\"params\">urlString</span>)</span>,</span><br><span class=\"line\">true<span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span>? <span class=\"constructor\">Data(<span class=\"params\">contentsOf</span>: <span class=\"params\">url</span>)</span>,</span><br><span class=\"line\">true<span class=\"keyword\">let</span> image = <span class=\"constructor\">UIImage(<span class=\"params\">data</span>: <span class=\"params\">data</span>)</span> </span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\">true<span class=\"keyword\">let</span> view = <span class=\"constructor\">UIImageView(<span class=\"params\">image</span>: <span class=\"params\">image</span>)</span></span><br><span class=\"line\">true<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">PlaygroundPage</span>.</span></span>current.liveView = view</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"while-let\"><a href=\"#while-let\" class=\"headerlink\" title=\"while let\"></a>while let</h6><p><code>while let </code> 和 <code>if let</code> 非常相似，它代表一个当遇到 nil 时终止的循环。注意，一旦条件为 false，循环就会停止(也许你错误地认为 where 条件会像 filter 那样工作，其实不然)。</p>\n<h6 id=\"nil-合并运算\"><a href=\"#nil-合并运算\" class=\"headerlink\" title=\"nil 合并运算\"></a>nil 合并运算</h6><p><code>??</code> 和 Objective-C 中的 <code>?:</code> 十分相似，但是它们还是有不同的地方，那就是 Swift 中的可选值<strong>不是指针</strong>。<br>我们可以对 Array 进行扩展来包含检查索引值是否在数组边界内:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">subscript</span>(<span class=\"params\">safe</span> <span class=\"params\">idx</span>: <span class=\"type\">Int</span>)</span> -&gt; <span class=\"type\">Element</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> idx <span class=\"operator\">&lt;</span> endIndex <span class=\"operator\">?</span> <span class=\"keyword\">self</span>[idx] : <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 现在就可以这样写</span></span><br><span class=\"line\">array[safe: <span class=\"number\">5</span>] <span class=\"operator\">??</span> <span class=\"number\">0</span> <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<p>合并操作也能够进行链接—-如果有多个可能的可选值，并且想要选择第一个非 nil 的值，则可以将他们按顺序合并:</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> i: <span class=\"built_in\">Int</span>? = nil</span><br><span class=\"line\"><span class=\"keyword\">let</span> j: <span class=\"built_in\">Int</span>? = nil</span><br><span class=\"line\"><span class=\"keyword\">let</span> k: <span class=\"built_in\">Int</span>? = <span class=\"number\">42</span></span><br><span class=\"line\">i ?? j ?? k <span class=\"comment\">// Optional(42)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"第五章-结构体和类\"><a href=\"#第五章-结构体和类\" class=\"headerlink\" title=\"第五章 结构体和类\"></a>第五章 结构体和类</h5><h6 id=\"值类型\"><a href=\"#值类型\" class=\"headerlink\" title=\"值类型\"></a>值类型</h6><p>结构体(和枚举)是<strong>值类型</strong>，而类是<strong>引用类型</strong>。因为结构体只有一个持有者，所以它不可能造成引用循环。而对于类和函数这样的引用类型，我们需要特别小心，避免造成引用循环的问题。<br>如果想要将两个 Point 相加，则可以对 + 操作符进行重载。在方法中，我们可以将成员相加，并返回新的 Point:</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func +(lhs: Point, rhs: Point) -&gt; Point &#123;</span><br><span class=\"line\">truereturn <span class=\"constructor\">Point(<span class=\"params\">x</span>: <span class=\"params\">lhs</span>.<span class=\"params\">x</span> + <span class=\"params\">rhs</span>.<span class=\"params\">x</span>, <span class=\"params\">y</span>: <span class=\"params\">lhs</span>.<span class=\"params\">y</span> + <span class=\"params\">rhs</span>.<span class=\"params\">y</span>)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">screen.origin + <span class=\"constructor\">Point(<span class=\"params\">x</span>: 10, <span class=\"params\">y</span>: 10)</span> <span class=\"comment\">// (x: 20, y: 20)</span></span><br></pre></td></tr></table></figure>\n<p>如果想要改变 self，或者嵌套的(比如 self.origin.x)任何属性，就需要将方法标记为 <code>mutating</code>。只有使用了这个关键字，我们才能在方法内部进行改变。<br>Swift 的结构体一般被存储在栈上，而非堆上。如果结构体太大，它也会被存储在堆上。</p>\n<h6 id=\"捕获列表\"><a href=\"#捕获列表\" class=\"headerlink\" title=\"捕获列表\"></a>捕获列表</h6><p>为了打破循环引用，需要保证闭包不去引用视图。通过使用<strong>捕获列表</strong>并将捕获变量 view 标记为 weak 或者 unowned 来达到这个目的。</p>\n<figure class=\"highlight sas\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">window</span>?onRotate = &#123; [weak <span class=\"meta\">view</span>] <span class=\"meta\">in</span></span><br><span class=\"line\">truep<span class=\"meta\">rint(</span><span class=\"string\">&quot;We now also need to update the view: \\(view)&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"第六章-函数\"><a href=\"#第六章-函数\" class=\"headerlink\" title=\"第六章 函数\"></a>第六章 函数</h5><ol>\n<li>函数可以像 Int 或者 String 那样被赋值给变量，也可以作为另一个函数的输入参数，或者另一个函数的返回值来使用。</li>\n<li>函数能够<strong>捕获</strong>存在于其作用域之外的变量。</li>\n<li>有两种方法可以创建函数，一种是使用 func 关键字，另一种是 { }。在 Swift 中，后一种被称为闭包表达式。</li>\n</ol>\n<h5 id=\"第七章-字符串\"><a href=\"#第七章-字符串\" class=\"headerlink\" title=\"第七章 字符串\"></a>第七章 字符串</h5><p>这一章主要介绍了 String，但是书中还是介绍 Swift3.0 的版本，而最新的 Swift4.0 对此更改了很多。我就直接记录一些 String 的变化吧。<br>String 现在已经更改为一个集合类型了，所以现在直接废除了 <code>.characters</code> 这个属性了。其他的操作也都遵循了 Collection 协议了。</p>\n<h5 id=\"第八章-错误处理\"><a href=\"#第八章-错误处理\" class=\"headerlink\" title=\"第八章 错误处理\"></a>第八章 错误处理</h5><h6 id=\"抛出和捕获\"><a href=\"#抛出和捕获\" class=\"headerlink\" title=\"抛出和捕获\"></a>抛出和捕获</h6><p>Swift 没有使用返回 Result 的方法来表示失败，而是将方法标记为 throws。Result 是作用于类型上的，而 throw 是作用于函数的。</p>\n<p>如果我们想要在错误中给出更多的信息，则可以使用带有关联值的枚举。(任何遵循 Error 协议的类型都可以被抛出函数作为错误抛出。)</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> LoginError: <span class=\"built_in\">Error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> wrongUser</span><br><span class=\"line\">    <span class=\"keyword\">case</span> passwordError(user: <span class=\"built_in\">String</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>你可以指定你的函数可能抛出的具体错误类型，但这并不是必须的。因为现在 Swift 中的<strong>错误类型是无类型的</strong>，所以通过文档来说明你的函数会抛出怎样的错误是非常重要的。</p>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">login</span>(<span class=\"params\">user</span>: <span class=\"type\">String</span>, <span class=\"params\">passWord</span>: <span class=\"type\">String</span>)</span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> user.isEmpty &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"type\">LoginError</span>.wrongUser</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> passWord <span class=\"operator\">!=</span> <span class=\"string\">&quot;123&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"type\">LoginError</span>.passwordError(user: user)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;登录成功！！！&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> login(user: <span class=\"string\">&quot;hu&quot;</span>, passWord: <span class=\"string\">&quot;111&quot;</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> <span class=\"type\">LoginError</span>.wrongUser &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;用户不存在&quot;</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> <span class=\"type\">LoginError</span>.passwordError(<span class=\"keyword\">let</span> id) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;<span class=\"subst\">\\(id)</span>的密码输入错误！！！&quot;</span>) <span class=\"comment\">// hu的密码输入错误！！！</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(error.localizedDescription)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，在 Swift 中，我们虽然把这块内容叫做“异常”，但是实质上它更多的还是“错误”而非真正意义上的异常。</p>\n<h6 id=\"使用-defer-进行清理\"><a href=\"#使用-defer-进行清理\" class=\"headerlink\" title=\"使用 defer 进行清理\"></a>使用 defer 进行清理</h6><p>Swift 中的 <code>defer</code> ，围绕的代码块一定会在函数返回时被执行（就是相当于在 return 之后再执行一些操作）。<br><code>defer</code> 类似于其他语言的 <code>finally</code>，但是 <code>defer</code> 不只是用于错误处理，可以将 <code>defer</code> 放在代码块的任意地方。<br>如果同一个作用域里使用多个 <code>defer</code>，那么它们会被逆序执行，可以把它想象成一个栈。用意在于，比如我们开启数据库然后连接，用 <code>defer</code> 就能自然的先关闭连接，再关闭数据库。</p>\n<h6 id=\"高阶函数和错误\"><a href=\"#高阶函数和错误\" class=\"headerlink\" title=\"高阶函数和错误\"></a>高阶函数和错误</h6><p>刚才我们就已经看出来了，在实际使用 Swift 中，经常能遇到网络请求这种异步处理错误的情况，如果按照刚才的写法，就是使用 <code>throws</code> 来捕获异常进行处理，这并不是一个好的方法，通常也不建议这么使用，因为可选值和 <code>Result</code> 作用于类型，而 <code>throws</code> 只对函数类型起效。将一个函数标注为 throws 意味着这个函数可能会失败。所以为了解决异步处理产生的问题，默认的规则就是定义 <code>Result&lt;T&gt;</code>：</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">enum</span> <span class=\"variable\"><span class=\"class\">Result</span></span>&lt;<span class=\"variable\">T</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"variable\">case</span> <span class=\"function\"><span class=\"title\">success</span>(<span class=\"variable\">T</span>)</span></span><br><span class=\"line\">    <span class=\"variable\">case</span> <span class=\"function\"><span class=\"title\">fail</span>(<span class=\"variable\">LoginError</span>)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Result 是异步错误处理的正确道路。不好的地方在于，如果你已经在同步函数中使用 throws 了，那么再在异步函数中转为使用 Result 将会在两种接口之间导入差异。</p>\n<h5 id=\"第九章-泛型\"><a href=\"#第九章-泛型\" class=\"headerlink\" title=\"第九章 泛型\"></a>第九章 泛型</h5><h6 id=\"使用闭包对行为进行参数化\"><a href=\"#使用闭包对行为进行参数化\" class=\"headerlink\" title=\"使用闭包对行为进行参数化\"></a>使用闭包对行为进行参数化</h6><p>对 Array 进行判断，标准库中提供的 <code>contains</code> 是这么做的:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Sequence</span> </span>&#123;</span><br><span class=\"line\">true<span class=\"comment\">/// 根据序列是否包含满足给定断言的元素，返回一个布尔值。</span></span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">contains</span>(<span class=\"params\">where</span> <span class=\"params\">predicate</span>: (<span class=\"type\">Iterator</span>.<span class=\"type\">Element</span>) <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Bool</span>)</span></span><br><span class=\"line\">truetrue<span class=\"keyword\">return</span> -&gt; <span class=\"type\">Bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说，它接受一个函数，这个函数从序列中取出一个元素，并对他进行一些检查。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isEven = &#123; $<span class=\"number\">0</span> % <span class=\"number\">2</span> == <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">(<span class=\"number\">0.</span>.<span class=\"number\">.5</span>).contains(<span class=\"keyword\">where</span>: isEven)  <span class=\"comment\">// ture</span></span><br><span class=\"line\">[<span class=\"meta\">1,3,99</span>].contains(<span class=\"keyword\">where</span>: isEven) <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用泛型进行代码设计\"><a href=\"#使用泛型进行代码设计\" class=\"headerlink\" title=\"使用泛型进行代码设计\"></a>使用泛型进行代码设计</h6><p>让我们来写一些与网络服务交互的函数。比如获取用户列表的数据，并解析为 User 数据类型。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func load<span class=\"constructor\">Users(<span class=\"params\">callback</span>: ([User]?)</span> -&gt; <span class=\"literal\">()</span>) &#123;</span><br><span class=\"line\">true<span class=\"keyword\">let</span> usersURL = webserviceURL.appending<span class=\"constructor\">PathComponent(<span class=\"string\">&quot;/users&quot;</span>)</span></span><br><span class=\"line\">true<span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span>? <span class=\"constructor\">Data(<span class=\"params\">contentsOf</span>: <span class=\"params\">usersURL</span>)</span></span><br><span class=\"line\">true<span class=\"keyword\">let</span> json = data.flatMap &#123;</span><br><span class=\"line\">truetrue<span class=\"keyword\">try</span>? <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">JSONSerialization</span>.</span></span>json<span class=\"constructor\">Object(<span class=\"params\">with</span>: $0, <span class=\"params\">options</span>: [])</span></span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">true<span class=\"keyword\">let</span> users = (json <span class=\"keyword\">as</span>? <span class=\"literal\">[A<span class=\"identifier\">ny</span>]</span>).flatMap &#123; jsonObject <span class=\"keyword\">in</span></span><br><span class=\"line\">truetruejsonObject.flat<span class=\"constructor\">Map(User.<span class=\"params\">init</span>)</span></span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">truecallback(users)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数会发生三种错误情况：URL 加载可能失败，JOSN解析可能失败，通过 JSON 数组构建用户对象也可能失败。</p>\n<p>现在，如果我们想要写一个相同的函数来加载其他资源。比如，我们需要一个加载博客文章的函数，它看起来是这样的：</p>\n<p><code>func loadBlogPosts(callback: ([BlogPost])? -&gt; ())</code><br>此函数的实现和前面的用户函数几乎相同。相比于复制和粘贴，将函数中 User 相关的部分提取出来，将其他部分进行重用，会是更好的方式。</p>\n<h5 id=\"第十章-协议\"><a href=\"#第十章-协议\" class=\"headerlink\" title=\"第十章 协议\"></a>第十章 协议</h5><h6 id=\"面向协议编程和协议拓展\"><a href=\"#面向协议编程和协议拓展\" class=\"headerlink\" title=\"面向协议编程和协议拓展\"></a>面向协议编程和协议拓展</h6><p>假设我们有一个只有 String 属性的 结构体 Obj</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Obj</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value <span class=\"operator\">=</span> <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span>(<span class=\"params\">str</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> num <span class=\"operator\">=</span> <span class=\"type\">Int</span>(value) <span class=\"operator\">??</span> <span class=\"number\">0</span> <span class=\"operator\">+</span> <span class=\"number\">1</span></span><br><span class=\"line\">        value <span class=\"operator\">=</span> <span class=\"type\">String</span>(num)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们想通过协议的方式对一个 String 进行加一操作：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">transform</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addOne</span>(<span class=\"params\">str</span>: <span class=\"type\">String</span>)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只要对结构体 Obj 进拓展并具体实现加一方法，来满足协议:</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Obj: transform &#123;</span><br><span class=\"line\">    mutating func add<span class=\"constructor\">One(<span class=\"params\">str</span>: String)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> n1 = <span class=\"constructor\">Int(<span class=\"params\">str</span>)</span> ?? <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> n2 = <span class=\"constructor\">Int(<span class=\"params\">value</span>)</span> ?? <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> tmp = n1 + n2</span><br><span class=\"line\">        value = <span class=\"constructor\">String(<span class=\"params\">tmp</span>)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在只需要假设 content 是满足协议的，就可以实现独立的方法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">var</span> <span class=\"attribute\">content</span>: transform = <span class=\"built_in\">Obj</span>(value: <span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">content.<span class=\"built_in\">addOne</span>(str: <span class=\"string\">&quot;2&quot;</span>) \t\t// <span class=\"built_in\">Obj</span>(value: <span class=\"string\">&quot;3&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>除此之外，同样可以通过协议拓展的方式。</p>\n<h6 id=\"协议内幕\"><a href=\"#协议内幕\" class=\"headerlink\" title=\"协议内幕\"></a>协议内幕</h6><p>当我们通过协议类型创建一个变量时，这个变量会被包装到一个叫存在容器的盒子中。<br>使用泛型参数确实要比使用协议类型高效的多。通过使用泛型参数，可以避免隐式的泛型封装。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隐式打包</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printProtocol</span>(<span class=\"params\">array</span>: [<span class=\"type\">CustomStringConvertible</span>])</span> &#123;</span><br><span class=\"line\">true<span class=\"built_in\">print</span>(array)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 没有打包</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printGeneric</span>&lt;<span class=\"type\">A</span>: <span class=\"type\">CustomStringConvertible</span>&gt;(<span class=\"params\">array</span>: [<span class=\"type\">A</span>])</span> &#123;</span><br><span class=\"line\">true<span class=\"built_in\">print</span>(array)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"读书","title":"《亲密关系》读书笔记","date":"2019-03-23T16:03:15.000Z","_content":"\n\"寻找真挚永恒的亲密关系，其实就是寻找自我。\"   ——克里斯多夫·孟\n今天开始读一下这本书，做一些思考和记录。\n<!-- more -->\n#### 第一章 亲密关系的圣杯\n&#8195;&#8195;几乎每个人都希望拥有很棒的亲密关系。只有了解到没断亲密关系的开始都是一段伟大的探索旅程时，我们才会明白其中的意义。我们希望从亲密关系中得到身、心、灵三方面渴望的东西。\n&#8195;&#8195;我们当中很多人想要亲密关系，并且需要的并不是慰藉与陪伴，而是需要能鼓励我们超越自我的伴侣，我们追寻的是能够激发人生意义与方向，并在我们受到考验时，给予我们帮助的人机关系。这也就是“**灵魂关系**”。\n<p align=\"right\"> 2019年03月24日</p>\n\n#### 第二章 月晕现象\n&#8195;&#8195;月亮本身并不发光，它只是反射太阳的光。影星的私生活其实也像普通人一样有许多问题，但影迷们被绚丽的光彩所迷惑，把明星当神一样来崇拜。即使无数的丑闻让盲目崇拜的问题暴露出来，也不能改变人们崇拜偶像的问题。这就是“月晕现象”。\n&#8195;&#8195;亲密关系的过程，一开始是相互吸引，然后一步步发展出浪漫的火花。人一旦坠入情网，难免会有**过高的期望**，以致最后会掉入幻灭的深渊。恐惧与无知是造成所谓“亲密关系失败”的两大原因。\n&#8195;&#8195;简单来说，情感来自人类“爱与被爱”的基本需求，这个主要的动机就构成了人与人之间的“**磁场吸引**”。\n<p align=\"right\"> 2019年03月24日</p>\n\n&#8195;&#8195;开始和维持一段亲密关系的背后的真正动机，其实在于需求。孩童的两大主要需求是归属感和确认自己的重要性。\n<p align=\"right\"> 2019年05月27日</p>\n\n&#8195;&#8195;**在恋爱中，期望就是通往地狱之路，因为期望让自己会把接受对方和让对方自由等爱意阻挡在外。**如果我不能接受他现在的样子，或是不能让他自由的走着自己的路，那我就是不是真的爱他，而只是想从对方那里得到满足。和对方建立的亲密关系的目的也不是因为爱，而是满足自己小小的自私需求。\n<p align=\"right\"> 2019年07月19日</p>\n\n#### 第三章 幻灭\n&#8195;&#8195;幻灭这个词的意思其实是 ------ 不被错觉所迷惑。这其实是件好事，让我们明白快乐的源泉其实并不在别人身上。幻灭的过程可能会持续很久，只有在我们的需求没有得到满足，而且对伴侣的改造计划又完全不起作用的时候幻灭才会到来。这时，我们就会做出一些**偏差行为**。\n\n四种主要的偏差行为：\n1. 引起注意。（看着我！看着我!）\n2. 权力斗争。（我不想做，你不能逼我！）\n3. 报复心理。（你伤害了我多少，我也要伤害你多少！）\n4. 自我放逐。（努力有什么用呢？反正我一点也不重要。）\n\n**我们宁愿争吵也不愿意面对伤口，是因为生气要比面对心碎简单的多。**\n<p align=\"right\"> 2019年07月21日</p>\n\n\n&#8195;&#8195;每个人都会伤害他所心爱的事物。许多夫妻宁愿陷入不愉快的权力斗争，也不愿意面对争吵背后的痛苦。在亲密关系中最大的问题就是我们面对痛苦的态度，在每段亲密关系中都会遇到困难，而面对问题时，都会伴随某种情绪的伤痛。就是这种伤痛，带来的争吵、批评和互相指责。\n<p align=\"right\"> 2019年11月11日</p>\n\n&#8195;&#8195;**愤怒是短暂的疯狂。**愤怒既不具备创造性、启发性、智慧和美感也不能鼓励人和使生活变得美好。我们对伴侣发怒的原因有两个：一是怒气能够麻痹我们心中的痛，压过所有情绪，甚至能够麻痹身体的感觉。是有效的止痛剂。第二个原因是生气能够让对方有负罪感，就能有效的控制对方的行为。\n&#8195;&#8195;在权力斗争中，愤怒有三种表达方式：攻击、情绪抽离和被动攻击\n&#8195;&#8195;1.攻击:攻击是公开明显表现愤怒的方式。通常表现批评、指责、怪罪、威胁、肢体攻击和言语中伤\n&#8195;&#8195;2.情绪抽离则是叫沉默的表达愤怒的方式。一副收到伴侣残忍对待的样子，让对方觉得愧疚。\n&#8195;&#8195;3.被动攻击就比较像零星的战火，假装不太介意对方的行为，但言语间却充斥着隐隐约约的批评、讽刺、批判、嘲弄或抱怨。为了保护自己免于痛苦，他选择暗中攻击伴侣，让他觉得歉疚。 \n\n面对权力斗争,最简单的方式就是**沟通**。\n有效沟通的八个纲要问题：\n1. 我想要什么？\n2. 有没有什么误会要先澄清的？\n3. 我所表达的情绪，有哪些是绝对真实的?\n4. 我或我伴侣的情绪，是不是似曾相识？\n5. 这种情绪怎么来的？\n6. 我该怎么回应这种情绪？\n7. 情绪背后有哪些感觉？\n8. 我能不能用爱来回应这种感觉？\n\n<p align=\"right\"> 2019年12月02日</p>\n\n&#8195;&#8195;**报复**的倾向，在权力斗争之前就已经开始。刻意伤害对方，会减轻自己的痛苦。在报复的时候，会得到一种冷冰冰的快感，这种行为会让人上瘾。其中一个原因是：超脱自己的痛苦，需要很大的努力，但借着报复来转移注意力却很简单。\n&#8195;&#8195;检查一下亲密关系中，你有没有在哪些地方去刻意伤害伴侣？晚回家又不打电话，跟尖酸批评或恶言相向一样算是报复行为。你必须了解自己在报复时，用的什么武器？并且让伴侣知道。问问对方哪些话或行为会让他真正受到伤害。然后保证以后会对自己行为更加注意与负责。\n<p align=\"right\"> 2020年04月13日</p>\n\n&#8195;&#8195;痛苦虽不能避免，要不要受苦却可以选择。逃避痛苦、不愿面对的倾向，只会延长我们所受的考验与苦难。如果不能，接受并坦然的面对痛苦，我们就必然要受苦。若能用勇敢的、灵魂所启发的方式来响应，我们就能得到前所未有的自由------灵魂关系的自由。\n<p align=\"right\"> 2020年04月14日</p>\n\n\n","source":"_posts/《亲密关系》读书笔记.md","raw":"---\nlayout: 读书\ntitle: 《亲密关系》读书笔记\ndate: 2019-03-24 00:03:15\ntags: \n- 读书\ncategories: \n- 读书\n---\n\n\"寻找真挚永恒的亲密关系，其实就是寻找自我。\"   ——克里斯多夫·孟\n今天开始读一下这本书，做一些思考和记录。\n<!-- more -->\n#### 第一章 亲密关系的圣杯\n&#8195;&#8195;几乎每个人都希望拥有很棒的亲密关系。只有了解到没断亲密关系的开始都是一段伟大的探索旅程时，我们才会明白其中的意义。我们希望从亲密关系中得到身、心、灵三方面渴望的东西。\n&#8195;&#8195;我们当中很多人想要亲密关系，并且需要的并不是慰藉与陪伴，而是需要能鼓励我们超越自我的伴侣，我们追寻的是能够激发人生意义与方向，并在我们受到考验时，给予我们帮助的人机关系。这也就是“**灵魂关系**”。\n<p align=\"right\"> 2019年03月24日</p>\n\n#### 第二章 月晕现象\n&#8195;&#8195;月亮本身并不发光，它只是反射太阳的光。影星的私生活其实也像普通人一样有许多问题，但影迷们被绚丽的光彩所迷惑，把明星当神一样来崇拜。即使无数的丑闻让盲目崇拜的问题暴露出来，也不能改变人们崇拜偶像的问题。这就是“月晕现象”。\n&#8195;&#8195;亲密关系的过程，一开始是相互吸引，然后一步步发展出浪漫的火花。人一旦坠入情网，难免会有**过高的期望**，以致最后会掉入幻灭的深渊。恐惧与无知是造成所谓“亲密关系失败”的两大原因。\n&#8195;&#8195;简单来说，情感来自人类“爱与被爱”的基本需求，这个主要的动机就构成了人与人之间的“**磁场吸引**”。\n<p align=\"right\"> 2019年03月24日</p>\n\n&#8195;&#8195;开始和维持一段亲密关系的背后的真正动机，其实在于需求。孩童的两大主要需求是归属感和确认自己的重要性。\n<p align=\"right\"> 2019年05月27日</p>\n\n&#8195;&#8195;**在恋爱中，期望就是通往地狱之路，因为期望让自己会把接受对方和让对方自由等爱意阻挡在外。**如果我不能接受他现在的样子，或是不能让他自由的走着自己的路，那我就是不是真的爱他，而只是想从对方那里得到满足。和对方建立的亲密关系的目的也不是因为爱，而是满足自己小小的自私需求。\n<p align=\"right\"> 2019年07月19日</p>\n\n#### 第三章 幻灭\n&#8195;&#8195;幻灭这个词的意思其实是 ------ 不被错觉所迷惑。这其实是件好事，让我们明白快乐的源泉其实并不在别人身上。幻灭的过程可能会持续很久，只有在我们的需求没有得到满足，而且对伴侣的改造计划又完全不起作用的时候幻灭才会到来。这时，我们就会做出一些**偏差行为**。\n\n四种主要的偏差行为：\n1. 引起注意。（看着我！看着我!）\n2. 权力斗争。（我不想做，你不能逼我！）\n3. 报复心理。（你伤害了我多少，我也要伤害你多少！）\n4. 自我放逐。（努力有什么用呢？反正我一点也不重要。）\n\n**我们宁愿争吵也不愿意面对伤口，是因为生气要比面对心碎简单的多。**\n<p align=\"right\"> 2019年07月21日</p>\n\n\n&#8195;&#8195;每个人都会伤害他所心爱的事物。许多夫妻宁愿陷入不愉快的权力斗争，也不愿意面对争吵背后的痛苦。在亲密关系中最大的问题就是我们面对痛苦的态度，在每段亲密关系中都会遇到困难，而面对问题时，都会伴随某种情绪的伤痛。就是这种伤痛，带来的争吵、批评和互相指责。\n<p align=\"right\"> 2019年11月11日</p>\n\n&#8195;&#8195;**愤怒是短暂的疯狂。**愤怒既不具备创造性、启发性、智慧和美感也不能鼓励人和使生活变得美好。我们对伴侣发怒的原因有两个：一是怒气能够麻痹我们心中的痛，压过所有情绪，甚至能够麻痹身体的感觉。是有效的止痛剂。第二个原因是生气能够让对方有负罪感，就能有效的控制对方的行为。\n&#8195;&#8195;在权力斗争中，愤怒有三种表达方式：攻击、情绪抽离和被动攻击\n&#8195;&#8195;1.攻击:攻击是公开明显表现愤怒的方式。通常表现批评、指责、怪罪、威胁、肢体攻击和言语中伤\n&#8195;&#8195;2.情绪抽离则是叫沉默的表达愤怒的方式。一副收到伴侣残忍对待的样子，让对方觉得愧疚。\n&#8195;&#8195;3.被动攻击就比较像零星的战火，假装不太介意对方的行为，但言语间却充斥着隐隐约约的批评、讽刺、批判、嘲弄或抱怨。为了保护自己免于痛苦，他选择暗中攻击伴侣，让他觉得歉疚。 \n\n面对权力斗争,最简单的方式就是**沟通**。\n有效沟通的八个纲要问题：\n1. 我想要什么？\n2. 有没有什么误会要先澄清的？\n3. 我所表达的情绪，有哪些是绝对真实的?\n4. 我或我伴侣的情绪，是不是似曾相识？\n5. 这种情绪怎么来的？\n6. 我该怎么回应这种情绪？\n7. 情绪背后有哪些感觉？\n8. 我能不能用爱来回应这种感觉？\n\n<p align=\"right\"> 2019年12月02日</p>\n\n&#8195;&#8195;**报复**的倾向，在权力斗争之前就已经开始。刻意伤害对方，会减轻自己的痛苦。在报复的时候，会得到一种冷冰冰的快感，这种行为会让人上瘾。其中一个原因是：超脱自己的痛苦，需要很大的努力，但借着报复来转移注意力却很简单。\n&#8195;&#8195;检查一下亲密关系中，你有没有在哪些地方去刻意伤害伴侣？晚回家又不打电话，跟尖酸批评或恶言相向一样算是报复行为。你必须了解自己在报复时，用的什么武器？并且让伴侣知道。问问对方哪些话或行为会让他真正受到伤害。然后保证以后会对自己行为更加注意与负责。\n<p align=\"right\"> 2020年04月13日</p>\n\n&#8195;&#8195;痛苦虽不能避免，要不要受苦却可以选择。逃避痛苦、不愿面对的倾向，只会延长我们所受的考验与苦难。如果不能，接受并坦然的面对痛苦，我们就必然要受苦。若能用勇敢的、灵魂所启发的方式来响应，我们就能得到前所未有的自由------灵魂关系的自由。\n<p align=\"right\"> 2020年04月14日</p>\n\n\n","slug":"《亲密关系》读书笔记","published":1,"updated":"2021-09-06T15:49:09.839Z","_id":"ckt8qfyah00167sn698ed2zz1","comments":1,"photos":[],"link":"","content":"<p>“寻找真挚永恒的亲密关系，其实就是寻找自我。”   ——克里斯多夫·孟<br>今天开始读一下这本书，做一些思考和记录。</p>\n<span id=\"more\"></span>\n<h4 id=\"第一章-亲密关系的圣杯\"><a href=\"#第一章-亲密关系的圣杯\" class=\"headerlink\" title=\"第一章 亲密关系的圣杯\"></a>第一章 亲密关系的圣杯</h4><p>&#8195;&#8195;几乎每个人都希望拥有很棒的亲密关系。只有了解到没断亲密关系的开始都是一段伟大的探索旅程时，我们才会明白其中的意义。我们希望从亲密关系中得到身、心、灵三方面渴望的东西。<br>&#8195;&#8195;我们当中很多人想要亲密关系，并且需要的并不是慰藉与陪伴，而是需要能鼓励我们超越自我的伴侣，我们追寻的是能够激发人生意义与方向，并在我们受到考验时，给予我们帮助的人机关系。这也就是“<strong>灵魂关系</strong>”。</p>\n<p align=\"right\"> 2019年03月24日</p>\n\n<h4 id=\"第二章-月晕现象\"><a href=\"#第二章-月晕现象\" class=\"headerlink\" title=\"第二章 月晕现象\"></a>第二章 月晕现象</h4><p>&#8195;&#8195;月亮本身并不发光，它只是反射太阳的光。影星的私生活其实也像普通人一样有许多问题，但影迷们被绚丽的光彩所迷惑，把明星当神一样来崇拜。即使无数的丑闻让盲目崇拜的问题暴露出来，也不能改变人们崇拜偶像的问题。这就是“月晕现象”。<br>&#8195;&#8195;亲密关系的过程，一开始是相互吸引，然后一步步发展出浪漫的火花。人一旦坠入情网，难免会有<strong>过高的期望</strong>，以致最后会掉入幻灭的深渊。恐惧与无知是造成所谓“亲密关系失败”的两大原因。<br>&#8195;&#8195;简单来说，情感来自人类“爱与被爱”的基本需求，这个主要的动机就构成了人与人之间的“<strong>磁场吸引</strong>”。</p>\n<p align=\"right\"> 2019年03月24日</p>\n\n<p>&#8195;&#8195;开始和维持一段亲密关系的背后的真正动机，其实在于需求。孩童的两大主要需求是归属感和确认自己的重要性。</p>\n<p align=\"right\"> 2019年05月27日</p>\n\n<p>&#8195;&#8195;<strong>在恋爱中，期望就是通往地狱之路，因为期望让自己会把接受对方和让对方自由等爱意阻挡在外。</strong>如果我不能接受他现在的样子，或是不能让他自由的走着自己的路，那我就是不是真的爱他，而只是想从对方那里得到满足。和对方建立的亲密关系的目的也不是因为爱，而是满足自己小小的自私需求。</p>\n<p align=\"right\"> 2019年07月19日</p>\n\n<h4 id=\"第三章-幻灭\"><a href=\"#第三章-幻灭\" class=\"headerlink\" title=\"第三章 幻灭\"></a>第三章 幻灭</h4><p>&#8195;&#8195;幻灭这个词的意思其实是 —— 不被错觉所迷惑。这其实是件好事，让我们明白快乐的源泉其实并不在别人身上。幻灭的过程可能会持续很久，只有在我们的需求没有得到满足，而且对伴侣的改造计划又完全不起作用的时候幻灭才会到来。这时，我们就会做出一些<strong>偏差行为</strong>。</p>\n<p>四种主要的偏差行为：</p>\n<ol>\n<li>引起注意。（看着我！看着我!）</li>\n<li>权力斗争。（我不想做，你不能逼我！）</li>\n<li>报复心理。（你伤害了我多少，我也要伤害你多少！）</li>\n<li>自我放逐。（努力有什么用呢？反正我一点也不重要。）</li>\n</ol>\n<p><strong>我们宁愿争吵也不愿意面对伤口，是因为生气要比面对心碎简单的多。</strong></p>\n<p align=\"right\"> 2019年07月21日</p>\n\n\n<p>&#8195;&#8195;每个人都会伤害他所心爱的事物。许多夫妻宁愿陷入不愉快的权力斗争，也不愿意面对争吵背后的痛苦。在亲密关系中最大的问题就是我们面对痛苦的态度，在每段亲密关系中都会遇到困难，而面对问题时，都会伴随某种情绪的伤痛。就是这种伤痛，带来的争吵、批评和互相指责。</p>\n<p align=\"right\"> 2019年11月11日</p>\n\n<p>&#8195;&#8195;<strong>愤怒是短暂的疯狂。</strong>愤怒既不具备创造性、启发性、智慧和美感也不能鼓励人和使生活变得美好。我们对伴侣发怒的原因有两个：一是怒气能够麻痹我们心中的痛，压过所有情绪，甚至能够麻痹身体的感觉。是有效的止痛剂。第二个原因是生气能够让对方有负罪感，就能有效的控制对方的行为。<br>&#8195;&#8195;在权力斗争中，愤怒有三种表达方式：攻击、情绪抽离和被动攻击<br>&#8195;&#8195;1.攻击:攻击是公开明显表现愤怒的方式。通常表现批评、指责、怪罪、威胁、肢体攻击和言语中伤<br>&#8195;&#8195;2.情绪抽离则是叫沉默的表达愤怒的方式。一副收到伴侣残忍对待的样子，让对方觉得愧疚。<br>&#8195;&#8195;3.被动攻击就比较像零星的战火，假装不太介意对方的行为，但言语间却充斥着隐隐约约的批评、讽刺、批判、嘲弄或抱怨。为了保护自己免于痛苦，他选择暗中攻击伴侣，让他觉得歉疚。 </p>\n<p>面对权力斗争,最简单的方式就是<strong>沟通</strong>。<br>有效沟通的八个纲要问题：</p>\n<ol>\n<li>我想要什么？</li>\n<li>有没有什么误会要先澄清的？</li>\n<li>我所表达的情绪，有哪些是绝对真实的?</li>\n<li>我或我伴侣的情绪，是不是似曾相识？</li>\n<li>这种情绪怎么来的？</li>\n<li>我该怎么回应这种情绪？</li>\n<li>情绪背后有哪些感觉？</li>\n<li>我能不能用爱来回应这种感觉？</li>\n</ol>\n<p align=\"right\"> 2019年12月02日</p>\n\n<p>&#8195;&#8195;<strong>报复</strong>的倾向，在权力斗争之前就已经开始。刻意伤害对方，会减轻自己的痛苦。在报复的时候，会得到一种冷冰冰的快感，这种行为会让人上瘾。其中一个原因是：超脱自己的痛苦，需要很大的努力，但借着报复来转移注意力却很简单。<br>&#8195;&#8195;检查一下亲密关系中，你有没有在哪些地方去刻意伤害伴侣？晚回家又不打电话，跟尖酸批评或恶言相向一样算是报复行为。你必须了解自己在报复时，用的什么武器？并且让伴侣知道。问问对方哪些话或行为会让他真正受到伤害。然后保证以后会对自己行为更加注意与负责。</p>\n<p align=\"right\"> 2020年04月13日</p>\n\n<p>&#8195;&#8195;痛苦虽不能避免，要不要受苦却可以选择。逃避痛苦、不愿面对的倾向，只会延长我们所受的考验与苦难。如果不能，接受并坦然的面对痛苦，我们就必然要受苦。若能用勇敢的、灵魂所启发的方式来响应，我们就能得到前所未有的自由——灵魂关系的自由。</p>\n<p align=\"right\"> 2020年04月14日</p>\n\n\n","site":{"data":{}},"excerpt":"<p>“寻找真挚永恒的亲密关系，其实就是寻找自我。”   ——克里斯多夫·孟<br>今天开始读一下这本书，做一些思考和记录。</p>","more":"<h4 id=\"第一章-亲密关系的圣杯\"><a href=\"#第一章-亲密关系的圣杯\" class=\"headerlink\" title=\"第一章 亲密关系的圣杯\"></a>第一章 亲密关系的圣杯</h4><p>&#8195;&#8195;几乎每个人都希望拥有很棒的亲密关系。只有了解到没断亲密关系的开始都是一段伟大的探索旅程时，我们才会明白其中的意义。我们希望从亲密关系中得到身、心、灵三方面渴望的东西。<br>&#8195;&#8195;我们当中很多人想要亲密关系，并且需要的并不是慰藉与陪伴，而是需要能鼓励我们超越自我的伴侣，我们追寻的是能够激发人生意义与方向，并在我们受到考验时，给予我们帮助的人机关系。这也就是“<strong>灵魂关系</strong>”。</p>\n<p align=\"right\"> 2019年03月24日</p>\n\n<h4 id=\"第二章-月晕现象\"><a href=\"#第二章-月晕现象\" class=\"headerlink\" title=\"第二章 月晕现象\"></a>第二章 月晕现象</h4><p>&#8195;&#8195;月亮本身并不发光，它只是反射太阳的光。影星的私生活其实也像普通人一样有许多问题，但影迷们被绚丽的光彩所迷惑，把明星当神一样来崇拜。即使无数的丑闻让盲目崇拜的问题暴露出来，也不能改变人们崇拜偶像的问题。这就是“月晕现象”。<br>&#8195;&#8195;亲密关系的过程，一开始是相互吸引，然后一步步发展出浪漫的火花。人一旦坠入情网，难免会有<strong>过高的期望</strong>，以致最后会掉入幻灭的深渊。恐惧与无知是造成所谓“亲密关系失败”的两大原因。<br>&#8195;&#8195;简单来说，情感来自人类“爱与被爱”的基本需求，这个主要的动机就构成了人与人之间的“<strong>磁场吸引</strong>”。</p>\n<p align=\"right\"> 2019年03月24日</p>\n\n<p>&#8195;&#8195;开始和维持一段亲密关系的背后的真正动机，其实在于需求。孩童的两大主要需求是归属感和确认自己的重要性。</p>\n<p align=\"right\"> 2019年05月27日</p>\n\n<p>&#8195;&#8195;<strong>在恋爱中，期望就是通往地狱之路，因为期望让自己会把接受对方和让对方自由等爱意阻挡在外。</strong>如果我不能接受他现在的样子，或是不能让他自由的走着自己的路，那我就是不是真的爱他，而只是想从对方那里得到满足。和对方建立的亲密关系的目的也不是因为爱，而是满足自己小小的自私需求。</p>\n<p align=\"right\"> 2019年07月19日</p>\n\n<h4 id=\"第三章-幻灭\"><a href=\"#第三章-幻灭\" class=\"headerlink\" title=\"第三章 幻灭\"></a>第三章 幻灭</h4><p>&#8195;&#8195;幻灭这个词的意思其实是 —— 不被错觉所迷惑。这其实是件好事，让我们明白快乐的源泉其实并不在别人身上。幻灭的过程可能会持续很久，只有在我们的需求没有得到满足，而且对伴侣的改造计划又完全不起作用的时候幻灭才会到来。这时，我们就会做出一些<strong>偏差行为</strong>。</p>\n<p>四种主要的偏差行为：</p>\n<ol>\n<li>引起注意。（看着我！看着我!）</li>\n<li>权力斗争。（我不想做，你不能逼我！）</li>\n<li>报复心理。（你伤害了我多少，我也要伤害你多少！）</li>\n<li>自我放逐。（努力有什么用呢？反正我一点也不重要。）</li>\n</ol>\n<p><strong>我们宁愿争吵也不愿意面对伤口，是因为生气要比面对心碎简单的多。</strong></p>\n<p align=\"right\"> 2019年07月21日</p>\n\n\n<p>&#8195;&#8195;每个人都会伤害他所心爱的事物。许多夫妻宁愿陷入不愉快的权力斗争，也不愿意面对争吵背后的痛苦。在亲密关系中最大的问题就是我们面对痛苦的态度，在每段亲密关系中都会遇到困难，而面对问题时，都会伴随某种情绪的伤痛。就是这种伤痛，带来的争吵、批评和互相指责。</p>\n<p align=\"right\"> 2019年11月11日</p>\n\n<p>&#8195;&#8195;<strong>愤怒是短暂的疯狂。</strong>愤怒既不具备创造性、启发性、智慧和美感也不能鼓励人和使生活变得美好。我们对伴侣发怒的原因有两个：一是怒气能够麻痹我们心中的痛，压过所有情绪，甚至能够麻痹身体的感觉。是有效的止痛剂。第二个原因是生气能够让对方有负罪感，就能有效的控制对方的行为。<br>&#8195;&#8195;在权力斗争中，愤怒有三种表达方式：攻击、情绪抽离和被动攻击<br>&#8195;&#8195;1.攻击:攻击是公开明显表现愤怒的方式。通常表现批评、指责、怪罪、威胁、肢体攻击和言语中伤<br>&#8195;&#8195;2.情绪抽离则是叫沉默的表达愤怒的方式。一副收到伴侣残忍对待的样子，让对方觉得愧疚。<br>&#8195;&#8195;3.被动攻击就比较像零星的战火，假装不太介意对方的行为，但言语间却充斥着隐隐约约的批评、讽刺、批判、嘲弄或抱怨。为了保护自己免于痛苦，他选择暗中攻击伴侣，让他觉得歉疚。 </p>\n<p>面对权力斗争,最简单的方式就是<strong>沟通</strong>。<br>有效沟通的八个纲要问题：</p>\n<ol>\n<li>我想要什么？</li>\n<li>有没有什么误会要先澄清的？</li>\n<li>我所表达的情绪，有哪些是绝对真实的?</li>\n<li>我或我伴侣的情绪，是不是似曾相识？</li>\n<li>这种情绪怎么来的？</li>\n<li>我该怎么回应这种情绪？</li>\n<li>情绪背后有哪些感觉？</li>\n<li>我能不能用爱来回应这种感觉？</li>\n</ol>\n<p align=\"right\"> 2019年12月02日</p>\n\n<p>&#8195;&#8195;<strong>报复</strong>的倾向，在权力斗争之前就已经开始。刻意伤害对方，会减轻自己的痛苦。在报复的时候，会得到一种冷冰冰的快感，这种行为会让人上瘾。其中一个原因是：超脱自己的痛苦，需要很大的努力，但借着报复来转移注意力却很简单。<br>&#8195;&#8195;检查一下亲密关系中，你有没有在哪些地方去刻意伤害伴侣？晚回家又不打电话，跟尖酸批评或恶言相向一样算是报复行为。你必须了解自己在报复时，用的什么武器？并且让伴侣知道。问问对方哪些话或行为会让他真正受到伤害。然后保证以后会对自己行为更加注意与负责。</p>\n<p align=\"right\"> 2020年04月13日</p>\n\n<p>&#8195;&#8195;痛苦虽不能避免，要不要受苦却可以选择。逃避痛苦、不愿面对的倾向，只会延长我们所受的考验与苦难。如果不能，接受并坦然的面对痛苦，我们就必然要受苦。若能用勇敢的、灵魂所启发的方式来响应，我们就能得到前所未有的自由——灵魂关系的自由。</p>\n<p align=\"right\"> 2020年04月14日</p>"},{"layout":"《函数式 Swift》读书笔记","title":"《函数式 Swift》读书笔记","date":"2018-01-10T08:03:21.000Z","_content":"\t\t函数在 Swift 中是一等公民，换句话说，函数可以作为参数被传递到其他函数，\n\t\t也可以作为其他函数的返回值。函数式编程的核心理念就是函数是值。\n<!---more--->\n#### 函数式思想\n在 Swift 中计算和传递函数的方式与整形或布尔型没有任何不同。\n假设有一个 struct 包含 x 和 y 坐标:\n\n```\nstruct Position {\n    let x: Int\n    let y: Int\n}\n```\n\n此时，定义一个 typealias，表示把 Position 转化为 bool 的函数。 \n`typealias Region = (Position) -> Bool`。\n\n接下来创建函数的返回值就可以是一个函数(Region) \n\n```\nfunc circle(radius: Int) -> Region {\n    return { loc in return loc.x < radius }\n}\n```\n\n其中 \n\n```\n{ (参数) -> (返回值) in \n\t(函数具体的操作)\n\treturn (返回值)\n}\n```\n大括号内就是表示一个函数。\n \n#### 案例研究：封装 Core Image\n书中的用例是对 CIImage 进行封装。为了让自己更明白本章所讲的内容，我把 CIImage 换成了 Int 类型来实现，两者的本质并无太大的区别，重点是对函数化这一概念要有清晰的认识。\n我们首先将 Filter 定义为一个函数，该函数接受 Int 型作为参数，并且返回一个新的 Int 型。`typealias Filter = (Int) -> Int`。\n首先，我们定义一个简单的 +1 的方法，返回值是 Filter(**是一个函数**)。 \n\n```\nfunc addOne(describe: String) -> Filter {\n    return { number in\n        return number + 1\n    }\n}\n```\n这样调用起来就是： `addOne(describe: \"简单的 10+1\")(10) // 11` \n接下来在的定义一个 +2 的方法，同上\n\n```\nfunc addTwo(describe: String) -> Filter {\n    return { number in\n        return number + 2\n    }\n}\n```\n到这里都挺简单的，现在如果我们要再实现一个 +3 的方法，再复制就显得太蠢了，所以转换一下思路，通过 +1 和 +2 的方法实现：\n\n```\nfunc addThree(describe: String) -> Filter {\n    return { number in\n        let one = addOne(describe: \"+ 1:\")(number)\n        return addTwo(describe: \"+ 2:\")(one)\n    }\n}\naddThree(describe: \"+ 3:\")(100) // 103\n```\n##### 复合函数\n现在，如果我们想要实现 0 + 1 + 2 + 3 的功能，就可以这么调用：\n`addThree(describe: \"3\")(addTwo(describe: \"2\")(addOne(describe: \"1\")(0))) // 6`。\n感觉这么调用并不友好，我们需要优化一下实现方式。书中给了一种方案是使用**复合函数**。\n首先定义一个用于组合的函数：\n\n```\nfunc compose(filter1: @escaping Filter, fileter2: @escaping Filter) -> Filter {\n    return { num in fileter2(filter1(num)) }\n}\n```\n这样可以使用复合函数来定义：\n`compose(compose(addOne(describe: \"1\"), addTwo(describe: \"2\")), addThree(describe: \"3\"))(100) // 106`\n##### 自定义运算符\n但是看起来也很不容易理解。为了让代码更具可读性，我们可以再进一步，为组合引入运算符。\n\n```\ninfix operator >>>: pro\nprecedencegroup pro {\n    associativity: left\n}\n\nfunc >>>(filter1: @escaping Filter, fileter2: @escaping Filter) -> Filter {\n    return { num in fileter2(filter1(num)) }\n}\n```\n这样就可以用运算符来实现了，\n\n```\nlet result = addOne(describe: \"1\") >>> addTwo(describe: \"2\") >>> addThree(describe: \"3\")\nresult(0) // 6\n```\n##### 柯里化\n函数接受参数之后，返回一个**闭包**，然后等待第二个参数。`add(1)(2)`。函数中的箭头 -> 向右结合。这也就是说没你可以将 A -> B -> C 理解为 A -> (B -> C)。\n\n#### Map、Filter 和 Reduce\n##### Map 和 Filter\n关于 Map 官网的描述是:\n> Returns an array containing the results of mapping the given closure over the sequence’s elements.\n\n翻译过来就是: 返回一个数组，数组中的元素是由闭包提供的映射序列产生的。\n\n`func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]`\n其中关于参数的描述是:\n> A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\n一个映射的闭包，以一个序列的**每个元素**作为参数，返回一个相同或不同的类型**新值**。可以知道我们需要提供的参数是**一个闭包**。这个闭包中的参数和返回值可以是任意类型的（由泛型定义）。\n\nMap的定义是这样的：\n\n```\nextension Array {\n\tfunc map<T>(transform: Element -> T) -> [T] {\n\t\tvar result: [T] = []\n\t\tfor x in self {\n\t\t\tresult.append(transform(x))\n\t\t}\n\t\treturn result\n\t}\n}\n```\n所以在调用的时候，我们就需要提供一个变换方法的闭包。\n\n```\narray.map { $0.lowercaseString } // [\"vivien\", \"marlon\", \"kim\"]\n```\n\n##### Reduce \n关于 Reduce 官网的描述是：\n> Returns the result of combining the elements of the sequence using the given closure.\n\n翻译过来是：返回组合运算的结果，组合运算是由提供的序列经过闭包处理每个元素产生的。\n\n`func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -> Result) rethrows -> Result`\n\n##### 泛型和 Any 类型\n除了泛型，Swift 还支持 Any 类型，它能代表任何类型的值。泛型可以用于定义灵活的函数，类型检查仍然由编译器负责；而 Any 类型则可以避开 Swift 的类型系统（**所以应该尽可能避免使用**）。\n\n泛型函数的类型十分丰富，这里我们可以考虑一下上一章对自定义函数组合运算符 >>> 的泛型实现:\n\n```\ninfix operator >>|: pro\nprecedencegroup pro {\n    associativity: left\n}\nfunc >>|<A, B, C>(f: @escaping (A) -> (B), g: @escaping (B) -> (C)) -> (A) -> (C) {\n    return { x in g(f(x))}\n}\n\nlet result = addOne(describe: \"1\") >>| addTwo(describe: \"2\") >>| addThree(describe: \"3\")\nresult(10) // 16\n```\n\n#### 可选值\n`??` 运算符的简易定义是这样的：\n\n```\ninfix operator ??\n\nfunc ??<T>(lhs: T?, rhs: T) -> T {\n    if let result = lhs {\n        return result\n    }else {\n        return rhs\n    }\n}\n\nlet result: Int? = { return nil }()\nresult ?? 100\t\t// 100\n```\n`??` 运算符提供了一个相比于强制可选解包更安全的替代，并且不像可选绑定一样繁琐。","source":"_posts/《函数式Swift》笔记.md","raw":"---\nlayout: 《函数式 Swift》读书笔记\ntitle: 《函数式 Swift》读书笔记\ndate: 2018-01-10 16:03:21\ntags: \n- Swift\n- 读书\ncategories: \n- Swift\n---\n\t\t函数在 Swift 中是一等公民，换句话说，函数可以作为参数被传递到其他函数，\n\t\t也可以作为其他函数的返回值。函数式编程的核心理念就是函数是值。\n<!---more--->\n#### 函数式思想\n在 Swift 中计算和传递函数的方式与整形或布尔型没有任何不同。\n假设有一个 struct 包含 x 和 y 坐标:\n\n```\nstruct Position {\n    let x: Int\n    let y: Int\n}\n```\n\n此时，定义一个 typealias，表示把 Position 转化为 bool 的函数。 \n`typealias Region = (Position) -> Bool`。\n\n接下来创建函数的返回值就可以是一个函数(Region) \n\n```\nfunc circle(radius: Int) -> Region {\n    return { loc in return loc.x < radius }\n}\n```\n\n其中 \n\n```\n{ (参数) -> (返回值) in \n\t(函数具体的操作)\n\treturn (返回值)\n}\n```\n大括号内就是表示一个函数。\n \n#### 案例研究：封装 Core Image\n书中的用例是对 CIImage 进行封装。为了让自己更明白本章所讲的内容，我把 CIImage 换成了 Int 类型来实现，两者的本质并无太大的区别，重点是对函数化这一概念要有清晰的认识。\n我们首先将 Filter 定义为一个函数，该函数接受 Int 型作为参数，并且返回一个新的 Int 型。`typealias Filter = (Int) -> Int`。\n首先，我们定义一个简单的 +1 的方法，返回值是 Filter(**是一个函数**)。 \n\n```\nfunc addOne(describe: String) -> Filter {\n    return { number in\n        return number + 1\n    }\n}\n```\n这样调用起来就是： `addOne(describe: \"简单的 10+1\")(10) // 11` \n接下来在的定义一个 +2 的方法，同上\n\n```\nfunc addTwo(describe: String) -> Filter {\n    return { number in\n        return number + 2\n    }\n}\n```\n到这里都挺简单的，现在如果我们要再实现一个 +3 的方法，再复制就显得太蠢了，所以转换一下思路，通过 +1 和 +2 的方法实现：\n\n```\nfunc addThree(describe: String) -> Filter {\n    return { number in\n        let one = addOne(describe: \"+ 1:\")(number)\n        return addTwo(describe: \"+ 2:\")(one)\n    }\n}\naddThree(describe: \"+ 3:\")(100) // 103\n```\n##### 复合函数\n现在，如果我们想要实现 0 + 1 + 2 + 3 的功能，就可以这么调用：\n`addThree(describe: \"3\")(addTwo(describe: \"2\")(addOne(describe: \"1\")(0))) // 6`。\n感觉这么调用并不友好，我们需要优化一下实现方式。书中给了一种方案是使用**复合函数**。\n首先定义一个用于组合的函数：\n\n```\nfunc compose(filter1: @escaping Filter, fileter2: @escaping Filter) -> Filter {\n    return { num in fileter2(filter1(num)) }\n}\n```\n这样可以使用复合函数来定义：\n`compose(compose(addOne(describe: \"1\"), addTwo(describe: \"2\")), addThree(describe: \"3\"))(100) // 106`\n##### 自定义运算符\n但是看起来也很不容易理解。为了让代码更具可读性，我们可以再进一步，为组合引入运算符。\n\n```\ninfix operator >>>: pro\nprecedencegroup pro {\n    associativity: left\n}\n\nfunc >>>(filter1: @escaping Filter, fileter2: @escaping Filter) -> Filter {\n    return { num in fileter2(filter1(num)) }\n}\n```\n这样就可以用运算符来实现了，\n\n```\nlet result = addOne(describe: \"1\") >>> addTwo(describe: \"2\") >>> addThree(describe: \"3\")\nresult(0) // 6\n```\n##### 柯里化\n函数接受参数之后，返回一个**闭包**，然后等待第二个参数。`add(1)(2)`。函数中的箭头 -> 向右结合。这也就是说没你可以将 A -> B -> C 理解为 A -> (B -> C)。\n\n#### Map、Filter 和 Reduce\n##### Map 和 Filter\n关于 Map 官网的描述是:\n> Returns an array containing the results of mapping the given closure over the sequence’s elements.\n\n翻译过来就是: 返回一个数组，数组中的元素是由闭包提供的映射序列产生的。\n\n`func map<T>(_ transform: (Element) throws -> T) rethrows -> [T]`\n其中关于参数的描述是:\n> A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.\n\n一个映射的闭包，以一个序列的**每个元素**作为参数，返回一个相同或不同的类型**新值**。可以知道我们需要提供的参数是**一个闭包**。这个闭包中的参数和返回值可以是任意类型的（由泛型定义）。\n\nMap的定义是这样的：\n\n```\nextension Array {\n\tfunc map<T>(transform: Element -> T) -> [T] {\n\t\tvar result: [T] = []\n\t\tfor x in self {\n\t\t\tresult.append(transform(x))\n\t\t}\n\t\treturn result\n\t}\n}\n```\n所以在调用的时候，我们就需要提供一个变换方法的闭包。\n\n```\narray.map { $0.lowercaseString } // [\"vivien\", \"marlon\", \"kim\"]\n```\n\n##### Reduce \n关于 Reduce 官网的描述是：\n> Returns the result of combining the elements of the sequence using the given closure.\n\n翻译过来是：返回组合运算的结果，组合运算是由提供的序列经过闭包处理每个元素产生的。\n\n`func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -> Result) rethrows -> Result`\n\n##### 泛型和 Any 类型\n除了泛型，Swift 还支持 Any 类型，它能代表任何类型的值。泛型可以用于定义灵活的函数，类型检查仍然由编译器负责；而 Any 类型则可以避开 Swift 的类型系统（**所以应该尽可能避免使用**）。\n\n泛型函数的类型十分丰富，这里我们可以考虑一下上一章对自定义函数组合运算符 >>> 的泛型实现:\n\n```\ninfix operator >>|: pro\nprecedencegroup pro {\n    associativity: left\n}\nfunc >>|<A, B, C>(f: @escaping (A) -> (B), g: @escaping (B) -> (C)) -> (A) -> (C) {\n    return { x in g(f(x))}\n}\n\nlet result = addOne(describe: \"1\") >>| addTwo(describe: \"2\") >>| addThree(describe: \"3\")\nresult(10) // 16\n```\n\n#### 可选值\n`??` 运算符的简易定义是这样的：\n\n```\ninfix operator ??\n\nfunc ??<T>(lhs: T?, rhs: T) -> T {\n    if let result = lhs {\n        return result\n    }else {\n        return rhs\n    }\n}\n\nlet result: Int? = { return nil }()\nresult ?? 100\t\t// 100\n```\n`??` 运算符提供了一个相比于强制可选解包更安全的替代，并且不像可选绑定一样繁琐。","slug":"《函数式Swift》笔记","published":1,"updated":"2018-01-16T09:43:29.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyak001b7sn60azfhybw","content":"<pre><code>    函数在 Swift 中是一等公民，换句话说，函数可以作为参数被传递到其他函数，\n    也可以作为其他函数的返回值。函数式编程的核心理念就是函数是值。\n</code></pre>\n<!---more--->\n<h4 id=\"函数式思想\"><a href=\"#函数式思想\" class=\"headerlink\" title=\"函数式思想\"></a>函数式思想</h4><p>在 Swift 中计算和传递函数的方式与整形或布尔型没有任何不同。<br>假设有一个 struct 包含 x 和 y 坐标:</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> Position &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x: <span class=\"built_in\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> y: <span class=\"built_in\">Int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时，定义一个 typealias，表示把 Position 转化为 bool 的函数。<br><code>typealias Region = (Position) -&gt; Bool</code>。</p>\n<p>接下来创建函数的返回值就可以是一个函数(Region) </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">circle</span>(<span class=\"params\">radius</span>: <span class=\"type\">Int</span>)</span> -&gt; <span class=\"type\">Region</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; loc <span class=\"keyword\">in</span> <span class=\"keyword\">return</span> loc.x <span class=\"operator\">&lt;</span> radius &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 </p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; (参数) -&gt; (返回值) in </span><br><span class=\"line\">true(函数具体的操作)</span><br><span class=\"line\">truereturn (返回值)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大括号内就是表示一个函数。</p>\n<h4 id=\"案例研究：封装-Core-Image\"><a href=\"#案例研究：封装-Core-Image\" class=\"headerlink\" title=\"案例研究：封装 Core Image\"></a>案例研究：封装 Core Image</h4><p>书中的用例是对 CIImage 进行封装。为了让自己更明白本章所讲的内容，我把 CIImage 换成了 Int 类型来实现，两者的本质并无太大的区别，重点是对函数化这一概念要有清晰的认识。<br>我们首先将 Filter 定义为一个函数，该函数接受 Int 型作为参数，并且返回一个新的 Int 型。<code>typealias Filter = (Int) -&gt; Int</code>。<br>首先，我们定义一个简单的 +1 的方法，返回值是 Filter(<strong>是一个函数</strong>)。 </p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addOne</span><span class=\"params\">(describe: String)</span> -&gt; <span class=\"title\">Filter</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"built_in\">number</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">number</span> + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样调用起来就是： <code>addOne(describe: &quot;简单的 10+1&quot;)(10) // 11</code><br>接下来在的定义一个 +2 的方法，同上</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addTwo</span><span class=\"params\">(describe: String)</span> -&gt; <span class=\"title\">Filter</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"built_in\">number</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">number</span> + <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里都挺简单的，现在如果我们要再实现一个 +3 的方法，再复制就显得太蠢了，所以转换一下思路，通过 +1 和 +2 的方法实现：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func add<span class=\"constructor\">Three(<span class=\"params\">describe</span>: String)</span> -&gt; Filter &#123;</span><br><span class=\"line\">    return &#123; number <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> one = add<span class=\"constructor\">One(<span class=\"params\">describe</span>: <span class=\"string\">&quot;+ 1:&quot;</span>)</span>(number)</span><br><span class=\"line\">        return add<span class=\"constructor\">Two(<span class=\"params\">describe</span>: <span class=\"string\">&quot;+ 2:&quot;</span>)</span>(one)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add<span class=\"constructor\">Three(<span class=\"params\">describe</span>: <span class=\"string\">&quot;+ 3:&quot;</span>)</span>(<span class=\"number\">100</span>) <span class=\"comment\">// 103</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"复合函数\"><a href=\"#复合函数\" class=\"headerlink\" title=\"复合函数\"></a>复合函数</h5><p>现在，如果我们想要实现 0 + 1 + 2 + 3 的功能，就可以这么调用：<br><code>addThree(describe: &quot;3&quot;)(addTwo(describe: &quot;2&quot;)(addOne(describe: &quot;1&quot;)(0))) // 6</code>。<br>感觉这么调用并不友好，我们需要优化一下实现方式。书中给了一种方案是使用<strong>复合函数</strong>。<br>首先定义一个用于组合的函数：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">func</span> <span class=\"selector-tag\">compose</span>(<span class=\"attribute\">filter1</span>: <span class=\"variable\">@escaping</span> Filter, <span class=\"attribute\">fileter2</span>: <span class=\"variable\">@escaping</span> Filter) <span class=\"selector-tag\">-</span>&gt; <span class=\"selector-tag\">Filter</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> &#123; <span class=\"selector-tag\">num</span> <span class=\"selector-tag\">in</span> <span class=\"selector-tag\">fileter2</span>(filter1(num)) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样可以使用复合函数来定义：<br><code>compose(compose(addOne(describe: &quot;1&quot;), addTwo(describe: &quot;2&quot;)), addThree(describe: &quot;3&quot;))(100) // 106</code></p>\n<h5 id=\"自定义运算符\"><a href=\"#自定义运算符\" class=\"headerlink\" title=\"自定义运算符\"></a>自定义运算符</h5><p>但是看起来也很不容易理解。为了让代码更具可读性，我们可以再进一步，为组合引入运算符。</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">infix</span> <span class=\"selector-tag\">operator</span> &gt;&gt;&gt;: <span class=\"selector-tag\">pro</span></span><br><span class=\"line\"><span class=\"selector-tag\">precedencegroup</span> <span class=\"selector-tag\">pro</span> &#123;</span><br><span class=\"line\">    associativity: <span class=\"attribute\">left</span></span><br><span class=\"line\"><span class=\"attribute\">&#125;</span></span><br><span class=\"line\"><span class=\"attribute\"></span></span><br><span class=\"line\"><span class=\"attribute\">func &gt;&gt;&gt;(filter1</span>: <span class=\"variable\">@escaping</span> Filter, <span class=\"attribute\">fileter2</span>: <span class=\"variable\">@escaping</span> Filter) -&gt; Filter &#123;</span><br><span class=\"line\">    return &#123; num in fileter2(filter1(num)) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以用运算符来实现了，</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = add<span class=\"constructor\">One(<span class=\"params\">describe</span>: <span class=\"string\">&quot;1&quot;</span>)</span> &gt;&gt;&gt; add<span class=\"constructor\">Two(<span class=\"params\">describe</span>: <span class=\"string\">&quot;2&quot;</span>)</span> &gt;&gt;&gt; add<span class=\"constructor\">Three(<span class=\"params\">describe</span>: <span class=\"string\">&quot;3&quot;</span>)</span></span><br><span class=\"line\">result(<span class=\"number\">0</span>) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h5><p>函数接受参数之后，返回一个<strong>闭包</strong>，然后等待第二个参数。<code>add(1)(2)</code>。函数中的箭头 -&gt; 向右结合。这也就是说没你可以将 A -&gt; B -&gt; C 理解为 A -&gt; (B -&gt; C)。</p>\n<h4 id=\"Map、Filter-和-Reduce\"><a href=\"#Map、Filter-和-Reduce\" class=\"headerlink\" title=\"Map、Filter 和 Reduce\"></a>Map、Filter 和 Reduce</h4><h5 id=\"Map-和-Filter\"><a href=\"#Map-和-Filter\" class=\"headerlink\" title=\"Map 和 Filter\"></a>Map 和 Filter</h5><p>关于 Map 官网的描述是:</p>\n<blockquote>\n<p>Returns an array containing the results of mapping the given closure over the sequence’s elements.</p>\n</blockquote>\n<p>翻译过来就是: 返回一个数组，数组中的元素是由闭包提供的映射序列产生的。</p>\n<p><code>func map&lt;T&gt;(_ transform: (Element) throws -&gt; T) rethrows -&gt; [T]</code><br>其中关于参数的描述是:</p>\n<blockquote>\n<p>A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.</p>\n</blockquote>\n<p>一个映射的闭包，以一个序列的<strong>每个元素</strong>作为参数，返回一个相同或不同的类型<strong>新值</strong>。可以知道我们需要提供的参数是<strong>一个闭包</strong>。这个闭包中的参数和返回值可以是任意类型的（由泛型定义）。</p>\n<p>Map的定义是这样的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">map</span>&lt;<span class=\"type\">T</span>&gt;(<span class=\"params\">transform</span>: <span class=\"type\">Element</span> -&gt; <span class=\"type\">T</span>)</span> -&gt; [<span class=\"type\">T</span>] &#123;</span><br><span class=\"line\">truetrue<span class=\"keyword\">var</span> result: [<span class=\"type\">T</span>] <span class=\"operator\">=</span> []</span><br><span class=\"line\">truetrue<span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">truetruetrueresult.append(transform(x))</span><br><span class=\"line\">truetrue&#125;</span><br><span class=\"line\">truetrue<span class=\"keyword\">return</span> result</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以在调用的时候，我们就需要提供一个变换方法的闭包。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.map &#123; <span class=\"variable\">$0</span>.lowercaseString &#125; <span class=\"regexp\">//</span> [<span class=\"string\">&quot;vivien&quot;</span>, <span class=\"string\">&quot;marlon&quot;</span>, <span class=\"string\">&quot;kim&quot;</span>]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Reduce\"><a href=\"#Reduce\" class=\"headerlink\" title=\"Reduce\"></a>Reduce</h5><p>关于 Reduce 官网的描述是：</p>\n<blockquote>\n<p>Returns the result of combining the elements of the sequence using the given closure.</p>\n</blockquote>\n<p>翻译过来是：返回组合运算的结果，组合运算是由提供的序列经过闭包处理每个元素产生的。</p>\n<p><code>func reduce&lt;Result&gt;(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -&gt; Result) rethrows -&gt; Result</code></p>\n<h5 id=\"泛型和-Any-类型\"><a href=\"#泛型和-Any-类型\" class=\"headerlink\" title=\"泛型和 Any 类型\"></a>泛型和 Any 类型</h5><p>除了泛型，Swift 还支持 Any 类型，它能代表任何类型的值。泛型可以用于定义灵活的函数，类型检查仍然由编译器负责；而 Any 类型则可以避开 Swift 的类型系统（<strong>所以应该尽可能避免使用</strong>）。</p>\n<p>泛型函数的类型十分丰富，这里我们可以考虑一下上一章对自定义函数组合运算符 &gt;&gt;&gt; 的泛型实现:</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">infix operator &gt;&gt;|: pro</span><br><span class=\"line\">precedencegroup pro &#123;</span><br><span class=\"line\">    associativity: left</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func &gt;&gt;|&lt;A, B, C&gt;<span class=\"function\"><span class=\"params\">(f: @escaping (A) -&gt; (B), g: @escaping (B) -&gt; (C))</span> -&gt;</span> <span class=\"function\"><span class=\"params\">(A)</span> -&gt;</span> (C) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; x <span class=\"keyword\">in</span> g(f(x))&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = addOne(describe: <span class=\"string\">&quot;1&quot;</span>) &gt;&gt;| addTwo(describe: <span class=\"string\">&quot;2&quot;</span>) &gt;&gt;| addThree(describe: <span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">result(<span class=\"number\">10</span>) <span class=\"regexp\">// 16</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可选值\"><a href=\"#可选值\" class=\"headerlink\" title=\"可选值\"></a>可选值</h4><p><code>??</code> 运算符的简易定义是这样的：</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">infix operator ??</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> ??&lt;T&gt;(lhs: T?, rhs: T) -&gt; T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">result</span> = lhs &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">result</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rhs</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"literal\">result</span>: <span class=\"type\">Int</span>? = &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">nil</span> &#125;()</span><br><span class=\"line\"><span class=\"literal\">result</span> ?? <span class=\"number\">100</span>\t\t// <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<p><code>??</code> 运算符提供了一个相比于强制可选解包更安全的替代，并且不像可选绑定一样繁琐。</p>\n","site":{"data":{}},"excerpt":"","more":"<pre><code>    函数在 Swift 中是一等公民，换句话说，函数可以作为参数被传递到其他函数，\n    也可以作为其他函数的返回值。函数式编程的核心理念就是函数是值。\n</code></pre>\n<!---more--->\n<h4 id=\"函数式思想\"><a href=\"#函数式思想\" class=\"headerlink\" title=\"函数式思想\"></a>函数式思想</h4><p>在 Swift 中计算和传递函数的方式与整形或布尔型没有任何不同。<br>假设有一个 struct 包含 x 和 y 坐标:</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> Position &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x: <span class=\"built_in\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> y: <span class=\"built_in\">Int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时，定义一个 typealias，表示把 Position 转化为 bool 的函数。<br><code>typealias Region = (Position) -&gt; Bool</code>。</p>\n<p>接下来创建函数的返回值就可以是一个函数(Region) </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">circle</span>(<span class=\"params\">radius</span>: <span class=\"type\">Int</span>)</span> -&gt; <span class=\"type\">Region</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; loc <span class=\"keyword\">in</span> <span class=\"keyword\">return</span> loc.x <span class=\"operator\">&lt;</span> radius &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 </p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; (参数) -&gt; (返回值) in </span><br><span class=\"line\">true(函数具体的操作)</span><br><span class=\"line\">truereturn (返回值)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大括号内就是表示一个函数。</p>\n<h4 id=\"案例研究：封装-Core-Image\"><a href=\"#案例研究：封装-Core-Image\" class=\"headerlink\" title=\"案例研究：封装 Core Image\"></a>案例研究：封装 Core Image</h4><p>书中的用例是对 CIImage 进行封装。为了让自己更明白本章所讲的内容，我把 CIImage 换成了 Int 类型来实现，两者的本质并无太大的区别，重点是对函数化这一概念要有清晰的认识。<br>我们首先将 Filter 定义为一个函数，该函数接受 Int 型作为参数，并且返回一个新的 Int 型。<code>typealias Filter = (Int) -&gt; Int</code>。<br>首先，我们定义一个简单的 +1 的方法，返回值是 Filter(<strong>是一个函数</strong>)。 </p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addOne</span><span class=\"params\">(describe: String)</span> -&gt; <span class=\"title\">Filter</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"built_in\">number</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">number</span> + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样调用起来就是： <code>addOne(describe: &quot;简单的 10+1&quot;)(10) // 11</code><br>接下来在的定义一个 +2 的方法，同上</p>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addTwo</span><span class=\"params\">(describe: String)</span> -&gt; <span class=\"title\">Filter</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"built_in\">number</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">number</span> + <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里都挺简单的，现在如果我们要再实现一个 +3 的方法，再复制就显得太蠢了，所以转换一下思路，通过 +1 和 +2 的方法实现：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func add<span class=\"constructor\">Three(<span class=\"params\">describe</span>: String)</span> -&gt; Filter &#123;</span><br><span class=\"line\">    return &#123; number <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> one = add<span class=\"constructor\">One(<span class=\"params\">describe</span>: <span class=\"string\">&quot;+ 1:&quot;</span>)</span>(number)</span><br><span class=\"line\">        return add<span class=\"constructor\">Two(<span class=\"params\">describe</span>: <span class=\"string\">&quot;+ 2:&quot;</span>)</span>(one)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add<span class=\"constructor\">Three(<span class=\"params\">describe</span>: <span class=\"string\">&quot;+ 3:&quot;</span>)</span>(<span class=\"number\">100</span>) <span class=\"comment\">// 103</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"复合函数\"><a href=\"#复合函数\" class=\"headerlink\" title=\"复合函数\"></a>复合函数</h5><p>现在，如果我们想要实现 0 + 1 + 2 + 3 的功能，就可以这么调用：<br><code>addThree(describe: &quot;3&quot;)(addTwo(describe: &quot;2&quot;)(addOne(describe: &quot;1&quot;)(0))) // 6</code>。<br>感觉这么调用并不友好，我们需要优化一下实现方式。书中给了一种方案是使用<strong>复合函数</strong>。<br>首先定义一个用于组合的函数：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">func</span> <span class=\"selector-tag\">compose</span>(<span class=\"attribute\">filter1</span>: <span class=\"variable\">@escaping</span> Filter, <span class=\"attribute\">fileter2</span>: <span class=\"variable\">@escaping</span> Filter) <span class=\"selector-tag\">-</span>&gt; <span class=\"selector-tag\">Filter</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> &#123; <span class=\"selector-tag\">num</span> <span class=\"selector-tag\">in</span> <span class=\"selector-tag\">fileter2</span>(filter1(num)) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样可以使用复合函数来定义：<br><code>compose(compose(addOne(describe: &quot;1&quot;), addTwo(describe: &quot;2&quot;)), addThree(describe: &quot;3&quot;))(100) // 106</code></p>\n<h5 id=\"自定义运算符\"><a href=\"#自定义运算符\" class=\"headerlink\" title=\"自定义运算符\"></a>自定义运算符</h5><p>但是看起来也很不容易理解。为了让代码更具可读性，我们可以再进一步，为组合引入运算符。</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">infix</span> <span class=\"selector-tag\">operator</span> &gt;&gt;&gt;: <span class=\"selector-tag\">pro</span></span><br><span class=\"line\"><span class=\"selector-tag\">precedencegroup</span> <span class=\"selector-tag\">pro</span> &#123;</span><br><span class=\"line\">    associativity: <span class=\"attribute\">left</span></span><br><span class=\"line\"><span class=\"attribute\">&#125;</span></span><br><span class=\"line\"><span class=\"attribute\"></span></span><br><span class=\"line\"><span class=\"attribute\">func &gt;&gt;&gt;(filter1</span>: <span class=\"variable\">@escaping</span> Filter, <span class=\"attribute\">fileter2</span>: <span class=\"variable\">@escaping</span> Filter) -&gt; Filter &#123;</span><br><span class=\"line\">    return &#123; num in fileter2(filter1(num)) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以用运算符来实现了，</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = add<span class=\"constructor\">One(<span class=\"params\">describe</span>: <span class=\"string\">&quot;1&quot;</span>)</span> &gt;&gt;&gt; add<span class=\"constructor\">Two(<span class=\"params\">describe</span>: <span class=\"string\">&quot;2&quot;</span>)</span> &gt;&gt;&gt; add<span class=\"constructor\">Three(<span class=\"params\">describe</span>: <span class=\"string\">&quot;3&quot;</span>)</span></span><br><span class=\"line\">result(<span class=\"number\">0</span>) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h5><p>函数接受参数之后，返回一个<strong>闭包</strong>，然后等待第二个参数。<code>add(1)(2)</code>。函数中的箭头 -&gt; 向右结合。这也就是说没你可以将 A -&gt; B -&gt; C 理解为 A -&gt; (B -&gt; C)。</p>\n<h4 id=\"Map、Filter-和-Reduce\"><a href=\"#Map、Filter-和-Reduce\" class=\"headerlink\" title=\"Map、Filter 和 Reduce\"></a>Map、Filter 和 Reduce</h4><h5 id=\"Map-和-Filter\"><a href=\"#Map-和-Filter\" class=\"headerlink\" title=\"Map 和 Filter\"></a>Map 和 Filter</h5><p>关于 Map 官网的描述是:</p>\n<blockquote>\n<p>Returns an array containing the results of mapping the given closure over the sequence’s elements.</p>\n</blockquote>\n<p>翻译过来就是: 返回一个数组，数组中的元素是由闭包提供的映射序列产生的。</p>\n<p><code>func map&lt;T&gt;(_ transform: (Element) throws -&gt; T) rethrows -&gt; [T]</code><br>其中关于参数的描述是:</p>\n<blockquote>\n<p>A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.</p>\n</blockquote>\n<p>一个映射的闭包，以一个序列的<strong>每个元素</strong>作为参数，返回一个相同或不同的类型<strong>新值</strong>。可以知道我们需要提供的参数是<strong>一个闭包</strong>。这个闭包中的参数和返回值可以是任意类型的（由泛型定义）。</p>\n<p>Map的定义是这样的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Array</span> </span>&#123;</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">map</span>&lt;<span class=\"type\">T</span>&gt;(<span class=\"params\">transform</span>: <span class=\"type\">Element</span> -&gt; <span class=\"type\">T</span>)</span> -&gt; [<span class=\"type\">T</span>] &#123;</span><br><span class=\"line\">truetrue<span class=\"keyword\">var</span> result: [<span class=\"type\">T</span>] <span class=\"operator\">=</span> []</span><br><span class=\"line\">truetrue<span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">truetruetrueresult.append(transform(x))</span><br><span class=\"line\">truetrue&#125;</span><br><span class=\"line\">truetrue<span class=\"keyword\">return</span> result</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以在调用的时候，我们就需要提供一个变换方法的闭包。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.map &#123; <span class=\"variable\">$0</span>.lowercaseString &#125; <span class=\"regexp\">//</span> [<span class=\"string\">&quot;vivien&quot;</span>, <span class=\"string\">&quot;marlon&quot;</span>, <span class=\"string\">&quot;kim&quot;</span>]</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Reduce\"><a href=\"#Reduce\" class=\"headerlink\" title=\"Reduce\"></a>Reduce</h5><p>关于 Reduce 官网的描述是：</p>\n<blockquote>\n<p>Returns the result of combining the elements of the sequence using the given closure.</p>\n</blockquote>\n<p>翻译过来是：返回组合运算的结果，组合运算是由提供的序列经过闭包处理每个元素产生的。</p>\n<p><code>func reduce&lt;Result&gt;(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -&gt; Result) rethrows -&gt; Result</code></p>\n<h5 id=\"泛型和-Any-类型\"><a href=\"#泛型和-Any-类型\" class=\"headerlink\" title=\"泛型和 Any 类型\"></a>泛型和 Any 类型</h5><p>除了泛型，Swift 还支持 Any 类型，它能代表任何类型的值。泛型可以用于定义灵活的函数，类型检查仍然由编译器负责；而 Any 类型则可以避开 Swift 的类型系统（<strong>所以应该尽可能避免使用</strong>）。</p>\n<p>泛型函数的类型十分丰富，这里我们可以考虑一下上一章对自定义函数组合运算符 &gt;&gt;&gt; 的泛型实现:</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">infix operator &gt;&gt;|: pro</span><br><span class=\"line\">precedencegroup pro &#123;</span><br><span class=\"line\">    associativity: left</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func &gt;&gt;|&lt;A, B, C&gt;<span class=\"function\"><span class=\"params\">(f: @escaping (A) -&gt; (B), g: @escaping (B) -&gt; (C))</span> -&gt;</span> <span class=\"function\"><span class=\"params\">(A)</span> -&gt;</span> (C) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; x <span class=\"keyword\">in</span> g(f(x))&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = addOne(describe: <span class=\"string\">&quot;1&quot;</span>) &gt;&gt;| addTwo(describe: <span class=\"string\">&quot;2&quot;</span>) &gt;&gt;| addThree(describe: <span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">result(<span class=\"number\">10</span>) <span class=\"regexp\">// 16</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可选值\"><a href=\"#可选值\" class=\"headerlink\" title=\"可选值\"></a>可选值</h4><p><code>??</code> 运算符的简易定义是这样的：</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">infix operator ??</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> ??&lt;T&gt;(lhs: T?, rhs: T) -&gt; T &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"literal\">result</span> = lhs &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">result</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rhs</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"literal\">result</span>: <span class=\"type\">Int</span>? = &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">nil</span> &#125;()</span><br><span class=\"line\"><span class=\"literal\">result</span> ?? <span class=\"number\">100</span>\t\t// <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<p><code>??</code> 运算符提供了一个相比于强制可选解包更安全的替代，并且不像可选绑定一样繁琐。</p>\n"},{"layout":"读书","title":"《批判性思维工具》笔记","date":"2017-11-03T09:14:07.000Z","_content":"\n\t心灵各自有所归属，天堂或地狱只在一念之间。 ---《失乐园》\n\n读了很久这本书。内容实在太复杂了，做个笔记慢慢看吧。\n<!---- more --->\n##### 绪论\n1. 了解批判性思维的本质。\n2. 与日常生活的关系。\n3. 用自己的话阐述对批判性思维的理解。\n\n1: 批判性思维的本质是一种对思维方式进行研究和思考。\n2: 生活中各个地方都适用，\n找出他的 <font color=#d13f28>**目的、困难、信息、结论、假设、意义、主要概念**</font>和<font color=#d13f28>**观点**</font>\n并检查他的 <font color=#d13f28>**清晰性、准确性、精准性、相关性、深度、广度、重要性、逻辑性**</font>和<font color=#d13f28>**公正性**</font>\n3: 批判性思维是对思维方式的修正，在考虑问题的时候全面考虑各个方面会出现的问题，多次思考。\n\n##### 第一章：成为公正的思考者\n\n1. 公正性的含义。\n2. 公正性思维的特质。\n3. 如何将公正思维内化为自己自我认同的一部分\n4. 思维特质有哪些？\n\n1: 公正就是要求我们努力平等对待每一种观点\n2: 思维谦逊、思维勇气、思维换位思考、思维正直、思维坚毅、对推理的信心、思维自主\n3: 思考自己是否能够抵抗住外部遵从力量以及内部自我中心思想的影响。\n4: 思维谦逊、思维勇气、思维换位思考、思维正直、思维坚毅、对推理的信心、思维自主。\n\n\n##### 第二章：你处于批判性思维前四个阶段的哪个阶段\n\n1. 如何通过练习来提高我们的思维水平？\n2. 如何意识到我们思维中的错误？\n3. 完善的思考者是如何进行思考的？\n\n1: 每天回忆自己一天的思维，例如 今天哪些时候思维最好，哪些实收思维最差？\n每天解决一个问题。将思维标准内化。坚持做思维日记。\n2: 重塑自我性格，每个月选择一种思维特质。注意到是什么时候什么原因阻碍了思维的学习。关注自己的情绪。\n3: 能够熟练的运用思维工具，应该就是一个完善的思考者吧？我也不知道。。。\n \n\n##### 第三章 自我理解\n\n1. 如何形成思维特质间相互关联的心理网络？\n2. 我们头脑中的什么机制在维护我们自身潜在的以自我为中心？\n3. 如何通过“计划性的训练”培养批判性思维？\n\n1: 我们即刻的欲望、痛苦、想法和感受深深地主导了我们的生活。出于本质上的自私，我们去寻找自我满足。我们需要你自觉的意识到自身的这些倾向，并有意识的通过客观思考去客服它。这要求我们将自己的思维分为两类：1.自我为中性的思维方式。2.理性公平的思维方式。\n2: 大脑拥有3个基本的功能：<font color=#d13f28>**思维**</font>、<font color=#d13f28>**感受**</font>与<font color=#d13f28>**需求**</font>。每一个积极的想法，我们的头脑会很自然的倾向于产生积极情感。相反，对于每个消极的想法，大脑倾向于产生消极的情感。思维的差异导致了行动和情感体验的差异。\n3: 将所学与生活 问题建立联系。当学术逻辑在我们生活中产生积极的意义时，我们会被激发去了解更多内容。如果学习变成了一项苦差，你看不到其中的价值，你会尽可能地拖延。<font color=#d13f28>**整合理智和情感学习的一个关键点在于，识别出每门学科中的思维模式，这些思维模式帮助你理性的思考。**</font>\n\n\n##### 第四章 思维的组成\n\n1. 如何将思维分解为不同的成分？\n2. 什么是思维推理？\n3. 思维的本质是什么？\n\n1: <font color=#d13f28>**目的·观点·假设·意义和结果·推理和判断·理论·解决问题。**</font>\n2: 推理具有<font color=#d13f28>**目的性**</font>，这一目的性是指人们对事物的思考都是与其目标、欲望、需求及价值观相一致的。推理过程常常从一定的<font color=#d13f28>**立场**</font>出发，这是指我们的思维具有指向性。推理是根据特定的问题或<font color=#d13f28>**论点**</font>。\n3: 思维的本质就是如何使用所有能获取的信息，来推理出<font color=#d13f28>**事物的因果关系**</font>。\n\n\n##### 第五章 思维标准\n\n1. 什么是最简化的思维标准？\n2. 如何理解思维标准？\n3. 我们如何使用这些标准评估思维中的一个或多个元素？\n\n\n1: <font color=#d13f28>**清晰性 准确性 精确性 相关性 深度 广度 逻辑性 重要性 公正性**</font>\n2: 批判性思考者需要思考如何提问，而引发自我思考。可以通过提问来提升思维标准。\n\n| 标准思维 | 问题 | 描述 |\n| :-------: | :--- | :--- |\n| 清晰性 | 1.可以详细描述那个观点吗？<br>2.可以用另外一种方式来表达那个观点吗？<br>3.可以给我举个例子嘛？ | 是最基本的标准 |\n| 准确性 | 1.是真的吗？<br>2.如何检查不是准确的？<br>3.如何确定他的准确? | 要表达出与实际事物相一致的信息 |\n| 精准性 | 可以给我更多的细节吗？ | 细节能够优化我们的思考 |\n| 相关性 | 它是怎样对问题产生影响的？ | 相关性思维让我们的思路保持在正常轨道上 |\n| 深度 | 1.如何处理这个问题中最重要的因素？<br>2.你的答案是怎样解决这个复杂问题的？ | 更需要积极思考其中的复杂性 |\n| 广度 | 1.需要考虑另一个观点吗？<br>2.是否存在另一种方式看待这个问题? | 更需要从不同的角度来思考问题 |\n| 逻辑性 | 1.这些组合起来后具有逻辑吗?<br>2.是根据论据推断出来的吗？ | 相互支持并能结合的有意义，这样的思维才有逻辑 |\n| 重要性 | 1.需要明确问题中最重要的信息是什么？<br>2.这些问题中的哪一个是最重要的？| 需要考虑最重要的观点或概念 |\n| 公正性 | 1.这些假设合理吗？<br>2.我考虑到其他可能的证据了吗？ | 公平的思考 |\n\n3: 每一个元素都含有可能出现的错误找到，使用一些检查点，可以提升思维标准。\n\t(1) 所有的思考都有一个目标。\n\t(2) 所有思考都是澄清一些事实，去发现一些问题，解决一些问题。\n\t(3) 所有的思考都要来自一些观点。\n\t(4) 所有的思考都是根据数据、信息和论据做出来的。\n\t(5) 所有的思考都通过概念和理论来表达并塑造。\n\t(6) 所有的思考都觊觎假设。\n\t(7) 所有的思考都会产生一些意义和结果。\n\t(8) 所有的思考均包含推理，以及能够得出结论、赋予数据意义的解释。\n\t\n\n##### 第六章 培养良好思维的提问\n\n1. 提问在发展思维中有何作用?\n2. 三种问题类型是什么？如何以此对提问进行“快速启动”？\n3. 苏格拉底式提问是什么？ \n\n1: 答案不能推动思维的发展，真正能推动思维发展的是问题。提出问题有助于我们清除任务要求，清楚与表达相关的问题，并是我们了解需要处理的事物。<font color=#d13f28>**问题的质量决定着你思考的质量。**</font>\n2:  (1) 基于事实的问题。正确答案只有一个。(2) 基于偏好的问题。纯粹主观意见。(3) 基于判断的问题。并不止一个可行的答案。\n可以在学习时区分问题的三种类型。寻找拥有确定的或正确答案的问题。此外，最为重要的的是，要找出那些可以从**不同角度看待**，接近于可争论的问题。\n3: “苏格拉底”为一般提问方式增加了系统性、深度和强烈的提问兴趣。我们可以从下列方式中提升提问方式。(1) 关注问题类型。(2) 关注思维标准。(3) 关注思维元素。(4) 关注问题优先次序。(5) 关注思维领域。\n\n##### 第七章 掌握思维，掌握内容\n1. 如何超越表面化记忆进行深度学习？\n2. 内容和思维的关系是什么？\n3. 如何运用思维模式来思考？\n\n1: 死记硬背是不可行的，洞悉内容和思维的关键在于，要清楚内容代表了特别的思维方式，需要理解所学内容和思维的关系。**所有的内容都是由概念组成的，所有内容逻辑上市相互依存的**。\n2: 通过思维理解内容，通过内容进行思考。\n3: (1)所有的思维都有<font color=#d13f28>**目的**</font>。(2)所有的思维都<font color=#d13f28>**至少提出一个问题**</font>。(3)所有的思维都<font color=#d13f28>**需要信息支持**</font>。(4)所有的思维都包括<font color=#d13f28>**推论**</font>。(5)所有的思维都包括<font color=#d13f28>**假设**</font>。(6)所有的思维都包括<font color=#d13f28>**预测**</font>。(7)所有的思维都包括<font color=#d13f28>**观点**</font>。(1)所有的思维都<font color=#d13f28>**概念**</font>。\n\n##### 第八章 了解优秀思维者是如何学习的\n1. 我该如何选择并练习哪些策略，可以使自己的学习更有成效？\n2. 课程和学科必要的思维模式是什么？\n\n1:优化学习的策略很多，但并不是每一种策略都需要掌握，找出适合自己的才是最好的。(1) 成为一个勤学好问者，通过问题知道自己掌握了哪些，没有掌握哪些。(2)  尽可能的将学到的内容与现实问题连接起来，注重实际运用。 (3) 经常问自己能否清晰的解释知识，且能让他人准确的听明白。\n2:可以从下面八个结构性问题来界定任何思维模式：\n(1) 该课程或学科的目标是什么？\n(2) 核心问题是什么？\n(3) 基础概念是什么？\n(4) 深入学习该学科需要运用哪些信息？\n(5) 要做出推理，需要哪些观点和参考文献？\n(6) 定义这门课程或学科的假设是什么？\n(7) 我需要哪种结论来学习如何推理？\n(8) 这门学科中科学推理的意义是什么？\n\n##### 第九章 重新评估自己思考和学习的水平\n1.哪些方面应该是模范学生的评判标准？\n\n1: (1).提出重要的问题和论点。\n(2).精准清晰地分析关键问题。\n(3).识别可疑的前提假设。\n(4).有效阐述关键观点。\n(5).识别出相关的竞争性观点。\n(6).审慎地呈现重要的意义和结果。\n(7).根据学科中清晰陈述的前提假设进行认真推理。\n\n##### 第十章 决策和问题解决\n1. 如何克服思维狭隘？\n2. 如何提高自己的掌握决策和问题解决的技巧？\n\n1: 思维过于狭隘很难改正，因为没人愿意相信自己的思维过于狭隘。实际上，思维越窄的人越觉得自己视野开阔。克服思维狭隘，下面两个规则是有用的：规则一：总会有办法的。规则二：总会有另外的解决办法。\n2: (1) 对我们生活中决策的本质和作为做出批判性思考。(2) 判断我们生活中的大问题，进而专注于这些问题的解决。 (3) 系统地采取某些策略来提高我们有效做出理性决策和问题解决的能力。 \n\n##### 第十一章 应对自身的非理性 \n1. 什么是自我中心思维？\n\n1: 自我中心思维源于我们人类天生的狭隘倾向，本能地以符合我们利益的方式解释情景和他人的行为。\n“因为我相信它，所以它是真的。”\n“因为我想相信它，所以它是真的。”\n“相信它符合我们的利益，所以它是真的。”\n“因为我一直相信它，所以它是真的。”\n\n##### 第十二章 如何甄别新闻中的媒体偏见和宣教\n1. 对于新闻如何做到客观性？\n\n1: (1) 确定新闻报道和历史记载中作者的观点。\n(2) 确定新闻报道和历史记载中的目标受众。\n(3) 确定文章中否定和忽视的观点。\n(4) 区别新闻报道中的原始事实和报道中加进去的解释和编造。\n\n##### 第十三章 谬误：心理诡计和操纵诡计\n> 了解人心，就是了解自我欺骗。  \n\n1. 44种赢取辩论的诡计是什么？\n\n<style> table th:first-of-type { width: 220px; } </style>\n\n观点 | 范例 \n:-- | :--\n以其人之道还治其人之身，<br>将对手对你的指责奉还给他。| *你说我不爱你，我认为是你不爱我！* \n指责他犯了滑坡谬误 | *A不是很糟糕，但是A导致了B，B导致了C，C兼职糟糕透顶*  \n诉诸权威 | *他们还会找一些科学家和“学识渊博”的人来支持自己的观点。* \n诉讼经验 | *指责对手的经验不具代表性，是偏颇、歪曲或主观的。* \n诉讼恐惧 | *记住，这些人威胁到我们的自由、我们的生活方式、我们的家园和我们的财产。*\n诉诸怜悯 | *在你批评总统之前，想想他在做着世界上最难做的工作吧。*\n诉诸大众偏好|*回到家乡，和我能够真正信任的人在一起真好。*\n诉诸传统和信仰|*操纵者会表现出坚定不移的相信。*\n采取一个圣洁的姿态|*我们国家有最崇高的理想。当然我们会犯错，但是我们的动机是好的。*\n攻击他人|*谩骂是一种很好的方式。*\n窃取观点|*我们是该站起来去捍卫自由和民主，还是任由恐怖主义和暴政所控？*\n要求完美|*是，我支持民主，但是必须是真正的民主，这意味着在我接受它之前，这儿、那儿都要改变*\n制造出一个虚假两难|*我们要么在发恐怖主义战争中失败，要么放弃我们一贯享有的自由和权力。*\n用类比和隐喻来支持你的观点|*你难道不认为到了我们打击那些对待犯罪软弱的法官的时候了吗？*\n质疑对手的结论|*你说的没有逻辑。你没能证实Y，只证实了X。*\n制造担忧：无风不起浪|*凯文已经承认吸食大麻，这足以让我们看清他了。*\n稻草人谬误|*那我想你是要释放所有的犯人，进而将我们置于更加危险的境地。*\n否认不一致或为不一致辩护|*要么否定矛盾的存在，要么承认矛盾并称这是一个合理的转变*\n妖魔化对手的观点，神化自己的观点|*用消极的词汇来描述对手即可*\n巧妙的回避问题|*问：军队多久才能从X国撤兵？答：只要不需要，我们一天都不会多待。*\n迎合你的受众|*一个真正聪明的人是像你这样不会受骗的人。*\n隐藏自己所述|*当面对压力时，他们会掩盖和回避。*\n忽视证据|*为了不改变自己的立场，操纵者常常会护士证据*\n忽视主要观点|*操纵者知道如果他们在某一议题上不能获胜，他们会想办法将受众的注意转移到另一个点上*\n攻击证据|*没有证据能够是美国政府相信他们做错了。*\n大声坚持次要观点|*我们将将攻击这座城市和一个必胜客快餐店。*\n采用“艰难、残忍世界”的论调|*我们不希望看到战争，我们是被迫加入战争的。*\n做出笼统、粉饰的概括|*我们忠诚于上帝、国家、热爱祖国、家庭和自由市场经济。*\n尽可能找到你对手的不一致处|*发现对手的不一致，并能快速的指责对手的虚伪。*\n是你的对手看起来荒谬可笑|*操纵者使用质疑策略，从而让他们的嘲笑看起来不像是酸葡萄。*\n简化问题|*把你的同情心留给受害者吧，而不是那些罪犯。*\n一直反对|*我会一直提出反对，没有什么能让我相信对手的观点。*\n按照自己的方式重写历史|*你总是看到我们哪里做错了，怎么不去看看我们做对的事情呢？*\n找到自己的既得利益|*你也会这样。*\n改变论据|*如果这都不算接受过教育，我不知道什么才叫受过教育。*\n转移举证责任|*你难道没有反对自由贸易吗？*\n歪曲、歪曲、歪曲|*大多数人已经放弃获取纯粹事实的希望，将自己与歪曲的报道为伍。*\n含糊的概括|*是我们强硬起来的时候了，我们要坚定不移的打击犯罪。*\n故弄玄虚，双言巧语|*我们做就是正确的；他们做就是错误的。*\n撤下弥天大谎|*操纵者不怕，他们知道如果他们足够坚持，人们就会相信。*\n将抽象词描绘的像真的|*我们是自由的代表。*\n转移受众注意力|*真正需要我们关心的是，所有政府都在监管他们的工业。*\n诉诸统计|*你知道吗？有78%的学生读了这本指南后，提高了1.33个水平。*\n双重标准|*我们谴责入侵（除非我们是入侵者）*\n\n##### 第十四章 努力变成一名有道德的推理者\n1. 为什么人们对道德感到困惑？\n\n1: 这源于我们与生俱来的同理心 ———— 想象自己处于他人的位置，对他人的遭遇感同身受。\n\n##### 第十五章 策略性思维：第一部分\n1. 思维、感受和需求是相互依存的。\n2. 这是有逻辑的，并且你能把它弄清楚。\n3. 进行定期评价，提高思维的质量。\n\n1: 我们不能够立即改变我们的需求和感受，我们只与思维有直接联系。即使我对情景的理解是合理的，我的愤怒是合理的，但是考虑到情景的各个方面，我的行为不一定是合理的。<font color=#d13f28>**愤怒是合理的，但不能因此就做出非理性的行为。**</font>\n2: 情景有逻辑，个人行为也有逻辑。有外显和和内隐的逻辑，也有公认的和隐藏的逻辑。<font color=#d13f28>**像质疑自己身边人的思维逻辑一样，质疑你自己的思维逻辑。**</font>\n3: 一定要从思维的标准中来评估自己的思维，熟练从不同的角度来对自己的思维进行评估。\n\n##### 第十六章 策略性思维：第二部分\n1. 自我中心是默认的心理机制。\n2. 审慎对待我们周围人的自我中心 。\n3. 人们倾向于做出超过个人经验的总结。\n4. 误把自我中心思维作为理性思维。 \n5. 自我中心思维是自动发生的\n6. 我们经常通过控制或顺从来谋取权力\n7. 人类的社会中心倾向是天生的\n8. 理性的发展需要练习\n\n1: 人类的心理具有二元性的：一方面，人类具有非理性的本能倾向；另一方面，又具有追求理性的能力。我们必须有能力去监控自我中心的非理性倾向，并且用理性来制衡非理性倾向。\n2: 人越是自我中心，就越拒绝承认自己的自我中心。从他人的观点进行思考，我们就可能预测我们周围人的自我中心反映。这样，我们就可以通过调整自我反应来回避掉他人自我中心的影响。\n3: 在头脑中形成一幅深刻全面的“大图”思维框架，通过在日常生活中尽可能全面地考虑观点，我们能够将自己的直接自我中心倾向减到最小。\n4: 没有真正思考反对观点，对反对者形成刻板印象、护士相关证据、情绪化地反应，以及为非理性的行为找借口。\n5: 我们能够拒绝收到原始需求和思维模式的控制，能够给主动地用理性思维来取代自动的自我中心思维。\n6: 我们对人类生活中控制和顺从的模式了解得越深，我们就能够在自己的生活中觉察到他们。\n7: 我们都在不同程度上不加鉴别地遵守我们群体的规则和期望。\n8: 我们要培养自己经常评价自身思维清晰度、准确性、逻辑性、重要性、广度、深度以及合理性的习惯。\n\n##### 第十七章 成为一名高级的思考者：总结\n因为人生来倾向自欺，所以必须主动调控自己的思维。慢慢蹭蹭的看了半年，总算是把这本书草草的看过一遍，其中的道理和方法还是不怎么理解，可能真的需要在看很多遍，去实践很多遍才能稍微理解吧。不过我们中的大多数都不会成为高级批判性的思考者，就像高校棒球运动员中不会有很多人发展成为专业棒球运动员。但是我们还是需要不断地学习，不断地开发自己的头脑，以及不断地反思批评。这是第一次读完留下的笔记，以后如果有什么思考也慢慢记录吧。\n<p align=\"right\">--------2017年12月14日10:56:44</p>\n","source":"_posts/《批判性思维工具》笔记.md","raw":"---\nlayout: 读书\ntitle: 《批判性思维工具》笔记\ndate: 2017-11-03 17:14:07\ntags:\n- 读书\ncategories: \n- 读书\n---\n\n\t心灵各自有所归属，天堂或地狱只在一念之间。 ---《失乐园》\n\n读了很久这本书。内容实在太复杂了，做个笔记慢慢看吧。\n<!---- more --->\n##### 绪论\n1. 了解批判性思维的本质。\n2. 与日常生活的关系。\n3. 用自己的话阐述对批判性思维的理解。\n\n1: 批判性思维的本质是一种对思维方式进行研究和思考。\n2: 生活中各个地方都适用，\n找出他的 <font color=#d13f28>**目的、困难、信息、结论、假设、意义、主要概念**</font>和<font color=#d13f28>**观点**</font>\n并检查他的 <font color=#d13f28>**清晰性、准确性、精准性、相关性、深度、广度、重要性、逻辑性**</font>和<font color=#d13f28>**公正性**</font>\n3: 批判性思维是对思维方式的修正，在考虑问题的时候全面考虑各个方面会出现的问题，多次思考。\n\n##### 第一章：成为公正的思考者\n\n1. 公正性的含义。\n2. 公正性思维的特质。\n3. 如何将公正思维内化为自己自我认同的一部分\n4. 思维特质有哪些？\n\n1: 公正就是要求我们努力平等对待每一种观点\n2: 思维谦逊、思维勇气、思维换位思考、思维正直、思维坚毅、对推理的信心、思维自主\n3: 思考自己是否能够抵抗住外部遵从力量以及内部自我中心思想的影响。\n4: 思维谦逊、思维勇气、思维换位思考、思维正直、思维坚毅、对推理的信心、思维自主。\n\n\n##### 第二章：你处于批判性思维前四个阶段的哪个阶段\n\n1. 如何通过练习来提高我们的思维水平？\n2. 如何意识到我们思维中的错误？\n3. 完善的思考者是如何进行思考的？\n\n1: 每天回忆自己一天的思维，例如 今天哪些时候思维最好，哪些实收思维最差？\n每天解决一个问题。将思维标准内化。坚持做思维日记。\n2: 重塑自我性格，每个月选择一种思维特质。注意到是什么时候什么原因阻碍了思维的学习。关注自己的情绪。\n3: 能够熟练的运用思维工具，应该就是一个完善的思考者吧？我也不知道。。。\n \n\n##### 第三章 自我理解\n\n1. 如何形成思维特质间相互关联的心理网络？\n2. 我们头脑中的什么机制在维护我们自身潜在的以自我为中心？\n3. 如何通过“计划性的训练”培养批判性思维？\n\n1: 我们即刻的欲望、痛苦、想法和感受深深地主导了我们的生活。出于本质上的自私，我们去寻找自我满足。我们需要你自觉的意识到自身的这些倾向，并有意识的通过客观思考去客服它。这要求我们将自己的思维分为两类：1.自我为中性的思维方式。2.理性公平的思维方式。\n2: 大脑拥有3个基本的功能：<font color=#d13f28>**思维**</font>、<font color=#d13f28>**感受**</font>与<font color=#d13f28>**需求**</font>。每一个积极的想法，我们的头脑会很自然的倾向于产生积极情感。相反，对于每个消极的想法，大脑倾向于产生消极的情感。思维的差异导致了行动和情感体验的差异。\n3: 将所学与生活 问题建立联系。当学术逻辑在我们生活中产生积极的意义时，我们会被激发去了解更多内容。如果学习变成了一项苦差，你看不到其中的价值，你会尽可能地拖延。<font color=#d13f28>**整合理智和情感学习的一个关键点在于，识别出每门学科中的思维模式，这些思维模式帮助你理性的思考。**</font>\n\n\n##### 第四章 思维的组成\n\n1. 如何将思维分解为不同的成分？\n2. 什么是思维推理？\n3. 思维的本质是什么？\n\n1: <font color=#d13f28>**目的·观点·假设·意义和结果·推理和判断·理论·解决问题。**</font>\n2: 推理具有<font color=#d13f28>**目的性**</font>，这一目的性是指人们对事物的思考都是与其目标、欲望、需求及价值观相一致的。推理过程常常从一定的<font color=#d13f28>**立场**</font>出发，这是指我们的思维具有指向性。推理是根据特定的问题或<font color=#d13f28>**论点**</font>。\n3: 思维的本质就是如何使用所有能获取的信息，来推理出<font color=#d13f28>**事物的因果关系**</font>。\n\n\n##### 第五章 思维标准\n\n1. 什么是最简化的思维标准？\n2. 如何理解思维标准？\n3. 我们如何使用这些标准评估思维中的一个或多个元素？\n\n\n1: <font color=#d13f28>**清晰性 准确性 精确性 相关性 深度 广度 逻辑性 重要性 公正性**</font>\n2: 批判性思考者需要思考如何提问，而引发自我思考。可以通过提问来提升思维标准。\n\n| 标准思维 | 问题 | 描述 |\n| :-------: | :--- | :--- |\n| 清晰性 | 1.可以详细描述那个观点吗？<br>2.可以用另外一种方式来表达那个观点吗？<br>3.可以给我举个例子嘛？ | 是最基本的标准 |\n| 准确性 | 1.是真的吗？<br>2.如何检查不是准确的？<br>3.如何确定他的准确? | 要表达出与实际事物相一致的信息 |\n| 精准性 | 可以给我更多的细节吗？ | 细节能够优化我们的思考 |\n| 相关性 | 它是怎样对问题产生影响的？ | 相关性思维让我们的思路保持在正常轨道上 |\n| 深度 | 1.如何处理这个问题中最重要的因素？<br>2.你的答案是怎样解决这个复杂问题的？ | 更需要积极思考其中的复杂性 |\n| 广度 | 1.需要考虑另一个观点吗？<br>2.是否存在另一种方式看待这个问题? | 更需要从不同的角度来思考问题 |\n| 逻辑性 | 1.这些组合起来后具有逻辑吗?<br>2.是根据论据推断出来的吗？ | 相互支持并能结合的有意义，这样的思维才有逻辑 |\n| 重要性 | 1.需要明确问题中最重要的信息是什么？<br>2.这些问题中的哪一个是最重要的？| 需要考虑最重要的观点或概念 |\n| 公正性 | 1.这些假设合理吗？<br>2.我考虑到其他可能的证据了吗？ | 公平的思考 |\n\n3: 每一个元素都含有可能出现的错误找到，使用一些检查点，可以提升思维标准。\n\t(1) 所有的思考都有一个目标。\n\t(2) 所有思考都是澄清一些事实，去发现一些问题，解决一些问题。\n\t(3) 所有的思考都要来自一些观点。\n\t(4) 所有的思考都是根据数据、信息和论据做出来的。\n\t(5) 所有的思考都通过概念和理论来表达并塑造。\n\t(6) 所有的思考都觊觎假设。\n\t(7) 所有的思考都会产生一些意义和结果。\n\t(8) 所有的思考均包含推理，以及能够得出结论、赋予数据意义的解释。\n\t\n\n##### 第六章 培养良好思维的提问\n\n1. 提问在发展思维中有何作用?\n2. 三种问题类型是什么？如何以此对提问进行“快速启动”？\n3. 苏格拉底式提问是什么？ \n\n1: 答案不能推动思维的发展，真正能推动思维发展的是问题。提出问题有助于我们清除任务要求，清楚与表达相关的问题，并是我们了解需要处理的事物。<font color=#d13f28>**问题的质量决定着你思考的质量。**</font>\n2:  (1) 基于事实的问题。正确答案只有一个。(2) 基于偏好的问题。纯粹主观意见。(3) 基于判断的问题。并不止一个可行的答案。\n可以在学习时区分问题的三种类型。寻找拥有确定的或正确答案的问题。此外，最为重要的的是，要找出那些可以从**不同角度看待**，接近于可争论的问题。\n3: “苏格拉底”为一般提问方式增加了系统性、深度和强烈的提问兴趣。我们可以从下列方式中提升提问方式。(1) 关注问题类型。(2) 关注思维标准。(3) 关注思维元素。(4) 关注问题优先次序。(5) 关注思维领域。\n\n##### 第七章 掌握思维，掌握内容\n1. 如何超越表面化记忆进行深度学习？\n2. 内容和思维的关系是什么？\n3. 如何运用思维模式来思考？\n\n1: 死记硬背是不可行的，洞悉内容和思维的关键在于，要清楚内容代表了特别的思维方式，需要理解所学内容和思维的关系。**所有的内容都是由概念组成的，所有内容逻辑上市相互依存的**。\n2: 通过思维理解内容，通过内容进行思考。\n3: (1)所有的思维都有<font color=#d13f28>**目的**</font>。(2)所有的思维都<font color=#d13f28>**至少提出一个问题**</font>。(3)所有的思维都<font color=#d13f28>**需要信息支持**</font>。(4)所有的思维都包括<font color=#d13f28>**推论**</font>。(5)所有的思维都包括<font color=#d13f28>**假设**</font>。(6)所有的思维都包括<font color=#d13f28>**预测**</font>。(7)所有的思维都包括<font color=#d13f28>**观点**</font>。(1)所有的思维都<font color=#d13f28>**概念**</font>。\n\n##### 第八章 了解优秀思维者是如何学习的\n1. 我该如何选择并练习哪些策略，可以使自己的学习更有成效？\n2. 课程和学科必要的思维模式是什么？\n\n1:优化学习的策略很多，但并不是每一种策略都需要掌握，找出适合自己的才是最好的。(1) 成为一个勤学好问者，通过问题知道自己掌握了哪些，没有掌握哪些。(2)  尽可能的将学到的内容与现实问题连接起来，注重实际运用。 (3) 经常问自己能否清晰的解释知识，且能让他人准确的听明白。\n2:可以从下面八个结构性问题来界定任何思维模式：\n(1) 该课程或学科的目标是什么？\n(2) 核心问题是什么？\n(3) 基础概念是什么？\n(4) 深入学习该学科需要运用哪些信息？\n(5) 要做出推理，需要哪些观点和参考文献？\n(6) 定义这门课程或学科的假设是什么？\n(7) 我需要哪种结论来学习如何推理？\n(8) 这门学科中科学推理的意义是什么？\n\n##### 第九章 重新评估自己思考和学习的水平\n1.哪些方面应该是模范学生的评判标准？\n\n1: (1).提出重要的问题和论点。\n(2).精准清晰地分析关键问题。\n(3).识别可疑的前提假设。\n(4).有效阐述关键观点。\n(5).识别出相关的竞争性观点。\n(6).审慎地呈现重要的意义和结果。\n(7).根据学科中清晰陈述的前提假设进行认真推理。\n\n##### 第十章 决策和问题解决\n1. 如何克服思维狭隘？\n2. 如何提高自己的掌握决策和问题解决的技巧？\n\n1: 思维过于狭隘很难改正，因为没人愿意相信自己的思维过于狭隘。实际上，思维越窄的人越觉得自己视野开阔。克服思维狭隘，下面两个规则是有用的：规则一：总会有办法的。规则二：总会有另外的解决办法。\n2: (1) 对我们生活中决策的本质和作为做出批判性思考。(2) 判断我们生活中的大问题，进而专注于这些问题的解决。 (3) 系统地采取某些策略来提高我们有效做出理性决策和问题解决的能力。 \n\n##### 第十一章 应对自身的非理性 \n1. 什么是自我中心思维？\n\n1: 自我中心思维源于我们人类天生的狭隘倾向，本能地以符合我们利益的方式解释情景和他人的行为。\n“因为我相信它，所以它是真的。”\n“因为我想相信它，所以它是真的。”\n“相信它符合我们的利益，所以它是真的。”\n“因为我一直相信它，所以它是真的。”\n\n##### 第十二章 如何甄别新闻中的媒体偏见和宣教\n1. 对于新闻如何做到客观性？\n\n1: (1) 确定新闻报道和历史记载中作者的观点。\n(2) 确定新闻报道和历史记载中的目标受众。\n(3) 确定文章中否定和忽视的观点。\n(4) 区别新闻报道中的原始事实和报道中加进去的解释和编造。\n\n##### 第十三章 谬误：心理诡计和操纵诡计\n> 了解人心，就是了解自我欺骗。  \n\n1. 44种赢取辩论的诡计是什么？\n\n<style> table th:first-of-type { width: 220px; } </style>\n\n观点 | 范例 \n:-- | :--\n以其人之道还治其人之身，<br>将对手对你的指责奉还给他。| *你说我不爱你，我认为是你不爱我！* \n指责他犯了滑坡谬误 | *A不是很糟糕，但是A导致了B，B导致了C，C兼职糟糕透顶*  \n诉诸权威 | *他们还会找一些科学家和“学识渊博”的人来支持自己的观点。* \n诉讼经验 | *指责对手的经验不具代表性，是偏颇、歪曲或主观的。* \n诉讼恐惧 | *记住，这些人威胁到我们的自由、我们的生活方式、我们的家园和我们的财产。*\n诉诸怜悯 | *在你批评总统之前，想想他在做着世界上最难做的工作吧。*\n诉诸大众偏好|*回到家乡，和我能够真正信任的人在一起真好。*\n诉诸传统和信仰|*操纵者会表现出坚定不移的相信。*\n采取一个圣洁的姿态|*我们国家有最崇高的理想。当然我们会犯错，但是我们的动机是好的。*\n攻击他人|*谩骂是一种很好的方式。*\n窃取观点|*我们是该站起来去捍卫自由和民主，还是任由恐怖主义和暴政所控？*\n要求完美|*是，我支持民主，但是必须是真正的民主，这意味着在我接受它之前，这儿、那儿都要改变*\n制造出一个虚假两难|*我们要么在发恐怖主义战争中失败，要么放弃我们一贯享有的自由和权力。*\n用类比和隐喻来支持你的观点|*你难道不认为到了我们打击那些对待犯罪软弱的法官的时候了吗？*\n质疑对手的结论|*你说的没有逻辑。你没能证实Y，只证实了X。*\n制造担忧：无风不起浪|*凯文已经承认吸食大麻，这足以让我们看清他了。*\n稻草人谬误|*那我想你是要释放所有的犯人，进而将我们置于更加危险的境地。*\n否认不一致或为不一致辩护|*要么否定矛盾的存在，要么承认矛盾并称这是一个合理的转变*\n妖魔化对手的观点，神化自己的观点|*用消极的词汇来描述对手即可*\n巧妙的回避问题|*问：军队多久才能从X国撤兵？答：只要不需要，我们一天都不会多待。*\n迎合你的受众|*一个真正聪明的人是像你这样不会受骗的人。*\n隐藏自己所述|*当面对压力时，他们会掩盖和回避。*\n忽视证据|*为了不改变自己的立场，操纵者常常会护士证据*\n忽视主要观点|*操纵者知道如果他们在某一议题上不能获胜，他们会想办法将受众的注意转移到另一个点上*\n攻击证据|*没有证据能够是美国政府相信他们做错了。*\n大声坚持次要观点|*我们将将攻击这座城市和一个必胜客快餐店。*\n采用“艰难、残忍世界”的论调|*我们不希望看到战争，我们是被迫加入战争的。*\n做出笼统、粉饰的概括|*我们忠诚于上帝、国家、热爱祖国、家庭和自由市场经济。*\n尽可能找到你对手的不一致处|*发现对手的不一致，并能快速的指责对手的虚伪。*\n是你的对手看起来荒谬可笑|*操纵者使用质疑策略，从而让他们的嘲笑看起来不像是酸葡萄。*\n简化问题|*把你的同情心留给受害者吧，而不是那些罪犯。*\n一直反对|*我会一直提出反对，没有什么能让我相信对手的观点。*\n按照自己的方式重写历史|*你总是看到我们哪里做错了，怎么不去看看我们做对的事情呢？*\n找到自己的既得利益|*你也会这样。*\n改变论据|*如果这都不算接受过教育，我不知道什么才叫受过教育。*\n转移举证责任|*你难道没有反对自由贸易吗？*\n歪曲、歪曲、歪曲|*大多数人已经放弃获取纯粹事实的希望，将自己与歪曲的报道为伍。*\n含糊的概括|*是我们强硬起来的时候了，我们要坚定不移的打击犯罪。*\n故弄玄虚，双言巧语|*我们做就是正确的；他们做就是错误的。*\n撤下弥天大谎|*操纵者不怕，他们知道如果他们足够坚持，人们就会相信。*\n将抽象词描绘的像真的|*我们是自由的代表。*\n转移受众注意力|*真正需要我们关心的是，所有政府都在监管他们的工业。*\n诉诸统计|*你知道吗？有78%的学生读了这本指南后，提高了1.33个水平。*\n双重标准|*我们谴责入侵（除非我们是入侵者）*\n\n##### 第十四章 努力变成一名有道德的推理者\n1. 为什么人们对道德感到困惑？\n\n1: 这源于我们与生俱来的同理心 ———— 想象自己处于他人的位置，对他人的遭遇感同身受。\n\n##### 第十五章 策略性思维：第一部分\n1. 思维、感受和需求是相互依存的。\n2. 这是有逻辑的，并且你能把它弄清楚。\n3. 进行定期评价，提高思维的质量。\n\n1: 我们不能够立即改变我们的需求和感受，我们只与思维有直接联系。即使我对情景的理解是合理的，我的愤怒是合理的，但是考虑到情景的各个方面，我的行为不一定是合理的。<font color=#d13f28>**愤怒是合理的，但不能因此就做出非理性的行为。**</font>\n2: 情景有逻辑，个人行为也有逻辑。有外显和和内隐的逻辑，也有公认的和隐藏的逻辑。<font color=#d13f28>**像质疑自己身边人的思维逻辑一样，质疑你自己的思维逻辑。**</font>\n3: 一定要从思维的标准中来评估自己的思维，熟练从不同的角度来对自己的思维进行评估。\n\n##### 第十六章 策略性思维：第二部分\n1. 自我中心是默认的心理机制。\n2. 审慎对待我们周围人的自我中心 。\n3. 人们倾向于做出超过个人经验的总结。\n4. 误把自我中心思维作为理性思维。 \n5. 自我中心思维是自动发生的\n6. 我们经常通过控制或顺从来谋取权力\n7. 人类的社会中心倾向是天生的\n8. 理性的发展需要练习\n\n1: 人类的心理具有二元性的：一方面，人类具有非理性的本能倾向；另一方面，又具有追求理性的能力。我们必须有能力去监控自我中心的非理性倾向，并且用理性来制衡非理性倾向。\n2: 人越是自我中心，就越拒绝承认自己的自我中心。从他人的观点进行思考，我们就可能预测我们周围人的自我中心反映。这样，我们就可以通过调整自我反应来回避掉他人自我中心的影响。\n3: 在头脑中形成一幅深刻全面的“大图”思维框架，通过在日常生活中尽可能全面地考虑观点，我们能够将自己的直接自我中心倾向减到最小。\n4: 没有真正思考反对观点，对反对者形成刻板印象、护士相关证据、情绪化地反应，以及为非理性的行为找借口。\n5: 我们能够拒绝收到原始需求和思维模式的控制，能够给主动地用理性思维来取代自动的自我中心思维。\n6: 我们对人类生活中控制和顺从的模式了解得越深，我们就能够在自己的生活中觉察到他们。\n7: 我们都在不同程度上不加鉴别地遵守我们群体的规则和期望。\n8: 我们要培养自己经常评价自身思维清晰度、准确性、逻辑性、重要性、广度、深度以及合理性的习惯。\n\n##### 第十七章 成为一名高级的思考者：总结\n因为人生来倾向自欺，所以必须主动调控自己的思维。慢慢蹭蹭的看了半年，总算是把这本书草草的看过一遍，其中的道理和方法还是不怎么理解，可能真的需要在看很多遍，去实践很多遍才能稍微理解吧。不过我们中的大多数都不会成为高级批判性的思考者，就像高校棒球运动员中不会有很多人发展成为专业棒球运动员。但是我们还是需要不断地学习，不断地开发自己的头脑，以及不断地反思批评。这是第一次读完留下的笔记，以后如果有什么思考也慢慢记录吧。\n<p align=\"right\">--------2017年12月14日10:56:44</p>\n","slug":"《批判性思维工具》笔记","published":1,"updated":"2017-12-14T03:05:22.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyal001e7sn61jvh3pnl","content":"<pre><code>心灵各自有所归属，天堂或地狱只在一念之间。 ---《失乐园》\n</code></pre>\n<p>读了很久这本书。内容实在太复杂了，做个笔记慢慢看吧。</p>\n<!---- more --->\n<h5 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h5><ol>\n<li>了解批判性思维的本质。</li>\n<li>与日常生活的关系。</li>\n<li>用自己的话阐述对批判性思维的理解。</li>\n</ol>\n<p>1: 批判性思维的本质是一种对思维方式进行研究和思考。<br>2: 生活中各个地方都适用，<br>找出他的 <font color=#d13f28><strong>目的、困难、信息、结论、假设、意义、主要概念</strong></font>和<font color=#d13f28><strong>观点</strong></font><br>并检查他的 <font color=#d13f28><strong>清晰性、准确性、精准性、相关性、深度、广度、重要性、逻辑性</strong></font>和<font color=#d13f28><strong>公正性</strong></font><br>3: 批判性思维是对思维方式的修正，在考虑问题的时候全面考虑各个方面会出现的问题，多次思考。</p>\n<h5 id=\"第一章：成为公正的思考者\"><a href=\"#第一章：成为公正的思考者\" class=\"headerlink\" title=\"第一章：成为公正的思考者\"></a>第一章：成为公正的思考者</h5><ol>\n<li>公正性的含义。</li>\n<li>公正性思维的特质。</li>\n<li>如何将公正思维内化为自己自我认同的一部分</li>\n<li>思维特质有哪些？</li>\n</ol>\n<p>1: 公正就是要求我们努力平等对待每一种观点<br>2: 思维谦逊、思维勇气、思维换位思考、思维正直、思维坚毅、对推理的信心、思维自主<br>3: 思考自己是否能够抵抗住外部遵从力量以及内部自我中心思想的影响。<br>4: 思维谦逊、思维勇气、思维换位思考、思维正直、思维坚毅、对推理的信心、思维自主。</p>\n<h5 id=\"第二章：你处于批判性思维前四个阶段的哪个阶段\"><a href=\"#第二章：你处于批判性思维前四个阶段的哪个阶段\" class=\"headerlink\" title=\"第二章：你处于批判性思维前四个阶段的哪个阶段\"></a>第二章：你处于批判性思维前四个阶段的哪个阶段</h5><ol>\n<li>如何通过练习来提高我们的思维水平？</li>\n<li>如何意识到我们思维中的错误？</li>\n<li>完善的思考者是如何进行思考的？</li>\n</ol>\n<p>1: 每天回忆自己一天的思维，例如 今天哪些时候思维最好，哪些实收思维最差？<br>每天解决一个问题。将思维标准内化。坚持做思维日记。<br>2: 重塑自我性格，每个月选择一种思维特质。注意到是什么时候什么原因阻碍了思维的学习。关注自己的情绪。<br>3: 能够熟练的运用思维工具，应该就是一个完善的思考者吧？我也不知道。。。</p>\n<h5 id=\"第三章-自我理解\"><a href=\"#第三章-自我理解\" class=\"headerlink\" title=\"第三章 自我理解\"></a>第三章 自我理解</h5><ol>\n<li>如何形成思维特质间相互关联的心理网络？</li>\n<li>我们头脑中的什么机制在维护我们自身潜在的以自我为中心？</li>\n<li>如何通过“计划性的训练”培养批判性思维？</li>\n</ol>\n<p>1: 我们即刻的欲望、痛苦、想法和感受深深地主导了我们的生活。出于本质上的自私，我们去寻找自我满足。我们需要你自觉的意识到自身的这些倾向，并有意识的通过客观思考去客服它。这要求我们将自己的思维分为两类：1.自我为中性的思维方式。2.理性公平的思维方式。<br>2: 大脑拥有3个基本的功能：<font color=#d13f28><strong>思维</strong></font>、<font color=#d13f28><strong>感受</strong></font>与<font color=#d13f28><strong>需求</strong></font>。每一个积极的想法，我们的头脑会很自然的倾向于产生积极情感。相反，对于每个消极的想法，大脑倾向于产生消极的情感。思维的差异导致了行动和情感体验的差异。<br>3: 将所学与生活 问题建立联系。当学术逻辑在我们生活中产生积极的意义时，我们会被激发去了解更多内容。如果学习变成了一项苦差，你看不到其中的价值，你会尽可能地拖延。<font color=#d13f28><strong>整合理智和情感学习的一个关键点在于，识别出每门学科中的思维模式，这些思维模式帮助你理性的思考。</strong></font></p>\n<h5 id=\"第四章-思维的组成\"><a href=\"#第四章-思维的组成\" class=\"headerlink\" title=\"第四章 思维的组成\"></a>第四章 思维的组成</h5><ol>\n<li>如何将思维分解为不同的成分？</li>\n<li>什么是思维推理？</li>\n<li>思维的本质是什么？</li>\n</ol>\n<p>1: <font color=#d13f28><strong>目的·观点·假设·意义和结果·推理和判断·理论·解决问题。</strong></font><br>2: 推理具有<font color=#d13f28><strong>目的性</strong></font>，这一目的性是指人们对事物的思考都是与其目标、欲望、需求及价值观相一致的。推理过程常常从一定的<font color=#d13f28><strong>立场</strong></font>出发，这是指我们的思维具有指向性。推理是根据特定的问题或<font color=#d13f28><strong>论点</strong></font>。<br>3: 思维的本质就是如何使用所有能获取的信息，来推理出<font color=#d13f28><strong>事物的因果关系</strong></font>。</p>\n<h5 id=\"第五章-思维标准\"><a href=\"#第五章-思维标准\" class=\"headerlink\" title=\"第五章 思维标准\"></a>第五章 思维标准</h5><ol>\n<li>什么是最简化的思维标准？</li>\n<li>如何理解思维标准？</li>\n<li>我们如何使用这些标准评估思维中的一个或多个元素？</li>\n</ol>\n<p>1: <font color=#d13f28><strong>清晰性 准确性 精确性 相关性 深度 广度 逻辑性 重要性 公正性</strong></font><br>2: 批判性思考者需要思考如何提问，而引发自我思考。可以通过提问来提升思维标准。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">标准思维</th>\n<th align=\"left\">问题</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">清晰性</td>\n<td align=\"left\">1.可以详细描述那个观点吗？<br>2.可以用另外一种方式来表达那个观点吗？<br>3.可以给我举个例子嘛？</td>\n<td align=\"left\">是最基本的标准</td>\n</tr>\n<tr>\n<td align=\"center\">准确性</td>\n<td align=\"left\">1.是真的吗？<br>2.如何检查不是准确的？<br>3.如何确定他的准确?</td>\n<td align=\"left\">要表达出与实际事物相一致的信息</td>\n</tr>\n<tr>\n<td align=\"center\">精准性</td>\n<td align=\"left\">可以给我更多的细节吗？</td>\n<td align=\"left\">细节能够优化我们的思考</td>\n</tr>\n<tr>\n<td align=\"center\">相关性</td>\n<td align=\"left\">它是怎样对问题产生影响的？</td>\n<td align=\"left\">相关性思维让我们的思路保持在正常轨道上</td>\n</tr>\n<tr>\n<td align=\"center\">深度</td>\n<td align=\"left\">1.如何处理这个问题中最重要的因素？<br>2.你的答案是怎样解决这个复杂问题的？</td>\n<td align=\"left\">更需要积极思考其中的复杂性</td>\n</tr>\n<tr>\n<td align=\"center\">广度</td>\n<td align=\"left\">1.需要考虑另一个观点吗？<br>2.是否存在另一种方式看待这个问题?</td>\n<td align=\"left\">更需要从不同的角度来思考问题</td>\n</tr>\n<tr>\n<td align=\"center\">逻辑性</td>\n<td align=\"left\">1.这些组合起来后具有逻辑吗?<br>2.是根据论据推断出来的吗？</td>\n<td align=\"left\">相互支持并能结合的有意义，这样的思维才有逻辑</td>\n</tr>\n<tr>\n<td align=\"center\">重要性</td>\n<td align=\"left\">1.需要明确问题中最重要的信息是什么？<br>2.这些问题中的哪一个是最重要的？</td>\n<td align=\"left\">需要考虑最重要的观点或概念</td>\n</tr>\n<tr>\n<td align=\"center\">公正性</td>\n<td align=\"left\">1.这些假设合理吗？<br>2.我考虑到其他可能的证据了吗？</td>\n<td align=\"left\">公平的思考</td>\n</tr>\n</tbody></table>\n<p>3: 每一个元素都含有可能出现的错误找到，使用一些检查点，可以提升思维标准。<br>    (1) 所有的思考都有一个目标。<br>    (2) 所有思考都是澄清一些事实，去发现一些问题，解决一些问题。<br>    (3) 所有的思考都要来自一些观点。<br>    (4) 所有的思考都是根据数据、信息和论据做出来的。<br>    (5) 所有的思考都通过概念和理论来表达并塑造。<br>    (6) 所有的思考都觊觎假设。<br>    (7) 所有的思考都会产生一些意义和结果。<br>    (8) 所有的思考均包含推理，以及能够得出结论、赋予数据意义的解释。</p>\n<h5 id=\"第六章-培养良好思维的提问\"><a href=\"#第六章-培养良好思维的提问\" class=\"headerlink\" title=\"第六章 培养良好思维的提问\"></a>第六章 培养良好思维的提问</h5><ol>\n<li>提问在发展思维中有何作用?</li>\n<li>三种问题类型是什么？如何以此对提问进行“快速启动”？</li>\n<li>苏格拉底式提问是什么？ </li>\n</ol>\n<p>1: 答案不能推动思维的发展，真正能推动思维发展的是问题。提出问题有助于我们清除任务要求，清楚与表达相关的问题，并是我们了解需要处理的事物。<font color=#d13f28><strong>问题的质量决定着你思考的质量。</strong></font><br>2:  (1) 基于事实的问题。正确答案只有一个。(2) 基于偏好的问题。纯粹主观意见。(3) 基于判断的问题。并不止一个可行的答案。<br>可以在学习时区分问题的三种类型。寻找拥有确定的或正确答案的问题。此外，最为重要的的是，要找出那些可以从<strong>不同角度看待</strong>，接近于可争论的问题。<br>3: “苏格拉底”为一般提问方式增加了系统性、深度和强烈的提问兴趣。我们可以从下列方式中提升提问方式。(1) 关注问题类型。(2) 关注思维标准。(3) 关注思维元素。(4) 关注问题优先次序。(5) 关注思维领域。</p>\n<h5 id=\"第七章-掌握思维，掌握内容\"><a href=\"#第七章-掌握思维，掌握内容\" class=\"headerlink\" title=\"第七章 掌握思维，掌握内容\"></a>第七章 掌握思维，掌握内容</h5><ol>\n<li>如何超越表面化记忆进行深度学习？</li>\n<li>内容和思维的关系是什么？</li>\n<li>如何运用思维模式来思考？</li>\n</ol>\n<p>1: 死记硬背是不可行的，洞悉内容和思维的关键在于，要清楚内容代表了特别的思维方式，需要理解所学内容和思维的关系。<strong>所有的内容都是由概念组成的，所有内容逻辑上市相互依存的</strong>。<br>2: 通过思维理解内容，通过内容进行思考。<br>3: (1)所有的思维都有<font color=#d13f28><strong>目的</strong></font>。(2)所有的思维都<font color=#d13f28><strong>至少提出一个问题</strong></font>。(3)所有的思维都<font color=#d13f28><strong>需要信息支持</strong></font>。(4)所有的思维都包括<font color=#d13f28><strong>推论</strong></font>。(5)所有的思维都包括<font color=#d13f28><strong>假设</strong></font>。(6)所有的思维都包括<font color=#d13f28><strong>预测</strong></font>。(7)所有的思维都包括<font color=#d13f28><strong>观点</strong></font>。(1)所有的思维都<font color=#d13f28><strong>概念</strong></font>。</p>\n<h5 id=\"第八章-了解优秀思维者是如何学习的\"><a href=\"#第八章-了解优秀思维者是如何学习的\" class=\"headerlink\" title=\"第八章 了解优秀思维者是如何学习的\"></a>第八章 了解优秀思维者是如何学习的</h5><ol>\n<li>我该如何选择并练习哪些策略，可以使自己的学习更有成效？</li>\n<li>课程和学科必要的思维模式是什么？</li>\n</ol>\n<p>1:优化学习的策略很多，但并不是每一种策略都需要掌握，找出适合自己的才是最好的。(1) 成为一个勤学好问者，通过问题知道自己掌握了哪些，没有掌握哪些。(2)  尽可能的将学到的内容与现实问题连接起来，注重实际运用。 (3) 经常问自己能否清晰的解释知识，且能让他人准确的听明白。<br>2:可以从下面八个结构性问题来界定任何思维模式：<br>(1) 该课程或学科的目标是什么？<br>(2) 核心问题是什么？<br>(3) 基础概念是什么？<br>(4) 深入学习该学科需要运用哪些信息？<br>(5) 要做出推理，需要哪些观点和参考文献？<br>(6) 定义这门课程或学科的假设是什么？<br>(7) 我需要哪种结论来学习如何推理？<br>(8) 这门学科中科学推理的意义是什么？</p>\n<h5 id=\"第九章-重新评估自己思考和学习的水平\"><a href=\"#第九章-重新评估自己思考和学习的水平\" class=\"headerlink\" title=\"第九章 重新评估自己思考和学习的水平\"></a>第九章 重新评估自己思考和学习的水平</h5><p>1.哪些方面应该是模范学生的评判标准？</p>\n<p>1: (1).提出重要的问题和论点。<br>(2).精准清晰地分析关键问题。<br>(3).识别可疑的前提假设。<br>(4).有效阐述关键观点。<br>(5).识别出相关的竞争性观点。<br>(6).审慎地呈现重要的意义和结果。<br>(7).根据学科中清晰陈述的前提假设进行认真推理。</p>\n<h5 id=\"第十章-决策和问题解决\"><a href=\"#第十章-决策和问题解决\" class=\"headerlink\" title=\"第十章 决策和问题解决\"></a>第十章 决策和问题解决</h5><ol>\n<li>如何克服思维狭隘？</li>\n<li>如何提高自己的掌握决策和问题解决的技巧？</li>\n</ol>\n<p>1: 思维过于狭隘很难改正，因为没人愿意相信自己的思维过于狭隘。实际上，思维越窄的人越觉得自己视野开阔。克服思维狭隘，下面两个规则是有用的：规则一：总会有办法的。规则二：总会有另外的解决办法。<br>2: (1) 对我们生活中决策的本质和作为做出批判性思考。(2) 判断我们生活中的大问题，进而专注于这些问题的解决。 (3) 系统地采取某些策略来提高我们有效做出理性决策和问题解决的能力。 </p>\n<h5 id=\"第十一章-应对自身的非理性\"><a href=\"#第十一章-应对自身的非理性\" class=\"headerlink\" title=\"第十一章 应对自身的非理性\"></a>第十一章 应对自身的非理性</h5><ol>\n<li>什么是自我中心思维？</li>\n</ol>\n<p>1: 自我中心思维源于我们人类天生的狭隘倾向，本能地以符合我们利益的方式解释情景和他人的行为。<br>“因为我相信它，所以它是真的。”<br>“因为我想相信它，所以它是真的。”<br>“相信它符合我们的利益，所以它是真的。”<br>“因为我一直相信它，所以它是真的。”</p>\n<h5 id=\"第十二章-如何甄别新闻中的媒体偏见和宣教\"><a href=\"#第十二章-如何甄别新闻中的媒体偏见和宣教\" class=\"headerlink\" title=\"第十二章 如何甄别新闻中的媒体偏见和宣教\"></a>第十二章 如何甄别新闻中的媒体偏见和宣教</h5><ol>\n<li>对于新闻如何做到客观性？</li>\n</ol>\n<p>1: (1) 确定新闻报道和历史记载中作者的观点。<br>(2) 确定新闻报道和历史记载中的目标受众。<br>(3) 确定文章中否定和忽视的观点。<br>(4) 区别新闻报道中的原始事实和报道中加进去的解释和编造。</p>\n<h5 id=\"第十三章-谬误：心理诡计和操纵诡计\"><a href=\"#第十三章-谬误：心理诡计和操纵诡计\" class=\"headerlink\" title=\"第十三章 谬误：心理诡计和操纵诡计\"></a>第十三章 谬误：心理诡计和操纵诡计</h5><blockquote>\n<p>了解人心，就是了解自我欺骗。  </p>\n</blockquote>\n<ol>\n<li>44种赢取辩论的诡计是什么？</li>\n</ol>\n<style> table th:first-of-type { width: 220px; } </style>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">观点</th>\n<th align=\"left\">范例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">以其人之道还治其人之身，<br>将对手对你的指责奉还给他。</td>\n<td align=\"left\"><em>你说我不爱你，我认为是你不爱我！</em></td>\n</tr>\n<tr>\n<td align=\"left\">指责他犯了滑坡谬误</td>\n<td align=\"left\"><em>A不是很糟糕，但是A导致了B，B导致了C，C兼职糟糕透顶</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉诸权威</td>\n<td align=\"left\"><em>他们还会找一些科学家和“学识渊博”的人来支持自己的观点。</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉讼经验</td>\n<td align=\"left\"><em>指责对手的经验不具代表性，是偏颇、歪曲或主观的。</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉讼恐惧</td>\n<td align=\"left\"><em>记住，这些人威胁到我们的自由、我们的生活方式、我们的家园和我们的财产。</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉诸怜悯</td>\n<td align=\"left\"><em>在你批评总统之前，想想他在做着世界上最难做的工作吧。</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉诸大众偏好</td>\n<td align=\"left\"><em>回到家乡，和我能够真正信任的人在一起真好。</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉诸传统和信仰</td>\n<td align=\"left\"><em>操纵者会表现出坚定不移的相信。</em></td>\n</tr>\n<tr>\n<td align=\"left\">采取一个圣洁的姿态</td>\n<td align=\"left\"><em>我们国家有最崇高的理想。当然我们会犯错，但是我们的动机是好的。</em></td>\n</tr>\n<tr>\n<td align=\"left\">攻击他人</td>\n<td align=\"left\"><em>谩骂是一种很好的方式。</em></td>\n</tr>\n<tr>\n<td align=\"left\">窃取观点</td>\n<td align=\"left\"><em>我们是该站起来去捍卫自由和民主，还是任由恐怖主义和暴政所控？</em></td>\n</tr>\n<tr>\n<td align=\"left\">要求完美</td>\n<td align=\"left\"><em>是，我支持民主，但是必须是真正的民主，这意味着在我接受它之前，这儿、那儿都要改变</em></td>\n</tr>\n<tr>\n<td align=\"left\">制造出一个虚假两难</td>\n<td align=\"left\"><em>我们要么在发恐怖主义战争中失败，要么放弃我们一贯享有的自由和权力。</em></td>\n</tr>\n<tr>\n<td align=\"left\">用类比和隐喻来支持你的观点</td>\n<td align=\"left\"><em>你难道不认为到了我们打击那些对待犯罪软弱的法官的时候了吗？</em></td>\n</tr>\n<tr>\n<td align=\"left\">质疑对手的结论</td>\n<td align=\"left\"><em>你说的没有逻辑。你没能证实Y，只证实了X。</em></td>\n</tr>\n<tr>\n<td align=\"left\">制造担忧：无风不起浪</td>\n<td align=\"left\"><em>凯文已经承认吸食大麻，这足以让我们看清他了。</em></td>\n</tr>\n<tr>\n<td align=\"left\">稻草人谬误</td>\n<td align=\"left\"><em>那我想你是要释放所有的犯人，进而将我们置于更加危险的境地。</em></td>\n</tr>\n<tr>\n<td align=\"left\">否认不一致或为不一致辩护</td>\n<td align=\"left\"><em>要么否定矛盾的存在，要么承认矛盾并称这是一个合理的转变</em></td>\n</tr>\n<tr>\n<td align=\"left\">妖魔化对手的观点，神化自己的观点</td>\n<td align=\"left\"><em>用消极的词汇来描述对手即可</em></td>\n</tr>\n<tr>\n<td align=\"left\">巧妙的回避问题</td>\n<td align=\"left\"><em>问：军队多久才能从X国撤兵？答：只要不需要，我们一天都不会多待。</em></td>\n</tr>\n<tr>\n<td align=\"left\">迎合你的受众</td>\n<td align=\"left\"><em>一个真正聪明的人是像你这样不会受骗的人。</em></td>\n</tr>\n<tr>\n<td align=\"left\">隐藏自己所述</td>\n<td align=\"left\"><em>当面对压力时，他们会掩盖和回避。</em></td>\n</tr>\n<tr>\n<td align=\"left\">忽视证据</td>\n<td align=\"left\"><em>为了不改变自己的立场，操纵者常常会护士证据</em></td>\n</tr>\n<tr>\n<td align=\"left\">忽视主要观点</td>\n<td align=\"left\"><em>操纵者知道如果他们在某一议题上不能获胜，他们会想办法将受众的注意转移到另一个点上</em></td>\n</tr>\n<tr>\n<td align=\"left\">攻击证据</td>\n<td align=\"left\"><em>没有证据能够是美国政府相信他们做错了。</em></td>\n</tr>\n<tr>\n<td align=\"left\">大声坚持次要观点</td>\n<td align=\"left\"><em>我们将将攻击这座城市和一个必胜客快餐店。</em></td>\n</tr>\n<tr>\n<td align=\"left\">采用“艰难、残忍世界”的论调</td>\n<td align=\"left\"><em>我们不希望看到战争，我们是被迫加入战争的。</em></td>\n</tr>\n<tr>\n<td align=\"left\">做出笼统、粉饰的概括</td>\n<td align=\"left\"><em>我们忠诚于上帝、国家、热爱祖国、家庭和自由市场经济。</em></td>\n</tr>\n<tr>\n<td align=\"left\">尽可能找到你对手的不一致处</td>\n<td align=\"left\"><em>发现对手的不一致，并能快速的指责对手的虚伪。</em></td>\n</tr>\n<tr>\n<td align=\"left\">是你的对手看起来荒谬可笑</td>\n<td align=\"left\"><em>操纵者使用质疑策略，从而让他们的嘲笑看起来不像是酸葡萄。</em></td>\n</tr>\n<tr>\n<td align=\"left\">简化问题</td>\n<td align=\"left\"><em>把你的同情心留给受害者吧，而不是那些罪犯。</em></td>\n</tr>\n<tr>\n<td align=\"left\">一直反对</td>\n<td align=\"left\"><em>我会一直提出反对，没有什么能让我相信对手的观点。</em></td>\n</tr>\n<tr>\n<td align=\"left\">按照自己的方式重写历史</td>\n<td align=\"left\"><em>你总是看到我们哪里做错了，怎么不去看看我们做对的事情呢？</em></td>\n</tr>\n<tr>\n<td align=\"left\">找到自己的既得利益</td>\n<td align=\"left\"><em>你也会这样。</em></td>\n</tr>\n<tr>\n<td align=\"left\">改变论据</td>\n<td align=\"left\"><em>如果这都不算接受过教育，我不知道什么才叫受过教育。</em></td>\n</tr>\n<tr>\n<td align=\"left\">转移举证责任</td>\n<td align=\"left\"><em>你难道没有反对自由贸易吗？</em></td>\n</tr>\n<tr>\n<td align=\"left\">歪曲、歪曲、歪曲</td>\n<td align=\"left\"><em>大多数人已经放弃获取纯粹事实的希望，将自己与歪曲的报道为伍。</em></td>\n</tr>\n<tr>\n<td align=\"left\">含糊的概括</td>\n<td align=\"left\"><em>是我们强硬起来的时候了，我们要坚定不移的打击犯罪。</em></td>\n</tr>\n<tr>\n<td align=\"left\">故弄玄虚，双言巧语</td>\n<td align=\"left\"><em>我们做就是正确的；他们做就是错误的。</em></td>\n</tr>\n<tr>\n<td align=\"left\">撤下弥天大谎</td>\n<td align=\"left\"><em>操纵者不怕，他们知道如果他们足够坚持，人们就会相信。</em></td>\n</tr>\n<tr>\n<td align=\"left\">将抽象词描绘的像真的</td>\n<td align=\"left\"><em>我们是自由的代表。</em></td>\n</tr>\n<tr>\n<td align=\"left\">转移受众注意力</td>\n<td align=\"left\"><em>真正需要我们关心的是，所有政府都在监管他们的工业。</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉诸统计</td>\n<td align=\"left\"><em>你知道吗？有78%的学生读了这本指南后，提高了1.33个水平。</em></td>\n</tr>\n<tr>\n<td align=\"left\">双重标准</td>\n<td align=\"left\"><em>我们谴责入侵（除非我们是入侵者）</em></td>\n</tr>\n</tbody></table>\n<h5 id=\"第十四章-努力变成一名有道德的推理者\"><a href=\"#第十四章-努力变成一名有道德的推理者\" class=\"headerlink\" title=\"第十四章 努力变成一名有道德的推理者\"></a>第十四章 努力变成一名有道德的推理者</h5><ol>\n<li>为什么人们对道德感到困惑？</li>\n</ol>\n<p>1: 这源于我们与生俱来的同理心 ———— 想象自己处于他人的位置，对他人的遭遇感同身受。</p>\n<h5 id=\"第十五章-策略性思维：第一部分\"><a href=\"#第十五章-策略性思维：第一部分\" class=\"headerlink\" title=\"第十五章 策略性思维：第一部分\"></a>第十五章 策略性思维：第一部分</h5><ol>\n<li>思维、感受和需求是相互依存的。</li>\n<li>这是有逻辑的，并且你能把它弄清楚。</li>\n<li>进行定期评价，提高思维的质量。</li>\n</ol>\n<p>1: 我们不能够立即改变我们的需求和感受，我们只与思维有直接联系。即使我对情景的理解是合理的，我的愤怒是合理的，但是考虑到情景的各个方面，我的行为不一定是合理的。<font color=#d13f28><strong>愤怒是合理的，但不能因此就做出非理性的行为。</strong></font><br>2: 情景有逻辑，个人行为也有逻辑。有外显和和内隐的逻辑，也有公认的和隐藏的逻辑。<font color=#d13f28><strong>像质疑自己身边人的思维逻辑一样，质疑你自己的思维逻辑。</strong></font><br>3: 一定要从思维的标准中来评估自己的思维，熟练从不同的角度来对自己的思维进行评估。</p>\n<h5 id=\"第十六章-策略性思维：第二部分\"><a href=\"#第十六章-策略性思维：第二部分\" class=\"headerlink\" title=\"第十六章 策略性思维：第二部分\"></a>第十六章 策略性思维：第二部分</h5><ol>\n<li>自我中心是默认的心理机制。</li>\n<li>审慎对待我们周围人的自我中心 。</li>\n<li>人们倾向于做出超过个人经验的总结。</li>\n<li>误把自我中心思维作为理性思维。 </li>\n<li>自我中心思维是自动发生的</li>\n<li>我们经常通过控制或顺从来谋取权力</li>\n<li>人类的社会中心倾向是天生的</li>\n<li>理性的发展需要练习</li>\n</ol>\n<p>1: 人类的心理具有二元性的：一方面，人类具有非理性的本能倾向；另一方面，又具有追求理性的能力。我们必须有能力去监控自我中心的非理性倾向，并且用理性来制衡非理性倾向。<br>2: 人越是自我中心，就越拒绝承认自己的自我中心。从他人的观点进行思考，我们就可能预测我们周围人的自我中心反映。这样，我们就可以通过调整自我反应来回避掉他人自我中心的影响。<br>3: 在头脑中形成一幅深刻全面的“大图”思维框架，通过在日常生活中尽可能全面地考虑观点，我们能够将自己的直接自我中心倾向减到最小。<br>4: 没有真正思考反对观点，对反对者形成刻板印象、护士相关证据、情绪化地反应，以及为非理性的行为找借口。<br>5: 我们能够拒绝收到原始需求和思维模式的控制，能够给主动地用理性思维来取代自动的自我中心思维。<br>6: 我们对人类生活中控制和顺从的模式了解得越深，我们就能够在自己的生活中觉察到他们。<br>7: 我们都在不同程度上不加鉴别地遵守我们群体的规则和期望。<br>8: 我们要培养自己经常评价自身思维清晰度、准确性、逻辑性、重要性、广度、深度以及合理性的习惯。</p>\n<h5 id=\"第十七章-成为一名高级的思考者：总结\"><a href=\"#第十七章-成为一名高级的思考者：总结\" class=\"headerlink\" title=\"第十七章 成为一名高级的思考者：总结\"></a>第十七章 成为一名高级的思考者：总结</h5><p>因为人生来倾向自欺，所以必须主动调控自己的思维。慢慢蹭蹭的看了半年，总算是把这本书草草的看过一遍，其中的道理和方法还是不怎么理解，可能真的需要在看很多遍，去实践很多遍才能稍微理解吧。不过我们中的大多数都不会成为高级批判性的思考者，就像高校棒球运动员中不会有很多人发展成为专业棒球运动员。但是我们还是需要不断地学习，不断地开发自己的头脑，以及不断地反思批评。这是第一次读完留下的笔记，以后如果有什么思考也慢慢记录吧。</p>\n<p align=\"right\">--------2017年12月14日10:56:44</p>\n","site":{"data":{}},"excerpt":"","more":"<pre><code>心灵各自有所归属，天堂或地狱只在一念之间。 ---《失乐园》\n</code></pre>\n<p>读了很久这本书。内容实在太复杂了，做个笔记慢慢看吧。</p>\n<!---- more --->\n<h5 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h5><ol>\n<li>了解批判性思维的本质。</li>\n<li>与日常生活的关系。</li>\n<li>用自己的话阐述对批判性思维的理解。</li>\n</ol>\n<p>1: 批判性思维的本质是一种对思维方式进行研究和思考。<br>2: 生活中各个地方都适用，<br>找出他的 <font color=#d13f28><strong>目的、困难、信息、结论、假设、意义、主要概念</strong></font>和<font color=#d13f28><strong>观点</strong></font><br>并检查他的 <font color=#d13f28><strong>清晰性、准确性、精准性、相关性、深度、广度、重要性、逻辑性</strong></font>和<font color=#d13f28><strong>公正性</strong></font><br>3: 批判性思维是对思维方式的修正，在考虑问题的时候全面考虑各个方面会出现的问题，多次思考。</p>\n<h5 id=\"第一章：成为公正的思考者\"><a href=\"#第一章：成为公正的思考者\" class=\"headerlink\" title=\"第一章：成为公正的思考者\"></a>第一章：成为公正的思考者</h5><ol>\n<li>公正性的含义。</li>\n<li>公正性思维的特质。</li>\n<li>如何将公正思维内化为自己自我认同的一部分</li>\n<li>思维特质有哪些？</li>\n</ol>\n<p>1: 公正就是要求我们努力平等对待每一种观点<br>2: 思维谦逊、思维勇气、思维换位思考、思维正直、思维坚毅、对推理的信心、思维自主<br>3: 思考自己是否能够抵抗住外部遵从力量以及内部自我中心思想的影响。<br>4: 思维谦逊、思维勇气、思维换位思考、思维正直、思维坚毅、对推理的信心、思维自主。</p>\n<h5 id=\"第二章：你处于批判性思维前四个阶段的哪个阶段\"><a href=\"#第二章：你处于批判性思维前四个阶段的哪个阶段\" class=\"headerlink\" title=\"第二章：你处于批判性思维前四个阶段的哪个阶段\"></a>第二章：你处于批判性思维前四个阶段的哪个阶段</h5><ol>\n<li>如何通过练习来提高我们的思维水平？</li>\n<li>如何意识到我们思维中的错误？</li>\n<li>完善的思考者是如何进行思考的？</li>\n</ol>\n<p>1: 每天回忆自己一天的思维，例如 今天哪些时候思维最好，哪些实收思维最差？<br>每天解决一个问题。将思维标准内化。坚持做思维日记。<br>2: 重塑自我性格，每个月选择一种思维特质。注意到是什么时候什么原因阻碍了思维的学习。关注自己的情绪。<br>3: 能够熟练的运用思维工具，应该就是一个完善的思考者吧？我也不知道。。。</p>\n<h5 id=\"第三章-自我理解\"><a href=\"#第三章-自我理解\" class=\"headerlink\" title=\"第三章 自我理解\"></a>第三章 自我理解</h5><ol>\n<li>如何形成思维特质间相互关联的心理网络？</li>\n<li>我们头脑中的什么机制在维护我们自身潜在的以自我为中心？</li>\n<li>如何通过“计划性的训练”培养批判性思维？</li>\n</ol>\n<p>1: 我们即刻的欲望、痛苦、想法和感受深深地主导了我们的生活。出于本质上的自私，我们去寻找自我满足。我们需要你自觉的意识到自身的这些倾向，并有意识的通过客观思考去客服它。这要求我们将自己的思维分为两类：1.自我为中性的思维方式。2.理性公平的思维方式。<br>2: 大脑拥有3个基本的功能：<font color=#d13f28><strong>思维</strong></font>、<font color=#d13f28><strong>感受</strong></font>与<font color=#d13f28><strong>需求</strong></font>。每一个积极的想法，我们的头脑会很自然的倾向于产生积极情感。相反，对于每个消极的想法，大脑倾向于产生消极的情感。思维的差异导致了行动和情感体验的差异。<br>3: 将所学与生活 问题建立联系。当学术逻辑在我们生活中产生积极的意义时，我们会被激发去了解更多内容。如果学习变成了一项苦差，你看不到其中的价值，你会尽可能地拖延。<font color=#d13f28><strong>整合理智和情感学习的一个关键点在于，识别出每门学科中的思维模式，这些思维模式帮助你理性的思考。</strong></font></p>\n<h5 id=\"第四章-思维的组成\"><a href=\"#第四章-思维的组成\" class=\"headerlink\" title=\"第四章 思维的组成\"></a>第四章 思维的组成</h5><ol>\n<li>如何将思维分解为不同的成分？</li>\n<li>什么是思维推理？</li>\n<li>思维的本质是什么？</li>\n</ol>\n<p>1: <font color=#d13f28><strong>目的·观点·假设·意义和结果·推理和判断·理论·解决问题。</strong></font><br>2: 推理具有<font color=#d13f28><strong>目的性</strong></font>，这一目的性是指人们对事物的思考都是与其目标、欲望、需求及价值观相一致的。推理过程常常从一定的<font color=#d13f28><strong>立场</strong></font>出发，这是指我们的思维具有指向性。推理是根据特定的问题或<font color=#d13f28><strong>论点</strong></font>。<br>3: 思维的本质就是如何使用所有能获取的信息，来推理出<font color=#d13f28><strong>事物的因果关系</strong></font>。</p>\n<h5 id=\"第五章-思维标准\"><a href=\"#第五章-思维标准\" class=\"headerlink\" title=\"第五章 思维标准\"></a>第五章 思维标准</h5><ol>\n<li>什么是最简化的思维标准？</li>\n<li>如何理解思维标准？</li>\n<li>我们如何使用这些标准评估思维中的一个或多个元素？</li>\n</ol>\n<p>1: <font color=#d13f28><strong>清晰性 准确性 精确性 相关性 深度 广度 逻辑性 重要性 公正性</strong></font><br>2: 批判性思考者需要思考如何提问，而引发自我思考。可以通过提问来提升思维标准。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">标准思维</th>\n<th align=\"left\">问题</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">清晰性</td>\n<td align=\"left\">1.可以详细描述那个观点吗？<br>2.可以用另外一种方式来表达那个观点吗？<br>3.可以给我举个例子嘛？</td>\n<td align=\"left\">是最基本的标准</td>\n</tr>\n<tr>\n<td align=\"center\">准确性</td>\n<td align=\"left\">1.是真的吗？<br>2.如何检查不是准确的？<br>3.如何确定他的准确?</td>\n<td align=\"left\">要表达出与实际事物相一致的信息</td>\n</tr>\n<tr>\n<td align=\"center\">精准性</td>\n<td align=\"left\">可以给我更多的细节吗？</td>\n<td align=\"left\">细节能够优化我们的思考</td>\n</tr>\n<tr>\n<td align=\"center\">相关性</td>\n<td align=\"left\">它是怎样对问题产生影响的？</td>\n<td align=\"left\">相关性思维让我们的思路保持在正常轨道上</td>\n</tr>\n<tr>\n<td align=\"center\">深度</td>\n<td align=\"left\">1.如何处理这个问题中最重要的因素？<br>2.你的答案是怎样解决这个复杂问题的？</td>\n<td align=\"left\">更需要积极思考其中的复杂性</td>\n</tr>\n<tr>\n<td align=\"center\">广度</td>\n<td align=\"left\">1.需要考虑另一个观点吗？<br>2.是否存在另一种方式看待这个问题?</td>\n<td align=\"left\">更需要从不同的角度来思考问题</td>\n</tr>\n<tr>\n<td align=\"center\">逻辑性</td>\n<td align=\"left\">1.这些组合起来后具有逻辑吗?<br>2.是根据论据推断出来的吗？</td>\n<td align=\"left\">相互支持并能结合的有意义，这样的思维才有逻辑</td>\n</tr>\n<tr>\n<td align=\"center\">重要性</td>\n<td align=\"left\">1.需要明确问题中最重要的信息是什么？<br>2.这些问题中的哪一个是最重要的？</td>\n<td align=\"left\">需要考虑最重要的观点或概念</td>\n</tr>\n<tr>\n<td align=\"center\">公正性</td>\n<td align=\"left\">1.这些假设合理吗？<br>2.我考虑到其他可能的证据了吗？</td>\n<td align=\"left\">公平的思考</td>\n</tr>\n</tbody></table>\n<p>3: 每一个元素都含有可能出现的错误找到，使用一些检查点，可以提升思维标准。<br>    (1) 所有的思考都有一个目标。<br>    (2) 所有思考都是澄清一些事实，去发现一些问题，解决一些问题。<br>    (3) 所有的思考都要来自一些观点。<br>    (4) 所有的思考都是根据数据、信息和论据做出来的。<br>    (5) 所有的思考都通过概念和理论来表达并塑造。<br>    (6) 所有的思考都觊觎假设。<br>    (7) 所有的思考都会产生一些意义和结果。<br>    (8) 所有的思考均包含推理，以及能够得出结论、赋予数据意义的解释。</p>\n<h5 id=\"第六章-培养良好思维的提问\"><a href=\"#第六章-培养良好思维的提问\" class=\"headerlink\" title=\"第六章 培养良好思维的提问\"></a>第六章 培养良好思维的提问</h5><ol>\n<li>提问在发展思维中有何作用?</li>\n<li>三种问题类型是什么？如何以此对提问进行“快速启动”？</li>\n<li>苏格拉底式提问是什么？ </li>\n</ol>\n<p>1: 答案不能推动思维的发展，真正能推动思维发展的是问题。提出问题有助于我们清除任务要求，清楚与表达相关的问题，并是我们了解需要处理的事物。<font color=#d13f28><strong>问题的质量决定着你思考的质量。</strong></font><br>2:  (1) 基于事实的问题。正确答案只有一个。(2) 基于偏好的问题。纯粹主观意见。(3) 基于判断的问题。并不止一个可行的答案。<br>可以在学习时区分问题的三种类型。寻找拥有确定的或正确答案的问题。此外，最为重要的的是，要找出那些可以从<strong>不同角度看待</strong>，接近于可争论的问题。<br>3: “苏格拉底”为一般提问方式增加了系统性、深度和强烈的提问兴趣。我们可以从下列方式中提升提问方式。(1) 关注问题类型。(2) 关注思维标准。(3) 关注思维元素。(4) 关注问题优先次序。(5) 关注思维领域。</p>\n<h5 id=\"第七章-掌握思维，掌握内容\"><a href=\"#第七章-掌握思维，掌握内容\" class=\"headerlink\" title=\"第七章 掌握思维，掌握内容\"></a>第七章 掌握思维，掌握内容</h5><ol>\n<li>如何超越表面化记忆进行深度学习？</li>\n<li>内容和思维的关系是什么？</li>\n<li>如何运用思维模式来思考？</li>\n</ol>\n<p>1: 死记硬背是不可行的，洞悉内容和思维的关键在于，要清楚内容代表了特别的思维方式，需要理解所学内容和思维的关系。<strong>所有的内容都是由概念组成的，所有内容逻辑上市相互依存的</strong>。<br>2: 通过思维理解内容，通过内容进行思考。<br>3: (1)所有的思维都有<font color=#d13f28><strong>目的</strong></font>。(2)所有的思维都<font color=#d13f28><strong>至少提出一个问题</strong></font>。(3)所有的思维都<font color=#d13f28><strong>需要信息支持</strong></font>。(4)所有的思维都包括<font color=#d13f28><strong>推论</strong></font>。(5)所有的思维都包括<font color=#d13f28><strong>假设</strong></font>。(6)所有的思维都包括<font color=#d13f28><strong>预测</strong></font>。(7)所有的思维都包括<font color=#d13f28><strong>观点</strong></font>。(1)所有的思维都<font color=#d13f28><strong>概念</strong></font>。</p>\n<h5 id=\"第八章-了解优秀思维者是如何学习的\"><a href=\"#第八章-了解优秀思维者是如何学习的\" class=\"headerlink\" title=\"第八章 了解优秀思维者是如何学习的\"></a>第八章 了解优秀思维者是如何学习的</h5><ol>\n<li>我该如何选择并练习哪些策略，可以使自己的学习更有成效？</li>\n<li>课程和学科必要的思维模式是什么？</li>\n</ol>\n<p>1:优化学习的策略很多，但并不是每一种策略都需要掌握，找出适合自己的才是最好的。(1) 成为一个勤学好问者，通过问题知道自己掌握了哪些，没有掌握哪些。(2)  尽可能的将学到的内容与现实问题连接起来，注重实际运用。 (3) 经常问自己能否清晰的解释知识，且能让他人准确的听明白。<br>2:可以从下面八个结构性问题来界定任何思维模式：<br>(1) 该课程或学科的目标是什么？<br>(2) 核心问题是什么？<br>(3) 基础概念是什么？<br>(4) 深入学习该学科需要运用哪些信息？<br>(5) 要做出推理，需要哪些观点和参考文献？<br>(6) 定义这门课程或学科的假设是什么？<br>(7) 我需要哪种结论来学习如何推理？<br>(8) 这门学科中科学推理的意义是什么？</p>\n<h5 id=\"第九章-重新评估自己思考和学习的水平\"><a href=\"#第九章-重新评估自己思考和学习的水平\" class=\"headerlink\" title=\"第九章 重新评估自己思考和学习的水平\"></a>第九章 重新评估自己思考和学习的水平</h5><p>1.哪些方面应该是模范学生的评判标准？</p>\n<p>1: (1).提出重要的问题和论点。<br>(2).精准清晰地分析关键问题。<br>(3).识别可疑的前提假设。<br>(4).有效阐述关键观点。<br>(5).识别出相关的竞争性观点。<br>(6).审慎地呈现重要的意义和结果。<br>(7).根据学科中清晰陈述的前提假设进行认真推理。</p>\n<h5 id=\"第十章-决策和问题解决\"><a href=\"#第十章-决策和问题解决\" class=\"headerlink\" title=\"第十章 决策和问题解决\"></a>第十章 决策和问题解决</h5><ol>\n<li>如何克服思维狭隘？</li>\n<li>如何提高自己的掌握决策和问题解决的技巧？</li>\n</ol>\n<p>1: 思维过于狭隘很难改正，因为没人愿意相信自己的思维过于狭隘。实际上，思维越窄的人越觉得自己视野开阔。克服思维狭隘，下面两个规则是有用的：规则一：总会有办法的。规则二：总会有另外的解决办法。<br>2: (1) 对我们生活中决策的本质和作为做出批判性思考。(2) 判断我们生活中的大问题，进而专注于这些问题的解决。 (3) 系统地采取某些策略来提高我们有效做出理性决策和问题解决的能力。 </p>\n<h5 id=\"第十一章-应对自身的非理性\"><a href=\"#第十一章-应对自身的非理性\" class=\"headerlink\" title=\"第十一章 应对自身的非理性\"></a>第十一章 应对自身的非理性</h5><ol>\n<li>什么是自我中心思维？</li>\n</ol>\n<p>1: 自我中心思维源于我们人类天生的狭隘倾向，本能地以符合我们利益的方式解释情景和他人的行为。<br>“因为我相信它，所以它是真的。”<br>“因为我想相信它，所以它是真的。”<br>“相信它符合我们的利益，所以它是真的。”<br>“因为我一直相信它，所以它是真的。”</p>\n<h5 id=\"第十二章-如何甄别新闻中的媒体偏见和宣教\"><a href=\"#第十二章-如何甄别新闻中的媒体偏见和宣教\" class=\"headerlink\" title=\"第十二章 如何甄别新闻中的媒体偏见和宣教\"></a>第十二章 如何甄别新闻中的媒体偏见和宣教</h5><ol>\n<li>对于新闻如何做到客观性？</li>\n</ol>\n<p>1: (1) 确定新闻报道和历史记载中作者的观点。<br>(2) 确定新闻报道和历史记载中的目标受众。<br>(3) 确定文章中否定和忽视的观点。<br>(4) 区别新闻报道中的原始事实和报道中加进去的解释和编造。</p>\n<h5 id=\"第十三章-谬误：心理诡计和操纵诡计\"><a href=\"#第十三章-谬误：心理诡计和操纵诡计\" class=\"headerlink\" title=\"第十三章 谬误：心理诡计和操纵诡计\"></a>第十三章 谬误：心理诡计和操纵诡计</h5><blockquote>\n<p>了解人心，就是了解自我欺骗。  </p>\n</blockquote>\n<ol>\n<li>44种赢取辩论的诡计是什么？</li>\n</ol>\n<style> table th:first-of-type { width: 220px; } </style>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">观点</th>\n<th align=\"left\">范例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">以其人之道还治其人之身，<br>将对手对你的指责奉还给他。</td>\n<td align=\"left\"><em>你说我不爱你，我认为是你不爱我！</em></td>\n</tr>\n<tr>\n<td align=\"left\">指责他犯了滑坡谬误</td>\n<td align=\"left\"><em>A不是很糟糕，但是A导致了B，B导致了C，C兼职糟糕透顶</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉诸权威</td>\n<td align=\"left\"><em>他们还会找一些科学家和“学识渊博”的人来支持自己的观点。</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉讼经验</td>\n<td align=\"left\"><em>指责对手的经验不具代表性，是偏颇、歪曲或主观的。</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉讼恐惧</td>\n<td align=\"left\"><em>记住，这些人威胁到我们的自由、我们的生活方式、我们的家园和我们的财产。</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉诸怜悯</td>\n<td align=\"left\"><em>在你批评总统之前，想想他在做着世界上最难做的工作吧。</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉诸大众偏好</td>\n<td align=\"left\"><em>回到家乡，和我能够真正信任的人在一起真好。</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉诸传统和信仰</td>\n<td align=\"left\"><em>操纵者会表现出坚定不移的相信。</em></td>\n</tr>\n<tr>\n<td align=\"left\">采取一个圣洁的姿态</td>\n<td align=\"left\"><em>我们国家有最崇高的理想。当然我们会犯错，但是我们的动机是好的。</em></td>\n</tr>\n<tr>\n<td align=\"left\">攻击他人</td>\n<td align=\"left\"><em>谩骂是一种很好的方式。</em></td>\n</tr>\n<tr>\n<td align=\"left\">窃取观点</td>\n<td align=\"left\"><em>我们是该站起来去捍卫自由和民主，还是任由恐怖主义和暴政所控？</em></td>\n</tr>\n<tr>\n<td align=\"left\">要求完美</td>\n<td align=\"left\"><em>是，我支持民主，但是必须是真正的民主，这意味着在我接受它之前，这儿、那儿都要改变</em></td>\n</tr>\n<tr>\n<td align=\"left\">制造出一个虚假两难</td>\n<td align=\"left\"><em>我们要么在发恐怖主义战争中失败，要么放弃我们一贯享有的自由和权力。</em></td>\n</tr>\n<tr>\n<td align=\"left\">用类比和隐喻来支持你的观点</td>\n<td align=\"left\"><em>你难道不认为到了我们打击那些对待犯罪软弱的法官的时候了吗？</em></td>\n</tr>\n<tr>\n<td align=\"left\">质疑对手的结论</td>\n<td align=\"left\"><em>你说的没有逻辑。你没能证实Y，只证实了X。</em></td>\n</tr>\n<tr>\n<td align=\"left\">制造担忧：无风不起浪</td>\n<td align=\"left\"><em>凯文已经承认吸食大麻，这足以让我们看清他了。</em></td>\n</tr>\n<tr>\n<td align=\"left\">稻草人谬误</td>\n<td align=\"left\"><em>那我想你是要释放所有的犯人，进而将我们置于更加危险的境地。</em></td>\n</tr>\n<tr>\n<td align=\"left\">否认不一致或为不一致辩护</td>\n<td align=\"left\"><em>要么否定矛盾的存在，要么承认矛盾并称这是一个合理的转变</em></td>\n</tr>\n<tr>\n<td align=\"left\">妖魔化对手的观点，神化自己的观点</td>\n<td align=\"left\"><em>用消极的词汇来描述对手即可</em></td>\n</tr>\n<tr>\n<td align=\"left\">巧妙的回避问题</td>\n<td align=\"left\"><em>问：军队多久才能从X国撤兵？答：只要不需要，我们一天都不会多待。</em></td>\n</tr>\n<tr>\n<td align=\"left\">迎合你的受众</td>\n<td align=\"left\"><em>一个真正聪明的人是像你这样不会受骗的人。</em></td>\n</tr>\n<tr>\n<td align=\"left\">隐藏自己所述</td>\n<td align=\"left\"><em>当面对压力时，他们会掩盖和回避。</em></td>\n</tr>\n<tr>\n<td align=\"left\">忽视证据</td>\n<td align=\"left\"><em>为了不改变自己的立场，操纵者常常会护士证据</em></td>\n</tr>\n<tr>\n<td align=\"left\">忽视主要观点</td>\n<td align=\"left\"><em>操纵者知道如果他们在某一议题上不能获胜，他们会想办法将受众的注意转移到另一个点上</em></td>\n</tr>\n<tr>\n<td align=\"left\">攻击证据</td>\n<td align=\"left\"><em>没有证据能够是美国政府相信他们做错了。</em></td>\n</tr>\n<tr>\n<td align=\"left\">大声坚持次要观点</td>\n<td align=\"left\"><em>我们将将攻击这座城市和一个必胜客快餐店。</em></td>\n</tr>\n<tr>\n<td align=\"left\">采用“艰难、残忍世界”的论调</td>\n<td align=\"left\"><em>我们不希望看到战争，我们是被迫加入战争的。</em></td>\n</tr>\n<tr>\n<td align=\"left\">做出笼统、粉饰的概括</td>\n<td align=\"left\"><em>我们忠诚于上帝、国家、热爱祖国、家庭和自由市场经济。</em></td>\n</tr>\n<tr>\n<td align=\"left\">尽可能找到你对手的不一致处</td>\n<td align=\"left\"><em>发现对手的不一致，并能快速的指责对手的虚伪。</em></td>\n</tr>\n<tr>\n<td align=\"left\">是你的对手看起来荒谬可笑</td>\n<td align=\"left\"><em>操纵者使用质疑策略，从而让他们的嘲笑看起来不像是酸葡萄。</em></td>\n</tr>\n<tr>\n<td align=\"left\">简化问题</td>\n<td align=\"left\"><em>把你的同情心留给受害者吧，而不是那些罪犯。</em></td>\n</tr>\n<tr>\n<td align=\"left\">一直反对</td>\n<td align=\"left\"><em>我会一直提出反对，没有什么能让我相信对手的观点。</em></td>\n</tr>\n<tr>\n<td align=\"left\">按照自己的方式重写历史</td>\n<td align=\"left\"><em>你总是看到我们哪里做错了，怎么不去看看我们做对的事情呢？</em></td>\n</tr>\n<tr>\n<td align=\"left\">找到自己的既得利益</td>\n<td align=\"left\"><em>你也会这样。</em></td>\n</tr>\n<tr>\n<td align=\"left\">改变论据</td>\n<td align=\"left\"><em>如果这都不算接受过教育，我不知道什么才叫受过教育。</em></td>\n</tr>\n<tr>\n<td align=\"left\">转移举证责任</td>\n<td align=\"left\"><em>你难道没有反对自由贸易吗？</em></td>\n</tr>\n<tr>\n<td align=\"left\">歪曲、歪曲、歪曲</td>\n<td align=\"left\"><em>大多数人已经放弃获取纯粹事实的希望，将自己与歪曲的报道为伍。</em></td>\n</tr>\n<tr>\n<td align=\"left\">含糊的概括</td>\n<td align=\"left\"><em>是我们强硬起来的时候了，我们要坚定不移的打击犯罪。</em></td>\n</tr>\n<tr>\n<td align=\"left\">故弄玄虚，双言巧语</td>\n<td align=\"left\"><em>我们做就是正确的；他们做就是错误的。</em></td>\n</tr>\n<tr>\n<td align=\"left\">撤下弥天大谎</td>\n<td align=\"left\"><em>操纵者不怕，他们知道如果他们足够坚持，人们就会相信。</em></td>\n</tr>\n<tr>\n<td align=\"left\">将抽象词描绘的像真的</td>\n<td align=\"left\"><em>我们是自由的代表。</em></td>\n</tr>\n<tr>\n<td align=\"left\">转移受众注意力</td>\n<td align=\"left\"><em>真正需要我们关心的是，所有政府都在监管他们的工业。</em></td>\n</tr>\n<tr>\n<td align=\"left\">诉诸统计</td>\n<td align=\"left\"><em>你知道吗？有78%的学生读了这本指南后，提高了1.33个水平。</em></td>\n</tr>\n<tr>\n<td align=\"left\">双重标准</td>\n<td align=\"left\"><em>我们谴责入侵（除非我们是入侵者）</em></td>\n</tr>\n</tbody></table>\n<h5 id=\"第十四章-努力变成一名有道德的推理者\"><a href=\"#第十四章-努力变成一名有道德的推理者\" class=\"headerlink\" title=\"第十四章 努力变成一名有道德的推理者\"></a>第十四章 努力变成一名有道德的推理者</h5><ol>\n<li>为什么人们对道德感到困惑？</li>\n</ol>\n<p>1: 这源于我们与生俱来的同理心 ———— 想象自己处于他人的位置，对他人的遭遇感同身受。</p>\n<h5 id=\"第十五章-策略性思维：第一部分\"><a href=\"#第十五章-策略性思维：第一部分\" class=\"headerlink\" title=\"第十五章 策略性思维：第一部分\"></a>第十五章 策略性思维：第一部分</h5><ol>\n<li>思维、感受和需求是相互依存的。</li>\n<li>这是有逻辑的，并且你能把它弄清楚。</li>\n<li>进行定期评价，提高思维的质量。</li>\n</ol>\n<p>1: 我们不能够立即改变我们的需求和感受，我们只与思维有直接联系。即使我对情景的理解是合理的，我的愤怒是合理的，但是考虑到情景的各个方面，我的行为不一定是合理的。<font color=#d13f28><strong>愤怒是合理的，但不能因此就做出非理性的行为。</strong></font><br>2: 情景有逻辑，个人行为也有逻辑。有外显和和内隐的逻辑，也有公认的和隐藏的逻辑。<font color=#d13f28><strong>像质疑自己身边人的思维逻辑一样，质疑你自己的思维逻辑。</strong></font><br>3: 一定要从思维的标准中来评估自己的思维，熟练从不同的角度来对自己的思维进行评估。</p>\n<h5 id=\"第十六章-策略性思维：第二部分\"><a href=\"#第十六章-策略性思维：第二部分\" class=\"headerlink\" title=\"第十六章 策略性思维：第二部分\"></a>第十六章 策略性思维：第二部分</h5><ol>\n<li>自我中心是默认的心理机制。</li>\n<li>审慎对待我们周围人的自我中心 。</li>\n<li>人们倾向于做出超过个人经验的总结。</li>\n<li>误把自我中心思维作为理性思维。 </li>\n<li>自我中心思维是自动发生的</li>\n<li>我们经常通过控制或顺从来谋取权力</li>\n<li>人类的社会中心倾向是天生的</li>\n<li>理性的发展需要练习</li>\n</ol>\n<p>1: 人类的心理具有二元性的：一方面，人类具有非理性的本能倾向；另一方面，又具有追求理性的能力。我们必须有能力去监控自我中心的非理性倾向，并且用理性来制衡非理性倾向。<br>2: 人越是自我中心，就越拒绝承认自己的自我中心。从他人的观点进行思考，我们就可能预测我们周围人的自我中心反映。这样，我们就可以通过调整自我反应来回避掉他人自我中心的影响。<br>3: 在头脑中形成一幅深刻全面的“大图”思维框架，通过在日常生活中尽可能全面地考虑观点，我们能够将自己的直接自我中心倾向减到最小。<br>4: 没有真正思考反对观点，对反对者形成刻板印象、护士相关证据、情绪化地反应，以及为非理性的行为找借口。<br>5: 我们能够拒绝收到原始需求和思维模式的控制，能够给主动地用理性思维来取代自动的自我中心思维。<br>6: 我们对人类生活中控制和顺从的模式了解得越深，我们就能够在自己的生活中觉察到他们。<br>7: 我们都在不同程度上不加鉴别地遵守我们群体的规则和期望。<br>8: 我们要培养自己经常评价自身思维清晰度、准确性、逻辑性、重要性、广度、深度以及合理性的习惯。</p>\n<h5 id=\"第十七章-成为一名高级的思考者：总结\"><a href=\"#第十七章-成为一名高级的思考者：总结\" class=\"headerlink\" title=\"第十七章 成为一名高级的思考者：总结\"></a>第十七章 成为一名高级的思考者：总结</h5><p>因为人生来倾向自欺，所以必须主动调控自己的思维。慢慢蹭蹭的看了半年，总算是把这本书草草的看过一遍，其中的道理和方法还是不怎么理解，可能真的需要在看很多遍，去实践很多遍才能稍微理解吧。不过我们中的大多数都不会成为高级批判性的思考者，就像高校棒球运动员中不会有很多人发展成为专业棒球运动员。但是我们还是需要不断地学习，不断地开发自己的头脑，以及不断地反思批评。这是第一次读完留下的笔记，以后如果有什么思考也慢慢记录吧。</p>\n<p align=\"right\">--------2017年12月14日10:56:44</p>\n"},{"layout":"日记","title":"知乎回答“什么能力很重要，但大多数人却没有？”","date":"2019-03-23T15:03:34.000Z","_content":"\n什么能力很重要，但大多数人却没有？\n\n1. 用肉体操纵精神的能力；\n2. 训练感官的能力；\n3. 让自己突然变开心的能力；\n<!-- more -->\n\n##### 用肉体操纵精神的能力\n\"用精神操控肉体\"，注定是要失败的。\n必须要学会，**用肉体操控精神**。\n比如读书，不管你多不愿意，有什么借口，你都可以选择让你的**身体**先坐下来，拿出书，翻开，然后开始读，读了一两分钟你会惊奇地发现，你竟然自己慢慢就读下去了。\n\n其实**人的身体和精神之间，往往存在很深入的“互相牵引”，而我们自己却很难意识到。**\n\n为什么要学会\"用肉体控制/推动精神\"，而不是相反？因为**你的精神会在你还没行动前，就给你设置了一大堆障碍、想象出一百万种失败的场景把你吓尿。**\n\n##### 训练感官的能力\n人的大脑总是倾向于以一个“**整体感觉**”来感觉、评价事物\n长此以往，我们**自然很难抛开这些“整体感受”，而深入到事物的细节、构造里面去。**\n**训练感官、分解感受。**\n\n##### 让自己突然变得开心的能力\n你需要做的是，**回想一下能让你开心的、非常具体的事儿**，或者，在你下次开心的时候，把你看到的东西，**保留下来、记录下来，下次找一类的就可以**。\n比较通用的，还是养点东西，花花草草、猫猫狗狗，都成；或者培养一个具体的爱好，烦心了就沉到这个爱好里面一会儿。\n\n##### 总之\n1. **用肉体控制精神的能力**——让肉体推动精神，精神自然顺势而为\n2. **训练感官的能力**——人的感觉越细微、有分别，人的感受能力就越强，思考能力自然也会变得更强，而不是浑噩地，一口吞下所有到嘴前的信息\n3. **让自己突然变开心的能力**——你可以突然变“丧”，但也可以突然开心起来，只要开心了，事情就好办！\n\n<br>\n>[什么能力很重要，但大多数人却没有？](https://www.zhihu.com/question/305507128)","source":"_posts/什么能力很重要，但大多数人却没有.md","raw":"---\nlayout: 日记\ntitle: 知乎回答“什么能力很重要，但大多数人却没有？”\ndate: 2019-03-23 23:03:34\ntags:\n- 日记\n- 随笔\ncategories:\n- 日记\n---\n\n什么能力很重要，但大多数人却没有？\n\n1. 用肉体操纵精神的能力；\n2. 训练感官的能力；\n3. 让自己突然变开心的能力；\n<!-- more -->\n\n##### 用肉体操纵精神的能力\n\"用精神操控肉体\"，注定是要失败的。\n必须要学会，**用肉体操控精神**。\n比如读书，不管你多不愿意，有什么借口，你都可以选择让你的**身体**先坐下来，拿出书，翻开，然后开始读，读了一两分钟你会惊奇地发现，你竟然自己慢慢就读下去了。\n\n其实**人的身体和精神之间，往往存在很深入的“互相牵引”，而我们自己却很难意识到。**\n\n为什么要学会\"用肉体控制/推动精神\"，而不是相反？因为**你的精神会在你还没行动前，就给你设置了一大堆障碍、想象出一百万种失败的场景把你吓尿。**\n\n##### 训练感官的能力\n人的大脑总是倾向于以一个“**整体感觉**”来感觉、评价事物\n长此以往，我们**自然很难抛开这些“整体感受”，而深入到事物的细节、构造里面去。**\n**训练感官、分解感受。**\n\n##### 让自己突然变得开心的能力\n你需要做的是，**回想一下能让你开心的、非常具体的事儿**，或者，在你下次开心的时候，把你看到的东西，**保留下来、记录下来，下次找一类的就可以**。\n比较通用的，还是养点东西，花花草草、猫猫狗狗，都成；或者培养一个具体的爱好，烦心了就沉到这个爱好里面一会儿。\n\n##### 总之\n1. **用肉体控制精神的能力**——让肉体推动精神，精神自然顺势而为\n2. **训练感官的能力**——人的感觉越细微、有分别，人的感受能力就越强，思考能力自然也会变得更强，而不是浑噩地，一口吞下所有到嘴前的信息\n3. **让自己突然变开心的能力**——你可以突然变“丧”，但也可以突然开心起来，只要开心了，事情就好办！\n\n<br>\n>[什么能力很重要，但大多数人却没有？](https://www.zhihu.com/question/305507128)","slug":"什么能力很重要，但大多数人却没有","published":1,"updated":"2021-09-06T15:49:48.184Z","_id":"ckt8qfyao001i7sn68t75gfsz","comments":1,"photos":[],"link":"","content":"<p>什么能力很重要，但大多数人却没有？</p>\n<ol>\n<li>用肉体操纵精神的能力；</li>\n<li>训练感官的能力；</li>\n<li>让自己突然变开心的能力；<span id=\"more\"></span></li>\n</ol>\n<h5 id=\"用肉体操纵精神的能力\"><a href=\"#用肉体操纵精神的能力\" class=\"headerlink\" title=\"用肉体操纵精神的能力\"></a>用肉体操纵精神的能力</h5><p>“用精神操控肉体”，注定是要失败的。<br>必须要学会，<strong>用肉体操控精神</strong>。<br>比如读书，不管你多不愿意，有什么借口，你都可以选择让你的<strong>身体</strong>先坐下来，拿出书，翻开，然后开始读，读了一两分钟你会惊奇地发现，你竟然自己慢慢就读下去了。</p>\n<p>其实<strong>人的身体和精神之间，往往存在很深入的“互相牵引”，而我们自己却很难意识到。</strong></p>\n<p>为什么要学会”用肉体控制/推动精神”，而不是相反？因为<strong>你的精神会在你还没行动前，就给你设置了一大堆障碍、想象出一百万种失败的场景把你吓尿。</strong></p>\n<h5 id=\"训练感官的能力\"><a href=\"#训练感官的能力\" class=\"headerlink\" title=\"训练感官的能力\"></a>训练感官的能力</h5><p>人的大脑总是倾向于以一个“<strong>整体感觉</strong>”来感觉、评价事物<br>长此以往，我们<strong>自然很难抛开这些“整体感受”，而深入到事物的细节、构造里面去。</strong><br><strong>训练感官、分解感受。</strong></p>\n<h5 id=\"让自己突然变得开心的能力\"><a href=\"#让自己突然变得开心的能力\" class=\"headerlink\" title=\"让自己突然变得开心的能力\"></a>让自己突然变得开心的能力</h5><p>你需要做的是，<strong>回想一下能让你开心的、非常具体的事儿</strong>，或者，在你下次开心的时候，把你看到的东西，<strong>保留下来、记录下来，下次找一类的就可以</strong>。<br>比较通用的，还是养点东西，花花草草、猫猫狗狗，都成；或者培养一个具体的爱好，烦心了就沉到这个爱好里面一会儿。</p>\n<h5 id=\"总之\"><a href=\"#总之\" class=\"headerlink\" title=\"总之\"></a>总之</h5><ol>\n<li><strong>用肉体控制精神的能力</strong>——让肉体推动精神，精神自然顺势而为</li>\n<li><strong>训练感官的能力</strong>——人的感觉越细微、有分别，人的感受能力就越强，思考能力自然也会变得更强，而不是浑噩地，一口吞下所有到嘴前的信息</li>\n<li><strong>让自己突然变开心的能力</strong>——你可以突然变“丧”，但也可以突然开心起来，只要开心了，事情就好办！</li>\n</ol>\n<br>\n>[什么能力很重要，但大多数人却没有？](https://www.zhihu.com/question/305507128)","site":{"data":{}},"excerpt":"<p>什么能力很重要，但大多数人却没有？</p>\n<ol>\n<li>用肉体操纵精神的能力；</li>\n<li>训练感官的能力；</li>\n<li>让自己突然变开心的能力；","more":"</li>\n</ol>\n<h5 id=\"用肉体操纵精神的能力\"><a href=\"#用肉体操纵精神的能力\" class=\"headerlink\" title=\"用肉体操纵精神的能力\"></a>用肉体操纵精神的能力</h5><p>“用精神操控肉体”，注定是要失败的。<br>必须要学会，<strong>用肉体操控精神</strong>。<br>比如读书，不管你多不愿意，有什么借口，你都可以选择让你的<strong>身体</strong>先坐下来，拿出书，翻开，然后开始读，读了一两分钟你会惊奇地发现，你竟然自己慢慢就读下去了。</p>\n<p>其实<strong>人的身体和精神之间，往往存在很深入的“互相牵引”，而我们自己却很难意识到。</strong></p>\n<p>为什么要学会”用肉体控制/推动精神”，而不是相反？因为<strong>你的精神会在你还没行动前，就给你设置了一大堆障碍、想象出一百万种失败的场景把你吓尿。</strong></p>\n<h5 id=\"训练感官的能力\"><a href=\"#训练感官的能力\" class=\"headerlink\" title=\"训练感官的能力\"></a>训练感官的能力</h5><p>人的大脑总是倾向于以一个“<strong>整体感觉</strong>”来感觉、评价事物<br>长此以往，我们<strong>自然很难抛开这些“整体感受”，而深入到事物的细节、构造里面去。</strong><br><strong>训练感官、分解感受。</strong></p>\n<h5 id=\"让自己突然变得开心的能力\"><a href=\"#让自己突然变得开心的能力\" class=\"headerlink\" title=\"让自己突然变得开心的能力\"></a>让自己突然变得开心的能力</h5><p>你需要做的是，<strong>回想一下能让你开心的、非常具体的事儿</strong>，或者，在你下次开心的时候，把你看到的东西，<strong>保留下来、记录下来，下次找一类的就可以</strong>。<br>比较通用的，还是养点东西，花花草草、猫猫狗狗，都成；或者培养一个具体的爱好，烦心了就沉到这个爱好里面一会儿。</p>\n<h5 id=\"总之\"><a href=\"#总之\" class=\"headerlink\" title=\"总之\"></a>总之</h5><ol>\n<li><strong>用肉体控制精神的能力</strong>——让肉体推动精神，精神自然顺势而为</li>\n<li><strong>训练感官的能力</strong>——人的感觉越细微、有分别，人的感受能力就越强，思考能力自然也会变得更强，而不是浑噩地，一口吞下所有到嘴前的信息</li>\n<li><strong>让自己突然变开心的能力</strong>——你可以突然变“丧”，但也可以突然开心起来，只要开心了，事情就好办！</li>\n</ol>\n<br>\n>[什么能力很重要，但大多数人却没有？](https://www.zhihu.com/question/305507128)"},{"layout":"Swift","title":"使用 UIPresentationController 实现底部弹出页面","date":"2018-03-08T06:07:13.000Z","_content":"底部弹出框在项目中很常见，之前对此的理解很肤浅，不太明白如何更好的实现自定义的页面。刚好在 [GitHub](https://github.com/IkeBanPC/PresentBottom) 看到有一中很简单的实现方式，是利用 UIPresentationController 和继承的方式实现。学习一下，自己再通过协议的方式实现下，加深自己的理解。\n<!--- more --->\n#### 实现效果\n![UIPresentationController 底部弹出](https://raw.githubusercontent.com/IkeBanPC/PresentBottom/master/Pics/Select.gif)\n#### 实现 UIPresentationController\n关于 `UIPresentationController` 的描述，官网的说法是 \n> An object that manages the transition animations and the presentation of view controllers onscreen.\n\n简单点说就是管理两个 Controller 之间的转场动画。\n所以可以通过重写这个类来自定义想要的转场动画。\n首先创建一个类来继承 `UIPresentationController`，并重写一些必要的方法\n\n```\nclass HUPresentController: UIPresentationController {\n\t//获取转场 Controller 高度\n    var controllerHeight: CGFloat = 0\n    //决定了弹出框的frame\n    override var frameOfPresentedViewInContainerView: CGRect {\n        return CGRect(x: 0, y: UIScreen.main.bounds.height - controllerHeight , width: UIScreen.main.bounds.width, height: controllerHeight)\n    }\n    //重写此方法可以在弹框即将显示时执行所需要的操作\n    override func presentationTransitionWillBegin() {\n        blackView.alpha = 0\n        containerView?.addSubview(blackView)\n        UIView.animate(withDuration: 0.3) { self.blackView.alpha = 1 }\n    }\n    //重写此方法可以在弹框显示完毕时执行所需要的操作\n    override func presentationTransitionDidEnd(_ completed: Bool) {\n    }\n    //重写此方法可以在弹框即将消失时执行所需要的操作\n    override func dismissalTransitionWillBegin() {\n        UIView.animate(withDuration: 0.5) { self.blackView.alpha = 0 }\n    }\n    //重写此方法可以在弹框消失之后执行所需要的操作\n    override func dismissalTransitionDidEnd(_ completed: Bool) {\n        if completed { blackView.removeFromSuperview() }\n    }\n    //遮挡阴影\n    lazy var blackView: UIView = {\n        let view = UIView()\n        if let frame = self.containerView?.bounds {\n            view.frame = frame\n        }\n        view.backgroundColor = UIColor.black.withAlphaComponent(0.5)\n        return view\n    }()\n\n    override init(presentedViewController: UIViewController, presenting presentingViewController: UIViewController?) {\n        if let vc = presentedViewController as? PresentProtocol {\n            controllerHeight = vc.controllerHeight\n        }\n        super.init(presentedViewController:presentedViewController,presenting: presentingViewController)\n    }\n}\n```\n#### 协议 && UIViewController 扩展\n原来的项目是通过继承的方式来实现的，但是在 Swift 中并不提倡使用继承，所以我们改用协议的方式来实现。\n```\nprotocol PresentProtocol {\n    var controllerHeight: CGFloat { get }\n}\nextension PresentProtocol where Self: UIViewController {}\n//对 UIViewController 进行拓展，并让其遵守转场协议\nextension UIViewController: UIViewControllerTransitioningDelegate  {\n    func presentBottom(_ vc: UIViewController) {\n        vc.modalPresentationStyle = .custom\n        vc.transitioningDelegate = self\n        self.present(vc, animated: true, completion: nil)\n    }\n    public func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -> UIPresentationController? {\n        let present = HUPresentController(presentedViewController: presented, presenting: presenting)\n        return present\n    }\n}\n```\n#### 实现自定义 Controller \n准备工作到了最后一步就是实现自定义的 Controller 了，确保 Controller 遵循刚才定义的协议 `PresentProtocol`，并实现协议属性。\n\n```\nclass HUTestVC: UIViewController, PresentProtocol {\n    var controllerHeight: CGFloat { return 600 }\n    /// sureButton to hide bottom vc\n    lazy var sureButton:UIButton = {\n        let button = UIButton(frame: CGRect(x: kScreenWidth-60, y: 0, width: 40, height: 40))\n//        button.setImage(, for: .normal)\n        button.backgroundColor = .white\n        button.addTarget(self, action: #selector(sureButtonClicked), for: .touchUpInside)\n        button.layer.cornerRadius = 20\n        button.clipsToBounds = true\n        return button\n    }()\n    \n    /// conntainer view of bottom vc\n    lazy var containerView: UIView = {\n        let view = UIView(frame: CGRect(x: 0, y: 75, width: kScreenWidth, height: kScreenHeight-75))\n        view.backgroundColor = UIColor.white\n        return view\n    }()\n    /// titleLabel\n    lazy var titleLabel: UILabel = {\n        let label = UILabel(frame:CGRect(x: (kScreenWidth-150)/2, y: 20, width: 150, height: 30))\n        label.textAlignment = .center\n        label.text = \"Select\"\n        label.font = UIFont.systemFont(ofSize: 20)\n        return label\n    }()\n    override public func viewDidLoad() {\n        super.viewDidLoad()\n        config()\n    }\n    private func config() {\n        view.backgroundColor = UIColor.clear\n        let roundView = RoundView(frame: CGRect(x: 0, y: 0, width: kScreenWidth, height: 150))\n        view.addSubview(roundView)\n        roundView.addSubview(titleLabel)\n        view.addSubview(containerView)\n        view.addSubview(sureButton)\n        let segment1 = UISegmentedControl(items: [\"Girl\",\"Boy\",\"Unsure\"])\n        segment1.frame = CGRect(x: 20, y: 20, width: kScreenWidth-40, height: 35)\n        segment1.selectedSegmentIndex = 0\n        segment1.tintColor = UIColor(red: 190/255, green: 31/255, blue: 109/255, alpha: 1)\n        containerView.addSubview(segment1)\n        let segment2 = UISegmentedControl(items: [\"🍎\",\"🍋\",\"🍊\"])\n        segment2.frame = CGRect(x: 20, y: 75, width: kScreenWidth-40, height: 35)\n        segment2.selectedSegmentIndex = 1\n        segment2.tintColor = UIColor(red: 190/255, green: 31/255, blue: 109/255, alpha: 1)\n        containerView.addSubview(segment2)\n        let segment3 = UISegmentedControl(items: [\"Home\",\"Company\",\"Parking Lot\"])\n        segment3.frame = CGRect(x: 20, y: 130, width: kScreenWidth-40, height: 35)\n        segment3.selectedSegmentIndex = 2\n        segment3.tintColor = UIColor(red: 190/255, green: 31/255, blue: 109/255, alpha: 1)\n        containerView.addSubview(segment3)\n    }\n    @objc func sureButtonClicked() {\n        self.dismiss(animated: true, completion: nil)\n    }\n}\n/// create a bezier path view\npublic class RoundView: UIView {\n    public override init(frame: CGRect) {\n        super.init(frame: frame)\n        backgroundColor = UIColor.clear\n    }\n    required public init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    public override func draw(_ rect: CGRect) {\n        let color = UIColor.white\n        color.set()\n        let path = UIBezierPath(ovalIn: rect)\n        path.fill()\n    }\n}\n```\n\n#### 最后调用\n调用和系统调用类似，在第一个 Controller 上调用 `self.presentBottom(HUTestVC())`。\n<br>\n> 参考资料\n> [用UIPresentationController来写一个简洁漂亮的底部弹出控件](https://github.com/IkeBanPC/PresentBottom)","source":"_posts/使用 UIPresentationController 实现底部弹出页面 .md","raw":"---\nlayout: Swift\ntitle: 使用 UIPresentationController 实现底部弹出页面 \ndate: 2018-03-08 14:07:13\ntags:\n- Swift\ncategories:\n- Swift\n---\n底部弹出框在项目中很常见，之前对此的理解很肤浅，不太明白如何更好的实现自定义的页面。刚好在 [GitHub](https://github.com/IkeBanPC/PresentBottom) 看到有一中很简单的实现方式，是利用 UIPresentationController 和继承的方式实现。学习一下，自己再通过协议的方式实现下，加深自己的理解。\n<!--- more --->\n#### 实现效果\n![UIPresentationController 底部弹出](https://raw.githubusercontent.com/IkeBanPC/PresentBottom/master/Pics/Select.gif)\n#### 实现 UIPresentationController\n关于 `UIPresentationController` 的描述，官网的说法是 \n> An object that manages the transition animations and the presentation of view controllers onscreen.\n\n简单点说就是管理两个 Controller 之间的转场动画。\n所以可以通过重写这个类来自定义想要的转场动画。\n首先创建一个类来继承 `UIPresentationController`，并重写一些必要的方法\n\n```\nclass HUPresentController: UIPresentationController {\n\t//获取转场 Controller 高度\n    var controllerHeight: CGFloat = 0\n    //决定了弹出框的frame\n    override var frameOfPresentedViewInContainerView: CGRect {\n        return CGRect(x: 0, y: UIScreen.main.bounds.height - controllerHeight , width: UIScreen.main.bounds.width, height: controllerHeight)\n    }\n    //重写此方法可以在弹框即将显示时执行所需要的操作\n    override func presentationTransitionWillBegin() {\n        blackView.alpha = 0\n        containerView?.addSubview(blackView)\n        UIView.animate(withDuration: 0.3) { self.blackView.alpha = 1 }\n    }\n    //重写此方法可以在弹框显示完毕时执行所需要的操作\n    override func presentationTransitionDidEnd(_ completed: Bool) {\n    }\n    //重写此方法可以在弹框即将消失时执行所需要的操作\n    override func dismissalTransitionWillBegin() {\n        UIView.animate(withDuration: 0.5) { self.blackView.alpha = 0 }\n    }\n    //重写此方法可以在弹框消失之后执行所需要的操作\n    override func dismissalTransitionDidEnd(_ completed: Bool) {\n        if completed { blackView.removeFromSuperview() }\n    }\n    //遮挡阴影\n    lazy var blackView: UIView = {\n        let view = UIView()\n        if let frame = self.containerView?.bounds {\n            view.frame = frame\n        }\n        view.backgroundColor = UIColor.black.withAlphaComponent(0.5)\n        return view\n    }()\n\n    override init(presentedViewController: UIViewController, presenting presentingViewController: UIViewController?) {\n        if let vc = presentedViewController as? PresentProtocol {\n            controllerHeight = vc.controllerHeight\n        }\n        super.init(presentedViewController:presentedViewController,presenting: presentingViewController)\n    }\n}\n```\n#### 协议 && UIViewController 扩展\n原来的项目是通过继承的方式来实现的，但是在 Swift 中并不提倡使用继承，所以我们改用协议的方式来实现。\n```\nprotocol PresentProtocol {\n    var controllerHeight: CGFloat { get }\n}\nextension PresentProtocol where Self: UIViewController {}\n//对 UIViewController 进行拓展，并让其遵守转场协议\nextension UIViewController: UIViewControllerTransitioningDelegate  {\n    func presentBottom(_ vc: UIViewController) {\n        vc.modalPresentationStyle = .custom\n        vc.transitioningDelegate = self\n        self.present(vc, animated: true, completion: nil)\n    }\n    public func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -> UIPresentationController? {\n        let present = HUPresentController(presentedViewController: presented, presenting: presenting)\n        return present\n    }\n}\n```\n#### 实现自定义 Controller \n准备工作到了最后一步就是实现自定义的 Controller 了，确保 Controller 遵循刚才定义的协议 `PresentProtocol`，并实现协议属性。\n\n```\nclass HUTestVC: UIViewController, PresentProtocol {\n    var controllerHeight: CGFloat { return 600 }\n    /// sureButton to hide bottom vc\n    lazy var sureButton:UIButton = {\n        let button = UIButton(frame: CGRect(x: kScreenWidth-60, y: 0, width: 40, height: 40))\n//        button.setImage(, for: .normal)\n        button.backgroundColor = .white\n        button.addTarget(self, action: #selector(sureButtonClicked), for: .touchUpInside)\n        button.layer.cornerRadius = 20\n        button.clipsToBounds = true\n        return button\n    }()\n    \n    /// conntainer view of bottom vc\n    lazy var containerView: UIView = {\n        let view = UIView(frame: CGRect(x: 0, y: 75, width: kScreenWidth, height: kScreenHeight-75))\n        view.backgroundColor = UIColor.white\n        return view\n    }()\n    /// titleLabel\n    lazy var titleLabel: UILabel = {\n        let label = UILabel(frame:CGRect(x: (kScreenWidth-150)/2, y: 20, width: 150, height: 30))\n        label.textAlignment = .center\n        label.text = \"Select\"\n        label.font = UIFont.systemFont(ofSize: 20)\n        return label\n    }()\n    override public func viewDidLoad() {\n        super.viewDidLoad()\n        config()\n    }\n    private func config() {\n        view.backgroundColor = UIColor.clear\n        let roundView = RoundView(frame: CGRect(x: 0, y: 0, width: kScreenWidth, height: 150))\n        view.addSubview(roundView)\n        roundView.addSubview(titleLabel)\n        view.addSubview(containerView)\n        view.addSubview(sureButton)\n        let segment1 = UISegmentedControl(items: [\"Girl\",\"Boy\",\"Unsure\"])\n        segment1.frame = CGRect(x: 20, y: 20, width: kScreenWidth-40, height: 35)\n        segment1.selectedSegmentIndex = 0\n        segment1.tintColor = UIColor(red: 190/255, green: 31/255, blue: 109/255, alpha: 1)\n        containerView.addSubview(segment1)\n        let segment2 = UISegmentedControl(items: [\"🍎\",\"🍋\",\"🍊\"])\n        segment2.frame = CGRect(x: 20, y: 75, width: kScreenWidth-40, height: 35)\n        segment2.selectedSegmentIndex = 1\n        segment2.tintColor = UIColor(red: 190/255, green: 31/255, blue: 109/255, alpha: 1)\n        containerView.addSubview(segment2)\n        let segment3 = UISegmentedControl(items: [\"Home\",\"Company\",\"Parking Lot\"])\n        segment3.frame = CGRect(x: 20, y: 130, width: kScreenWidth-40, height: 35)\n        segment3.selectedSegmentIndex = 2\n        segment3.tintColor = UIColor(red: 190/255, green: 31/255, blue: 109/255, alpha: 1)\n        containerView.addSubview(segment3)\n    }\n    @objc func sureButtonClicked() {\n        self.dismiss(animated: true, completion: nil)\n    }\n}\n/// create a bezier path view\npublic class RoundView: UIView {\n    public override init(frame: CGRect) {\n        super.init(frame: frame)\n        backgroundColor = UIColor.clear\n    }\n    required public init?(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n    }\n    public override func draw(_ rect: CGRect) {\n        let color = UIColor.white\n        color.set()\n        let path = UIBezierPath(ovalIn: rect)\n        path.fill()\n    }\n}\n```\n\n#### 最后调用\n调用和系统调用类似，在第一个 Controller 上调用 `self.presentBottom(HUTestVC())`。\n<br>\n> 参考资料\n> [用UIPresentationController来写一个简洁漂亮的底部弹出控件](https://github.com/IkeBanPC/PresentBottom)","slug":"使用 UIPresentationController 实现底部弹出页面 ","published":1,"updated":"2018-03-22T06:33:41.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyaq001l7sn6b4vhhzyu","content":"<p>底部弹出框在项目中很常见，之前对此的理解很肤浅，不太明白如何更好的实现自定义的页面。刚好在 <a href=\"https://github.com/IkeBanPC/PresentBottom\">GitHub</a> 看到有一中很简单的实现方式，是利用 UIPresentationController 和继承的方式实现。学习一下，自己再通过协议的方式实现下，加深自己的理解。</p>\n<!--- more --->\n<h4 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h4><p><img src=\"https://raw.githubusercontent.com/IkeBanPC/PresentBottom/master/Pics/Select.gif\" alt=\"UIPresentationController 底部弹出\"></p>\n<h4 id=\"实现-UIPresentationController\"><a href=\"#实现-UIPresentationController\" class=\"headerlink\" title=\"实现 UIPresentationController\"></a>实现 UIPresentationController</h4><p>关于 <code>UIPresentationController</code> 的描述，官网的说法是 </p>\n<blockquote>\n<p>An object that manages the transition animations and the presentation of view controllers onscreen.</p>\n</blockquote>\n<p>简单点说就是管理两个 Controller 之间的转场动画。<br>所以可以通过重写这个类来自定义想要的转场动画。<br>首先创建一个类来继承 <code>UIPresentationController</code>，并重写一些必要的方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HUPresentController</span>: <span class=\"title\">UIPresentationController</span> </span>&#123;</span><br><span class=\"line\">true<span class=\"comment\">//获取转场 Controller 高度</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> controllerHeight: <span class=\"type\">CGFloat</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//决定了弹出框的frame</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> frameOfPresentedViewInContainerView: <span class=\"type\">CGRect</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"type\">UIScreen</span>.main.bounds.height <span class=\"operator\">-</span> controllerHeight , width: <span class=\"type\">UIScreen</span>.main.bounds.width, height: controllerHeight)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重写此方法可以在弹框即将显示时执行所需要的操作</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionWillBegin</span>()</span> &#123;</span><br><span class=\"line\">        blackView.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">        containerView<span class=\"operator\">?</span>.addSubview(blackView)</span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123; <span class=\"keyword\">self</span>.blackView.alpha <span class=\"operator\">=</span> <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重写此方法可以在弹框显示完毕时执行所需要的操作</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionDidEnd</span>(<span class=\"keyword\">_</span> <span class=\"params\">completed</span>: <span class=\"type\">Bool</span>)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重写此方法可以在弹框即将消失时执行所需要的操作</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionWillBegin</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.5</span>) &#123; <span class=\"keyword\">self</span>.blackView.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重写此方法可以在弹框消失之后执行所需要的操作</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionDidEnd</span>(<span class=\"keyword\">_</span> <span class=\"params\">completed</span>: <span class=\"type\">Bool</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> completed &#123; blackView.removeFromSuperview() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//遮挡阴影</span></span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> blackView: <span class=\"type\">UIView</span> <span class=\"operator\">=</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> view <span class=\"operator\">=</span> <span class=\"type\">UIView</span>()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> frame <span class=\"operator\">=</span> <span class=\"keyword\">self</span>.containerView<span class=\"operator\">?</span>.bounds &#123;</span><br><span class=\"line\">            view.frame <span class=\"operator\">=</span> frame</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        view.backgroundColor <span class=\"operator\">=</span> <span class=\"type\">UIColor</span>.black.withAlphaComponent(<span class=\"number\">0.5</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">presentedViewController</span>: <span class=\"type\">UIViewController</span>, <span class=\"params\">presenting</span> <span class=\"params\">presentingViewController</span>: <span class=\"type\">UIViewController</span>?)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> vc <span class=\"operator\">=</span> presentedViewController <span class=\"keyword\">as?</span> <span class=\"type\">PresentProtocol</span> &#123;</span><br><span class=\"line\">            controllerHeight <span class=\"operator\">=</span> vc.controllerHeight</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(presentedViewController:presentedViewController,presenting: presentingViewController)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"协议-amp-amp-UIViewController-扩展\"><a href=\"#协议-amp-amp-UIViewController-扩展\" class=\"headerlink\" title=\"协议 &amp;&amp; UIViewController 扩展\"></a>协议 &amp;&amp; UIViewController 扩展</h4><p>原来的项目是通过继承的方式来实现的，但是在 Swift 中并不提倡使用继承，所以我们改用协议的方式来实现。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">PresentProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> controllerHeight: <span class=\"type\">CGFloat</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">PresentProtocol</span> <span class=\"title\">where</span> <span class=\"title\">Self</span>: <span class=\"title\">UIViewController</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//对 UIViewController 进行拓展，并让其遵守转场协议</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIViewController</span>: <span class=\"title\">UIViewControllerTransitioningDelegate</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentBottom</span>(<span class=\"keyword\">_</span> <span class=\"params\">vc</span>: <span class=\"type\">UIViewController</span>)</span> &#123;</span><br><span class=\"line\">        vc.modalPresentationStyle <span class=\"operator\">=</span> .custom</span><br><span class=\"line\">        vc.transitioningDelegate <span class=\"operator\">=</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.present(vc, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationController</span>(<span class=\"params\">forPresented</span> <span class=\"params\">presented</span>: <span class=\"type\">UIViewController</span>, <span class=\"params\">presenting</span>: <span class=\"type\">UIViewController</span>?, <span class=\"params\">source</span>: <span class=\"type\">UIViewController</span>)</span> -&gt; <span class=\"type\">UIPresentationController</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> present <span class=\"operator\">=</span> <span class=\"type\">HUPresentController</span>(presentedViewController: presented, presenting: presenting)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> present</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实现自定义-Controller\"><a href=\"#实现自定义-Controller\" class=\"headerlink\" title=\"实现自定义 Controller\"></a>实现自定义 Controller</h4><p>准备工作到了最后一步就是实现自定义的 Controller 了，确保 Controller 遵循刚才定义的协议 <code>PresentProtocol</code>，并实现协议属性。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> HUTestVC: UIViewController, PresentProtocol &#123;</span><br><span class=\"line\">    var controllerHeight: CGFloat &#123; return <span class=\"number\">600</span> &#125;</span><br><span class=\"line\">    <span class=\"comment\">/// sureButton to hide bottom vc</span></span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> var sureButton:UIButton = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = <span class=\"constructor\">UIButton(<span class=\"params\">frame</span>: CGRect(<span class=\"params\">x</span>: <span class=\"params\">kScreenWidth</span>-60, <span class=\"params\">y</span>: 0, <span class=\"params\">width</span>: 40, <span class=\"params\">height</span>: 40)</span>)</span><br><span class=\"line\"><span class=\"comment\">//        button.setImage(, for: .normal)</span></span><br><span class=\"line\">        button.backgroundColor = .white</span><br><span class=\"line\">        button.add<span class=\"constructor\">Target(<span class=\"params\">self</span>, <span class=\"params\">action</span>: #<span class=\"params\">selector</span>(<span class=\"params\">sureButtonClicked</span>)</span>, <span class=\"keyword\">for</span>: .touchUpInside)</span><br><span class=\"line\">        button.layer.cornerRadius = <span class=\"number\">20</span></span><br><span class=\"line\">        button.clipsToBounds = <span class=\"literal\">true</span></span><br><span class=\"line\">        return button</span><br><span class=\"line\">    &#125;<span class=\"literal\">()</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// conntainer view of bottom vc</span></span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> var containerView: UIView = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> view = <span class=\"constructor\">UIView(<span class=\"params\">frame</span>: CGRect(<span class=\"params\">x</span>: 0, <span class=\"params\">y</span>: 75, <span class=\"params\">width</span>: <span class=\"params\">kScreenWidth</span>, <span class=\"params\">height</span>: <span class=\"params\">kScreenHeight</span>-75)</span>)</span><br><span class=\"line\">        view.backgroundColor = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">UIColor</span>.</span></span>white</span><br><span class=\"line\">        return view</span><br><span class=\"line\">    &#125;<span class=\"literal\">()</span></span><br><span class=\"line\">    <span class=\"comment\">/// titleLabel</span></span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> var titleLabel: UILabel = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> label = <span class=\"constructor\">UILabel(<span class=\"params\">frame</span>:CGRect(<span class=\"params\">x</span>: (<span class=\"params\">kScreenWidth</span>-150)</span>/<span class=\"number\">2</span>, y: <span class=\"number\">20</span>, width: <span class=\"number\">150</span>, height: <span class=\"number\">30</span>))</span><br><span class=\"line\">        label.textAlignment = .center</span><br><span class=\"line\">        label.text = <span class=\"string\">&quot;Select&quot;</span></span><br><span class=\"line\">        label.font = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">UIFont</span>.</span></span>system<span class=\"constructor\">Font(<span class=\"params\">ofSize</span>: 20)</span></span><br><span class=\"line\">        return label</span><br><span class=\"line\">    &#125;<span class=\"literal\">()</span></span><br><span class=\"line\">    override public func view<span class=\"constructor\">DidLoad()</span> &#123;</span><br><span class=\"line\">        super.view<span class=\"constructor\">DidLoad()</span></span><br><span class=\"line\">        config<span class=\"literal\">()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> func config<span class=\"literal\">()</span> &#123;</span><br><span class=\"line\">        view.backgroundColor = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">UIColor</span>.</span></span>clear</span><br><span class=\"line\">        <span class=\"keyword\">let</span> roundView = <span class=\"constructor\">RoundView(<span class=\"params\">frame</span>: CGRect(<span class=\"params\">x</span>: 0, <span class=\"params\">y</span>: 0, <span class=\"params\">width</span>: <span class=\"params\">kScreenWidth</span>, <span class=\"params\">height</span>: 150)</span>)</span><br><span class=\"line\">        view.add<span class=\"constructor\">Subview(<span class=\"params\">roundView</span>)</span></span><br><span class=\"line\">        roundView.add<span class=\"constructor\">Subview(<span class=\"params\">titleLabel</span>)</span></span><br><span class=\"line\">        view.add<span class=\"constructor\">Subview(<span class=\"params\">containerView</span>)</span></span><br><span class=\"line\">        view.add<span class=\"constructor\">Subview(<span class=\"params\">sureButton</span>)</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> segment1 = <span class=\"constructor\">UISegmentedControl(<span class=\"params\">items</span>: [<span class=\"string\">&quot;Girl&quot;</span>,<span class=\"string\">&quot;Boy&quot;</span>,<span class=\"string\">&quot;Unsure&quot;</span>])</span></span><br><span class=\"line\">        segment1.frame = <span class=\"constructor\">CGRect(<span class=\"params\">x</span>: 20, <span class=\"params\">y</span>: 20, <span class=\"params\">width</span>: <span class=\"params\">kScreenWidth</span>-40, <span class=\"params\">height</span>: 35)</span></span><br><span class=\"line\">        segment1.selectedSegmentIndex = <span class=\"number\">0</span></span><br><span class=\"line\">        segment1.tintColor = <span class=\"constructor\">UIColor(<span class=\"params\">red</span>: 190<span class=\"operator\">/</span>255, <span class=\"params\">green</span>: 31<span class=\"operator\">/</span>255, <span class=\"params\">blue</span>: 109<span class=\"operator\">/</span>255, <span class=\"params\">alpha</span>: 1)</span></span><br><span class=\"line\">        containerView.add<span class=\"constructor\">Subview(<span class=\"params\">segment1</span>)</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> segment2 = <span class=\"constructor\">UISegmentedControl(<span class=\"params\">items</span>: [<span class=\"string\">&quot;🍎&quot;</span>,<span class=\"string\">&quot;🍋&quot;</span>,<span class=\"string\">&quot;🍊&quot;</span>])</span></span><br><span class=\"line\">        segment2.frame = <span class=\"constructor\">CGRect(<span class=\"params\">x</span>: 20, <span class=\"params\">y</span>: 75, <span class=\"params\">width</span>: <span class=\"params\">kScreenWidth</span>-40, <span class=\"params\">height</span>: 35)</span></span><br><span class=\"line\">        segment2.selectedSegmentIndex = <span class=\"number\">1</span></span><br><span class=\"line\">        segment2.tintColor = <span class=\"constructor\">UIColor(<span class=\"params\">red</span>: 190<span class=\"operator\">/</span>255, <span class=\"params\">green</span>: 31<span class=\"operator\">/</span>255, <span class=\"params\">blue</span>: 109<span class=\"operator\">/</span>255, <span class=\"params\">alpha</span>: 1)</span></span><br><span class=\"line\">        containerView.add<span class=\"constructor\">Subview(<span class=\"params\">segment2</span>)</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> segment3 = <span class=\"constructor\">UISegmentedControl(<span class=\"params\">items</span>: [<span class=\"string\">&quot;Home&quot;</span>,<span class=\"string\">&quot;Company&quot;</span>,<span class=\"string\">&quot;Parking Lot&quot;</span>])</span></span><br><span class=\"line\">        segment3.frame = <span class=\"constructor\">CGRect(<span class=\"params\">x</span>: 20, <span class=\"params\">y</span>: 130, <span class=\"params\">width</span>: <span class=\"params\">kScreenWidth</span>-40, <span class=\"params\">height</span>: 35)</span></span><br><span class=\"line\">        segment3.selectedSegmentIndex = <span class=\"number\">2</span></span><br><span class=\"line\">        segment3.tintColor = <span class=\"constructor\">UIColor(<span class=\"params\">red</span>: 190<span class=\"operator\">/</span>255, <span class=\"params\">green</span>: 31<span class=\"operator\">/</span>255, <span class=\"params\">blue</span>: 109<span class=\"operator\">/</span>255, <span class=\"params\">alpha</span>: 1)</span></span><br><span class=\"line\">        containerView.add<span class=\"constructor\">Subview(<span class=\"params\">segment3</span>)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @objc func sure<span class=\"constructor\">ButtonClicked()</span> &#123;</span><br><span class=\"line\">        self.dismiss(animated: <span class=\"literal\">true</span>, completion: nil)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/// create a bezier path view</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> RoundView: UIView &#123;</span><br><span class=\"line\">    public override init(frame: CGRect) &#123;</span><br><span class=\"line\">        super.init(frame: frame)</span><br><span class=\"line\">        backgroundColor = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">UIColor</span>.</span></span>clear</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    required public init?(coder aDecoder: NSCoder) &#123;</span><br><span class=\"line\">        super.init(coder: aDecoder)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public override func draw(_ rect: CGRect) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> color = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">UIColor</span>.</span></span>white</span><br><span class=\"line\">        color.set<span class=\"literal\">()</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> path = <span class=\"constructor\">UIBezierPath(<span class=\"params\">ovalIn</span>: <span class=\"params\">rect</span>)</span></span><br><span class=\"line\">        path.fill<span class=\"literal\">()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"最后调用\"><a href=\"#最后调用\" class=\"headerlink\" title=\"最后调用\"></a>最后调用</h4><p>调用和系统调用类似，在第一个 Controller 上调用 <code>self.presentBottom(HUTestVC())</code>。<br><br></p>\n<blockquote>\n<p>参考资料<br><a href=\"https://github.com/IkeBanPC/PresentBottom\">用UIPresentationController来写一个简洁漂亮的底部弹出控件</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>底部弹出框在项目中很常见，之前对此的理解很肤浅，不太明白如何更好的实现自定义的页面。刚好在 <a href=\"https://github.com/IkeBanPC/PresentBottom\">GitHub</a> 看到有一中很简单的实现方式，是利用 UIPresentationController 和继承的方式实现。学习一下，自己再通过协议的方式实现下，加深自己的理解。</p>\n<!--- more --->\n<h4 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h4><p><img src=\"https://raw.githubusercontent.com/IkeBanPC/PresentBottom/master/Pics/Select.gif\" alt=\"UIPresentationController 底部弹出\"></p>\n<h4 id=\"实现-UIPresentationController\"><a href=\"#实现-UIPresentationController\" class=\"headerlink\" title=\"实现 UIPresentationController\"></a>实现 UIPresentationController</h4><p>关于 <code>UIPresentationController</code> 的描述，官网的说法是 </p>\n<blockquote>\n<p>An object that manages the transition animations and the presentation of view controllers onscreen.</p>\n</blockquote>\n<p>简单点说就是管理两个 Controller 之间的转场动画。<br>所以可以通过重写这个类来自定义想要的转场动画。<br>首先创建一个类来继承 <code>UIPresentationController</code>，并重写一些必要的方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HUPresentController</span>: <span class=\"title\">UIPresentationController</span> </span>&#123;</span><br><span class=\"line\">true<span class=\"comment\">//获取转场 Controller 高度</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> controllerHeight: <span class=\"type\">CGFloat</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">//决定了弹出框的frame</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> frameOfPresentedViewInContainerView: <span class=\"type\">CGRect</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"type\">UIScreen</span>.main.bounds.height <span class=\"operator\">-</span> controllerHeight , width: <span class=\"type\">UIScreen</span>.main.bounds.width, height: controllerHeight)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重写此方法可以在弹框即将显示时执行所需要的操作</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionWillBegin</span>()</span> &#123;</span><br><span class=\"line\">        blackView.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">        containerView<span class=\"operator\">?</span>.addSubview(blackView)</span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123; <span class=\"keyword\">self</span>.blackView.alpha <span class=\"operator\">=</span> <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重写此方法可以在弹框显示完毕时执行所需要的操作</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationTransitionDidEnd</span>(<span class=\"keyword\">_</span> <span class=\"params\">completed</span>: <span class=\"type\">Bool</span>)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重写此方法可以在弹框即将消失时执行所需要的操作</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionWillBegin</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.5</span>) &#123; <span class=\"keyword\">self</span>.blackView.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重写此方法可以在弹框消失之后执行所需要的操作</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dismissalTransitionDidEnd</span>(<span class=\"keyword\">_</span> <span class=\"params\">completed</span>: <span class=\"type\">Bool</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> completed &#123; blackView.removeFromSuperview() &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//遮挡阴影</span></span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> blackView: <span class=\"type\">UIView</span> <span class=\"operator\">=</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> view <span class=\"operator\">=</span> <span class=\"type\">UIView</span>()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> frame <span class=\"operator\">=</span> <span class=\"keyword\">self</span>.containerView<span class=\"operator\">?</span>.bounds &#123;</span><br><span class=\"line\">            view.frame <span class=\"operator\">=</span> frame</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        view.backgroundColor <span class=\"operator\">=</span> <span class=\"type\">UIColor</span>.black.withAlphaComponent(<span class=\"number\">0.5</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">presentedViewController</span>: <span class=\"type\">UIViewController</span>, <span class=\"params\">presenting</span> <span class=\"params\">presentingViewController</span>: <span class=\"type\">UIViewController</span>?)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> vc <span class=\"operator\">=</span> presentedViewController <span class=\"keyword\">as?</span> <span class=\"type\">PresentProtocol</span> &#123;</span><br><span class=\"line\">            controllerHeight <span class=\"operator\">=</span> vc.controllerHeight</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(presentedViewController:presentedViewController,presenting: presentingViewController)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"协议-amp-amp-UIViewController-扩展\"><a href=\"#协议-amp-amp-UIViewController-扩展\" class=\"headerlink\" title=\"协议 &amp;&amp; UIViewController 扩展\"></a>协议 &amp;&amp; UIViewController 扩展</h4><p>原来的项目是通过继承的方式来实现的，但是在 Swift 中并不提倡使用继承，所以我们改用协议的方式来实现。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">PresentProtocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> controllerHeight: <span class=\"type\">CGFloat</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">PresentProtocol</span> <span class=\"title\">where</span> <span class=\"title\">Self</span>: <span class=\"title\">UIViewController</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//对 UIViewController 进行拓展，并让其遵守转场协议</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIViewController</span>: <span class=\"title\">UIViewControllerTransitioningDelegate</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentBottom</span>(<span class=\"keyword\">_</span> <span class=\"params\">vc</span>: <span class=\"type\">UIViewController</span>)</span> &#123;</span><br><span class=\"line\">        vc.modalPresentationStyle <span class=\"operator\">=</span> .custom</span><br><span class=\"line\">        vc.transitioningDelegate <span class=\"operator\">=</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.present(vc, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentationController</span>(<span class=\"params\">forPresented</span> <span class=\"params\">presented</span>: <span class=\"type\">UIViewController</span>, <span class=\"params\">presenting</span>: <span class=\"type\">UIViewController</span>?, <span class=\"params\">source</span>: <span class=\"type\">UIViewController</span>)</span> -&gt; <span class=\"type\">UIPresentationController</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> present <span class=\"operator\">=</span> <span class=\"type\">HUPresentController</span>(presentedViewController: presented, presenting: presenting)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> present</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"实现自定义-Controller\"><a href=\"#实现自定义-Controller\" class=\"headerlink\" title=\"实现自定义 Controller\"></a>实现自定义 Controller</h4><p>准备工作到了最后一步就是实现自定义的 Controller 了，确保 Controller 遵循刚才定义的协议 <code>PresentProtocol</code>，并实现协议属性。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> HUTestVC: UIViewController, PresentProtocol &#123;</span><br><span class=\"line\">    var controllerHeight: CGFloat &#123; return <span class=\"number\">600</span> &#125;</span><br><span class=\"line\">    <span class=\"comment\">/// sureButton to hide bottom vc</span></span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> var sureButton:UIButton = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = <span class=\"constructor\">UIButton(<span class=\"params\">frame</span>: CGRect(<span class=\"params\">x</span>: <span class=\"params\">kScreenWidth</span>-60, <span class=\"params\">y</span>: 0, <span class=\"params\">width</span>: 40, <span class=\"params\">height</span>: 40)</span>)</span><br><span class=\"line\"><span class=\"comment\">//        button.setImage(, for: .normal)</span></span><br><span class=\"line\">        button.backgroundColor = .white</span><br><span class=\"line\">        button.add<span class=\"constructor\">Target(<span class=\"params\">self</span>, <span class=\"params\">action</span>: #<span class=\"params\">selector</span>(<span class=\"params\">sureButtonClicked</span>)</span>, <span class=\"keyword\">for</span>: .touchUpInside)</span><br><span class=\"line\">        button.layer.cornerRadius = <span class=\"number\">20</span></span><br><span class=\"line\">        button.clipsToBounds = <span class=\"literal\">true</span></span><br><span class=\"line\">        return button</span><br><span class=\"line\">    &#125;<span class=\"literal\">()</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// conntainer view of bottom vc</span></span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> var containerView: UIView = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> view = <span class=\"constructor\">UIView(<span class=\"params\">frame</span>: CGRect(<span class=\"params\">x</span>: 0, <span class=\"params\">y</span>: 75, <span class=\"params\">width</span>: <span class=\"params\">kScreenWidth</span>, <span class=\"params\">height</span>: <span class=\"params\">kScreenHeight</span>-75)</span>)</span><br><span class=\"line\">        view.backgroundColor = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">UIColor</span>.</span></span>white</span><br><span class=\"line\">        return view</span><br><span class=\"line\">    &#125;<span class=\"literal\">()</span></span><br><span class=\"line\">    <span class=\"comment\">/// titleLabel</span></span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> var titleLabel: UILabel = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> label = <span class=\"constructor\">UILabel(<span class=\"params\">frame</span>:CGRect(<span class=\"params\">x</span>: (<span class=\"params\">kScreenWidth</span>-150)</span>/<span class=\"number\">2</span>, y: <span class=\"number\">20</span>, width: <span class=\"number\">150</span>, height: <span class=\"number\">30</span>))</span><br><span class=\"line\">        label.textAlignment = .center</span><br><span class=\"line\">        label.text = <span class=\"string\">&quot;Select&quot;</span></span><br><span class=\"line\">        label.font = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">UIFont</span>.</span></span>system<span class=\"constructor\">Font(<span class=\"params\">ofSize</span>: 20)</span></span><br><span class=\"line\">        return label</span><br><span class=\"line\">    &#125;<span class=\"literal\">()</span></span><br><span class=\"line\">    override public func view<span class=\"constructor\">DidLoad()</span> &#123;</span><br><span class=\"line\">        super.view<span class=\"constructor\">DidLoad()</span></span><br><span class=\"line\">        config<span class=\"literal\">()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> func config<span class=\"literal\">()</span> &#123;</span><br><span class=\"line\">        view.backgroundColor = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">UIColor</span>.</span></span>clear</span><br><span class=\"line\">        <span class=\"keyword\">let</span> roundView = <span class=\"constructor\">RoundView(<span class=\"params\">frame</span>: CGRect(<span class=\"params\">x</span>: 0, <span class=\"params\">y</span>: 0, <span class=\"params\">width</span>: <span class=\"params\">kScreenWidth</span>, <span class=\"params\">height</span>: 150)</span>)</span><br><span class=\"line\">        view.add<span class=\"constructor\">Subview(<span class=\"params\">roundView</span>)</span></span><br><span class=\"line\">        roundView.add<span class=\"constructor\">Subview(<span class=\"params\">titleLabel</span>)</span></span><br><span class=\"line\">        view.add<span class=\"constructor\">Subview(<span class=\"params\">containerView</span>)</span></span><br><span class=\"line\">        view.add<span class=\"constructor\">Subview(<span class=\"params\">sureButton</span>)</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> segment1 = <span class=\"constructor\">UISegmentedControl(<span class=\"params\">items</span>: [<span class=\"string\">&quot;Girl&quot;</span>,<span class=\"string\">&quot;Boy&quot;</span>,<span class=\"string\">&quot;Unsure&quot;</span>])</span></span><br><span class=\"line\">        segment1.frame = <span class=\"constructor\">CGRect(<span class=\"params\">x</span>: 20, <span class=\"params\">y</span>: 20, <span class=\"params\">width</span>: <span class=\"params\">kScreenWidth</span>-40, <span class=\"params\">height</span>: 35)</span></span><br><span class=\"line\">        segment1.selectedSegmentIndex = <span class=\"number\">0</span></span><br><span class=\"line\">        segment1.tintColor = <span class=\"constructor\">UIColor(<span class=\"params\">red</span>: 190<span class=\"operator\">/</span>255, <span class=\"params\">green</span>: 31<span class=\"operator\">/</span>255, <span class=\"params\">blue</span>: 109<span class=\"operator\">/</span>255, <span class=\"params\">alpha</span>: 1)</span></span><br><span class=\"line\">        containerView.add<span class=\"constructor\">Subview(<span class=\"params\">segment1</span>)</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> segment2 = <span class=\"constructor\">UISegmentedControl(<span class=\"params\">items</span>: [<span class=\"string\">&quot;🍎&quot;</span>,<span class=\"string\">&quot;🍋&quot;</span>,<span class=\"string\">&quot;🍊&quot;</span>])</span></span><br><span class=\"line\">        segment2.frame = <span class=\"constructor\">CGRect(<span class=\"params\">x</span>: 20, <span class=\"params\">y</span>: 75, <span class=\"params\">width</span>: <span class=\"params\">kScreenWidth</span>-40, <span class=\"params\">height</span>: 35)</span></span><br><span class=\"line\">        segment2.selectedSegmentIndex = <span class=\"number\">1</span></span><br><span class=\"line\">        segment2.tintColor = <span class=\"constructor\">UIColor(<span class=\"params\">red</span>: 190<span class=\"operator\">/</span>255, <span class=\"params\">green</span>: 31<span class=\"operator\">/</span>255, <span class=\"params\">blue</span>: 109<span class=\"operator\">/</span>255, <span class=\"params\">alpha</span>: 1)</span></span><br><span class=\"line\">        containerView.add<span class=\"constructor\">Subview(<span class=\"params\">segment2</span>)</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> segment3 = <span class=\"constructor\">UISegmentedControl(<span class=\"params\">items</span>: [<span class=\"string\">&quot;Home&quot;</span>,<span class=\"string\">&quot;Company&quot;</span>,<span class=\"string\">&quot;Parking Lot&quot;</span>])</span></span><br><span class=\"line\">        segment3.frame = <span class=\"constructor\">CGRect(<span class=\"params\">x</span>: 20, <span class=\"params\">y</span>: 130, <span class=\"params\">width</span>: <span class=\"params\">kScreenWidth</span>-40, <span class=\"params\">height</span>: 35)</span></span><br><span class=\"line\">        segment3.selectedSegmentIndex = <span class=\"number\">2</span></span><br><span class=\"line\">        segment3.tintColor = <span class=\"constructor\">UIColor(<span class=\"params\">red</span>: 190<span class=\"operator\">/</span>255, <span class=\"params\">green</span>: 31<span class=\"operator\">/</span>255, <span class=\"params\">blue</span>: 109<span class=\"operator\">/</span>255, <span class=\"params\">alpha</span>: 1)</span></span><br><span class=\"line\">        containerView.add<span class=\"constructor\">Subview(<span class=\"params\">segment3</span>)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @objc func sure<span class=\"constructor\">ButtonClicked()</span> &#123;</span><br><span class=\"line\">        self.dismiss(animated: <span class=\"literal\">true</span>, completion: nil)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/// create a bezier path view</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> RoundView: UIView &#123;</span><br><span class=\"line\">    public override init(frame: CGRect) &#123;</span><br><span class=\"line\">        super.init(frame: frame)</span><br><span class=\"line\">        backgroundColor = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">UIColor</span>.</span></span>clear</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    required public init?(coder aDecoder: NSCoder) &#123;</span><br><span class=\"line\">        super.init(coder: aDecoder)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public override func draw(_ rect: CGRect) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> color = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">UIColor</span>.</span></span>white</span><br><span class=\"line\">        color.set<span class=\"literal\">()</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> path = <span class=\"constructor\">UIBezierPath(<span class=\"params\">ovalIn</span>: <span class=\"params\">rect</span>)</span></span><br><span class=\"line\">        path.fill<span class=\"literal\">()</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"最后调用\"><a href=\"#最后调用\" class=\"headerlink\" title=\"最后调用\"></a>最后调用</h4><p>调用和系统调用类似，在第一个 Controller 上调用 <code>self.presentBottom(HUTestVC())</code>。<br><br></p>\n<blockquote>\n<p>参考资料<br><a href=\"https://github.com/IkeBanPC/PresentBottom\">用UIPresentationController来写一个简洁漂亮的底部弹出控件</a></p>\n</blockquote>\n"},{"layout":"待续","title":"使用vps搭建ss","date":"2017-11-04T07:59:15.000Z","_content":"#### 使用 VPS 搭建 SS\n由于之前的 VPN 到期了，刚好想自己搞一个 VPS，初步搭建记录一下过程。\n<!--- more --->\n#### 购买 VPS 服务器\n登录 [Vultr](https://my.vultr.com/) 官网选择需要的服务器。我选择日本东京的服务器。服务器类型选择 CentOS 7 x64 ![CentOS 7 x64](https://raw.githubusercontent.com/hGhostD/MarkDownPhotos/master/VPS/ServerType.png)等服务器启动后可以获取相关信息，查看 IP 地址和密码![](https://raw.githubusercontent.com/hGhostD/MarkDownPhotos/master/VPS/Account.jpeg)\n#### 配置服务器\n服务搭建完成后需要连接服务器，mac 用户可以直接在终端 使用 `ssh root@XX.XX.XX.XXX` 指令进行连接。windows 可以下载 [XShell](https://nofile.io/f/eb5dUzYMQK4/Xshell_setup_wm.exe) 提取密码: 666。\n连接之后输入密码，遍进入服务器终端。\n\n使用 root 用户登录，运行一下命令:\n```\nwget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n按照提示命令，输入密码、端口号、加密方式(aes-256-cfb)等信息\n```\nCongratulations, Shadowsocks-python server install completed!\nYour Server IP        : // 服务器 IP\nYour Server Port      : // 刚才设置的端口号\nYour Password         : // 刚才设置的密码\nYour Encryption Method:your_encryption_method\n\nWelcome to visit:https://teddysun.com/342.html\nEnjoy it!\n```\n到此初步配置已经结束，最后需要重启一下服务器。\n以后可能还需要用 VPS 做一些更有难度的工作，不过第一步通过 VPS 翻墙总算是大功告成了！！！\n\n<br>\n>参考资料\n>[vultr](https://my.vultr.com/)\n>[自建ss服务器教程](https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B)\n>[Shadowsocks Python版一键安装脚本](https://teddysun.com/342.html)","source":"_posts/使用vps搭建ss.md","raw":"---\nlayout: 待续\ntitle: 使用vps搭建ss\ndate: 2017-11-04 15:59:15\ntags: \n- 待续\ncategories: \n- 待续\n---\n#### 使用 VPS 搭建 SS\n由于之前的 VPN 到期了，刚好想自己搞一个 VPS，初步搭建记录一下过程。\n<!--- more --->\n#### 购买 VPS 服务器\n登录 [Vultr](https://my.vultr.com/) 官网选择需要的服务器。我选择日本东京的服务器。服务器类型选择 CentOS 7 x64 ![CentOS 7 x64](https://raw.githubusercontent.com/hGhostD/MarkDownPhotos/master/VPS/ServerType.png)等服务器启动后可以获取相关信息，查看 IP 地址和密码![](https://raw.githubusercontent.com/hGhostD/MarkDownPhotos/master/VPS/Account.jpeg)\n#### 配置服务器\n服务搭建完成后需要连接服务器，mac 用户可以直接在终端 使用 `ssh root@XX.XX.XX.XXX` 指令进行连接。windows 可以下载 [XShell](https://nofile.io/f/eb5dUzYMQK4/Xshell_setup_wm.exe) 提取密码: 666。\n连接之后输入密码，遍进入服务器终端。\n\n使用 root 用户登录，运行一下命令:\n```\nwget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\nchmod +x shadowsocks.sh\n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n```\n按照提示命令，输入密码、端口号、加密方式(aes-256-cfb)等信息\n```\nCongratulations, Shadowsocks-python server install completed!\nYour Server IP        : // 服务器 IP\nYour Server Port      : // 刚才设置的端口号\nYour Password         : // 刚才设置的密码\nYour Encryption Method:your_encryption_method\n\nWelcome to visit:https://teddysun.com/342.html\nEnjoy it!\n```\n到此初步配置已经结束，最后需要重启一下服务器。\n以后可能还需要用 VPS 做一些更有难度的工作，不过第一步通过 VPS 翻墙总算是大功告成了！！！\n\n<br>\n>参考资料\n>[vultr](https://my.vultr.com/)\n>[自建ss服务器教程](https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B)\n>[Shadowsocks Python版一键安装脚本](https://teddysun.com/342.html)","slug":"使用vps搭建ss","published":1,"updated":"2017-11-06T06:10:28.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyau001q7sn6em5xfmiy","content":"<h4 id=\"使用-VPS-搭建-SS\"><a href=\"#使用-VPS-搭建-SS\" class=\"headerlink\" title=\"使用 VPS 搭建 SS\"></a>使用 VPS 搭建 SS</h4><p>由于之前的 VPN 到期了，刚好想自己搞一个 VPS，初步搭建记录一下过程。</p>\n<!--- more --->\n<h4 id=\"购买-VPS-服务器\"><a href=\"#购买-VPS-服务器\" class=\"headerlink\" title=\"购买 VPS 服务器\"></a>购买 VPS 服务器</h4><p>登录 <a href=\"https://my.vultr.com/\">Vultr</a> 官网选择需要的服务器。我选择日本东京的服务器。服务器类型选择 CentOS 7 x64 <img src=\"https://raw.githubusercontent.com/hGhostD/MarkDownPhotos/master/VPS/ServerType.png\" alt=\"CentOS 7 x64\">等服务器启动后可以获取相关信息，查看 IP 地址和密码<img src=\"https://raw.githubusercontent.com/hGhostD/MarkDownPhotos/master/VPS/Account.jpeg\"></p>\n<h4 id=\"配置服务器\"><a href=\"#配置服务器\" class=\"headerlink\" title=\"配置服务器\"></a>配置服务器</h4><p>服务搭建完成后需要连接服务器，mac 用户可以直接在终端 使用 <code>ssh root@XX.XX.XX.XXX</code> 指令进行连接。windows 可以下载 <a href=\"https://nofile.io/f/eb5dUzYMQK4/Xshell_setup_wm.exe\">XShell</a> 提取密码: 666。<br>连接之后输入密码，遍进入服务器终端。</p>\n<p>使用 root 用户登录，运行一下命令:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --<span class=\"keyword\">no</span>-check-certificate -O shadowsocks.<span class=\"keyword\">sh</span> http<span class=\"variable\">s:</span>//raw.githubusercontent.<span class=\"keyword\">com</span>/teddysun/shadowsocks_install/master/shadowsocks.<span class=\"keyword\">sh</span></span><br><span class=\"line\">chmod +<span class=\"keyword\">x</span> shadowsocks.<span class=\"keyword\">sh</span></span><br><span class=\"line\">./shadowsocks.<span class=\"keyword\">sh</span> <span class=\"number\">2</span>&gt;&amp;<span class=\"number\">1</span> | tee shadowsocks.<span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n<p>按照提示命令，输入密码、端口号、加密方式(aes-256-cfb)等信息</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Congratulations, Shadowsocks-python server install completed!</span><br><span class=\"line\">Your Server IP        : <span class=\"comment\">// 服务器 IP</span></span><br><span class=\"line\">Your Server Port      : <span class=\"comment\">// 刚才设置的端口号</span></span><br><span class=\"line\">Your Password         : <span class=\"comment\">// 刚才设置的密码</span></span><br><span class=\"line\">Your Encryption <span class=\"function\"><span class=\"keyword\">Method</span>:</span>your_encryption_method</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome <span class=\"keyword\">to</span> visit:https:<span class=\"comment\">//teddysun.com/342.html</span></span><br><span class=\"line\">Enjoy it!</span><br></pre></td></tr></table></figure>\n<p>到此初步配置已经结束，最后需要重启一下服务器。<br>以后可能还需要用 VPS 做一些更有难度的工作，不过第一步通过 VPS 翻墙总算是大功告成了！！！</p>\n<br>\n>参考资料\n>[vultr](https://my.vultr.com/)\n>[自建ss服务器教程](https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B)\n>[Shadowsocks Python版一键安装脚本](https://teddysun.com/342.html)","site":{"data":{}},"excerpt":"","more":"<h4 id=\"使用-VPS-搭建-SS\"><a href=\"#使用-VPS-搭建-SS\" class=\"headerlink\" title=\"使用 VPS 搭建 SS\"></a>使用 VPS 搭建 SS</h4><p>由于之前的 VPN 到期了，刚好想自己搞一个 VPS，初步搭建记录一下过程。</p>\n<!--- more --->\n<h4 id=\"购买-VPS-服务器\"><a href=\"#购买-VPS-服务器\" class=\"headerlink\" title=\"购买 VPS 服务器\"></a>购买 VPS 服务器</h4><p>登录 <a href=\"https://my.vultr.com/\">Vultr</a> 官网选择需要的服务器。我选择日本东京的服务器。服务器类型选择 CentOS 7 x64 <img src=\"https://raw.githubusercontent.com/hGhostD/MarkDownPhotos/master/VPS/ServerType.png\" alt=\"CentOS 7 x64\">等服务器启动后可以获取相关信息，查看 IP 地址和密码<img src=\"https://raw.githubusercontent.com/hGhostD/MarkDownPhotos/master/VPS/Account.jpeg\"></p>\n<h4 id=\"配置服务器\"><a href=\"#配置服务器\" class=\"headerlink\" title=\"配置服务器\"></a>配置服务器</h4><p>服务搭建完成后需要连接服务器，mac 用户可以直接在终端 使用 <code>ssh root@XX.XX.XX.XXX</code> 指令进行连接。windows 可以下载 <a href=\"https://nofile.io/f/eb5dUzYMQK4/Xshell_setup_wm.exe\">XShell</a> 提取密码: 666。<br>连接之后输入密码，遍进入服务器终端。</p>\n<p>使用 root 用户登录，运行一下命令:</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget --<span class=\"keyword\">no</span>-check-certificate -O shadowsocks.<span class=\"keyword\">sh</span> http<span class=\"variable\">s:</span>//raw.githubusercontent.<span class=\"keyword\">com</span>/teddysun/shadowsocks_install/master/shadowsocks.<span class=\"keyword\">sh</span></span><br><span class=\"line\">chmod +<span class=\"keyword\">x</span> shadowsocks.<span class=\"keyword\">sh</span></span><br><span class=\"line\">./shadowsocks.<span class=\"keyword\">sh</span> <span class=\"number\">2</span>&gt;&amp;<span class=\"number\">1</span> | tee shadowsocks.<span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n<p>按照提示命令，输入密码、端口号、加密方式(aes-256-cfb)等信息</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Congratulations, Shadowsocks-python server install completed!</span><br><span class=\"line\">Your Server IP        : <span class=\"comment\">// 服务器 IP</span></span><br><span class=\"line\">Your Server Port      : <span class=\"comment\">// 刚才设置的端口号</span></span><br><span class=\"line\">Your Password         : <span class=\"comment\">// 刚才设置的密码</span></span><br><span class=\"line\">Your Encryption <span class=\"function\"><span class=\"keyword\">Method</span>:</span>your_encryption_method</span><br><span class=\"line\"></span><br><span class=\"line\">Welcome <span class=\"keyword\">to</span> visit:https:<span class=\"comment\">//teddysun.com/342.html</span></span><br><span class=\"line\">Enjoy it!</span><br></pre></td></tr></table></figure>\n<p>到此初步配置已经结束，最后需要重启一下服务器。<br>以后可能还需要用 VPS 做一些更有难度的工作，不过第一步通过 VPS 翻墙总算是大功告成了！！！</p>\n<br>\n>参考资料\n>[vultr](https://my.vultr.com/)\n>[自建ss服务器教程](https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B)\n>[Shadowsocks Python版一键安装脚本](https://teddysun.com/342.html)"},{"layout":"Objective-c","title":"关于RestKit的使用","date":"2018-06-23T10:34:37.000Z","_content":"最新需要使用 RestKit 框架处理网络请求，查了一下资料发现网上的资料确实不多，但还是有人翻译了一些资料的，趁此机会学习一下吧。\n<!--- more --->\n#### 服务器搭建\n使用 RestKit 框架，需要有一个支持 Restful 的网络接口，为了方便自己测试，我们可以自行搭建一个本地的 Restful 接口。方法不是很复杂可以参考 [搭建 Restful 服务器](http://mclspace.com/2016/06/26/node-json-server/)。搭建成功后访问本地 3000 端口，访问 http://localhost:3000/posts/1 可以获得返回 json。\n#### RestKit 文档\n关于使用 RestKit 的文章，可以参考[这里](https://segmentfault.com/a/1190000003745207)，十分详细我们可以参考这里的介绍来使用。\n#### 集成 RestKit\n还是推荐使用 cocoapods 集成，方便管理。\n#### 创建解析 Model\nRestKit 非常强大的功能就是能够对返回 json 进行映射处理。所以很多时候需要使用 `RKObjectMapping` 来管理映射对象。刚才已经成功搭建了自己的服务器，先访问一下看看 json 的格式，如下：\n\n```\n{\n  \"id\": 1,\n  \"title\": \"json-server\",\n  \"author\": \"typicode\"\n}\n```\n这个 json 很容易理解，我们只需创建一个 ResultModel 的 class，来映射 json 即可，只需要在 .h 文件中声明 key。\n#### URL 请求设置\n在发送网络请求前，一定要明确的信息就是 URL，在使用 RestKit 前，就需要创建好 URL 的使用类。\n\n```\nNSURL *baseUrl = [NSURL URLWithString:@\"http://localhost:3000\"];\nAFRKHTTPClient *httpClient = [[AFRKHTTPClient alloc]initWithBaseURL:baseUrl];\n    \nRKObjectManager *objectManager = [[RKObjectManager alloc]initWithHTTPClient:httpClient];\n[objectManager setRequestSerializationMIMEType:RKMIMETypeJSON];\nhttpClient.allowsInvalidSSLCertificate = YES;\n```\n相应的一些 header 的关键信息，就可以添加到 httpClient 中，例如 `[httpClient setDefaultHeader:@\"Content-Encoding\" value:@\"gzip\"];`。\n#### RKResponseDescriptor 设置\n在发送请求之前，还需要的关键一步就是对返回 response 的处理，在这里设置对返回 json 的映射处理。\n\n```\nRKObjectMapping *mapping = [RKObjectMapping mappingForClass:[ResultModel class]];\n[mapping addAttributeMappingsFromDictionary:@{@\"id\":@\"identifier\",@\"title\":@\"title\",@\"author\":@\"author\"}];\nNSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful);\nRKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping \nmethod:RKRequestMethodGET\npathPattern:nil \nkeyPath:nil\nstatusCodes:statusCodes];\n[objectManager addResponseDescriptor:responseDescriptor];\n```\n#### 发送参数访问\n最后一步就是想正确的路径发送参数进行访问了，很容易理解。\n\n```\n[RKObjectManager.sharedManager getObject:_manager path:@\"posts/1\"\nparameters:nil\nsuccess:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {\n\tsuccessBlock(mappingResult);\n} failure:^(RKObjectRequestOperation *operation, NSError *error) {\n\terrorBlock(error);\n}];                                      \n```\n至此，一个基本的访问请求已经可以实现了。但是 RestKit 支持的功能还有很多没有使用到，最近公司也有个需求是要使请求发送 Gzip 数据，这就需要对 RestKit 进行一些拓展了，以后会详细说明。\n\n<br>\n> [搭建 Restful 服务器](http://mclspace.com/2016/06/26/node-json-server/)\n> [RestKit ,一个用于更好支持RESTful风格服务器接口的iOS库](https://segmentfault.com/a/1190000003745207)","source":"_posts/关于Restkit的使用.md","raw":"---\nlayout: Objective-c\ntitle: 关于RestKit的使用\ndate: 2018-06-23 18:34:37\ntags:\n- Objective-C\ncategories:\n- Objective-C\n---\n最新需要使用 RestKit 框架处理网络请求，查了一下资料发现网上的资料确实不多，但还是有人翻译了一些资料的，趁此机会学习一下吧。\n<!--- more --->\n#### 服务器搭建\n使用 RestKit 框架，需要有一个支持 Restful 的网络接口，为了方便自己测试，我们可以自行搭建一个本地的 Restful 接口。方法不是很复杂可以参考 [搭建 Restful 服务器](http://mclspace.com/2016/06/26/node-json-server/)。搭建成功后访问本地 3000 端口，访问 http://localhost:3000/posts/1 可以获得返回 json。\n#### RestKit 文档\n关于使用 RestKit 的文章，可以参考[这里](https://segmentfault.com/a/1190000003745207)，十分详细我们可以参考这里的介绍来使用。\n#### 集成 RestKit\n还是推荐使用 cocoapods 集成，方便管理。\n#### 创建解析 Model\nRestKit 非常强大的功能就是能够对返回 json 进行映射处理。所以很多时候需要使用 `RKObjectMapping` 来管理映射对象。刚才已经成功搭建了自己的服务器，先访问一下看看 json 的格式，如下：\n\n```\n{\n  \"id\": 1,\n  \"title\": \"json-server\",\n  \"author\": \"typicode\"\n}\n```\n这个 json 很容易理解，我们只需创建一个 ResultModel 的 class，来映射 json 即可，只需要在 .h 文件中声明 key。\n#### URL 请求设置\n在发送网络请求前，一定要明确的信息就是 URL，在使用 RestKit 前，就需要创建好 URL 的使用类。\n\n```\nNSURL *baseUrl = [NSURL URLWithString:@\"http://localhost:3000\"];\nAFRKHTTPClient *httpClient = [[AFRKHTTPClient alloc]initWithBaseURL:baseUrl];\n    \nRKObjectManager *objectManager = [[RKObjectManager alloc]initWithHTTPClient:httpClient];\n[objectManager setRequestSerializationMIMEType:RKMIMETypeJSON];\nhttpClient.allowsInvalidSSLCertificate = YES;\n```\n相应的一些 header 的关键信息，就可以添加到 httpClient 中，例如 `[httpClient setDefaultHeader:@\"Content-Encoding\" value:@\"gzip\"];`。\n#### RKResponseDescriptor 设置\n在发送请求之前，还需要的关键一步就是对返回 response 的处理，在这里设置对返回 json 的映射处理。\n\n```\nRKObjectMapping *mapping = [RKObjectMapping mappingForClass:[ResultModel class]];\n[mapping addAttributeMappingsFromDictionary:@{@\"id\":@\"identifier\",@\"title\":@\"title\",@\"author\":@\"author\"}];\nNSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful);\nRKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping \nmethod:RKRequestMethodGET\npathPattern:nil \nkeyPath:nil\nstatusCodes:statusCodes];\n[objectManager addResponseDescriptor:responseDescriptor];\n```\n#### 发送参数访问\n最后一步就是想正确的路径发送参数进行访问了，很容易理解。\n\n```\n[RKObjectManager.sharedManager getObject:_manager path:@\"posts/1\"\nparameters:nil\nsuccess:^(RKObjectRequestOperation *operation, RKMappingResult *mappingResult) {\n\tsuccessBlock(mappingResult);\n} failure:^(RKObjectRequestOperation *operation, NSError *error) {\n\terrorBlock(error);\n}];                                      \n```\n至此，一个基本的访问请求已经可以实现了。但是 RestKit 支持的功能还有很多没有使用到，最近公司也有个需求是要使请求发送 Gzip 数据，这就需要对 RestKit 进行一些拓展了，以后会详细说明。\n\n<br>\n> [搭建 Restful 服务器](http://mclspace.com/2016/06/26/node-json-server/)\n> [RestKit ,一个用于更好支持RESTful风格服务器接口的iOS库](https://segmentfault.com/a/1190000003745207)","slug":"关于Restkit的使用","published":1,"updated":"2020-08-03T09:35:48.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyav001t7sn681jk82k0","content":"<p>最新需要使用 RestKit 框架处理网络请求，查了一下资料发现网上的资料确实不多，但还是有人翻译了一些资料的，趁此机会学习一下吧。</p>\n<!--- more --->\n<h4 id=\"服务器搭建\"><a href=\"#服务器搭建\" class=\"headerlink\" title=\"服务器搭建\"></a>服务器搭建</h4><p>使用 RestKit 框架，需要有一个支持 Restful 的网络接口，为了方便自己测试，我们可以自行搭建一个本地的 Restful 接口。方法不是很复杂可以参考 <a href=\"http://mclspace.com/2016/06/26/node-json-server/\">搭建 Restful 服务器</a>。搭建成功后访问本地 3000 端口，访问 <a href=\"http://localhost:3000/posts/1\">http://localhost:3000/posts/1</a> 可以获得返回 json。</p>\n<h4 id=\"RestKit-文档\"><a href=\"#RestKit-文档\" class=\"headerlink\" title=\"RestKit 文档\"></a>RestKit 文档</h4><p>关于使用 RestKit 的文章，可以参考<a href=\"https://segmentfault.com/a/1190000003745207\">这里</a>，十分详细我们可以参考这里的介绍来使用。</p>\n<h4 id=\"集成-RestKit\"><a href=\"#集成-RestKit\" class=\"headerlink\" title=\"集成 RestKit\"></a>集成 RestKit</h4><p>还是推荐使用 cocoapods 集成，方便管理。</p>\n<h4 id=\"创建解析-Model\"><a href=\"#创建解析-Model\" class=\"headerlink\" title=\"创建解析 Model\"></a>创建解析 Model</h4><p>RestKit 非常强大的功能就是能够对返回 json 进行映射处理。所以很多时候需要使用 <code>RKObjectMapping</code> 来管理映射对象。刚才已经成功搭建了自己的服务器，先访问一下看看 json 的格式，如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;title&quot;</span>: <span class=\"string\">&quot;json-server&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;author&quot;</span>: <span class=\"string\">&quot;typicode&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个 json 很容易理解，我们只需创建一个 ResultModel 的 class，来映射 json 即可，只需要在 .h 文件中声明 key。</p>\n<h4 id=\"URL-请求设置\"><a href=\"#URL-请求设置\" class=\"headerlink\" title=\"URL 请求设置\"></a>URL 请求设置</h4><p>在发送网络请求前，一定要明确的信息就是 URL，在使用 RestKit 前，就需要创建好 URL 的使用类。</p>\n<figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">NSURL</span> *baseUrl = [<span class=\"symbol\">NSURL</span> <span class=\"symbol\">URLWithString</span>:@<span class=\"string\">&quot;http://localhost:3000&quot;</span>];</span><br><span class=\"line\"><span class=\"symbol\">AFRKHTTPClient</span> *httpClient = [[<span class=\"symbol\">AFRKHTTPClient</span> alloc]initWithBaseURL:baseUrl];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"symbol\">RKObjectManager</span> *objectManager = [[<span class=\"symbol\">RKObjectManager</span> alloc]initWithHTTPClient:httpClient];</span><br><span class=\"line\">[objectManager setRequestSerializationMIMEType:<span class=\"symbol\">RKMIMETypeJSON</span>];</span><br><span class=\"line\">httpClient.allowsInvalidSSLCertificate = <span class=\"symbol\">YES</span>;</span><br></pre></td></tr></table></figure>\n<p>相应的一些 header 的关键信息，就可以添加到 httpClient 中，例如 <code>[httpClient setDefaultHeader:@&quot;Content-Encoding&quot; value:@&quot;gzip&quot;];</code>。</p>\n<h4 id=\"RKResponseDescriptor-设置\"><a href=\"#RKResponseDescriptor-设置\" class=\"headerlink\" title=\"RKResponseDescriptor 设置\"></a>RKResponseDescriptor 设置</h4><p>在发送请求之前，还需要的关键一步就是对返回 response 的处理，在这里设置对返回 json 的映射处理。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[ResultModel <span class=\"keyword\">class</span>]];</span><br><span class=\"line\">[mapping addAttributeMappingsFromDictionary:@<span class=\"comment\">&#123;@&quot;id&quot;:@&quot;identifier&quot;,@&quot;title&quot;:@&quot;title&quot;,@&quot;author&quot;:@&quot;author&quot;&#125;</span>];</span><br><span class=\"line\">NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful);</span><br><span class=\"line\">RKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">method</span>:</span>RKRequestMethodGET</span><br><span class=\"line\">pathPattern:<span class=\"keyword\">nil</span> </span><br><span class=\"line\">keyPath:<span class=\"keyword\">nil</span></span><br><span class=\"line\">statusCodes:statusCodes];</span><br><span class=\"line\">[objectManager addResponseDescriptor:responseDescriptor];</span><br></pre></td></tr></table></figure>\n<h4 id=\"发送参数访问\"><a href=\"#发送参数访问\" class=\"headerlink\" title=\"发送参数访问\"></a>发送参数访问</h4><p>最后一步就是想正确的路径发送参数进行访问了，很容易理解。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[RKObjectManager.sharedManager getObject:_manager path:@<span class=\"string\">&quot;posts/1&quot;</span></span><br><span class=\"line\">parameters:nil</span><br><span class=\"line\">success:^(<span class=\"name\">RKObjectRequestOperation</span> *operation, RKMappingResult *mappingResult) &#123;</span><br><span class=\"line\">truesuccessBlock(<span class=\"name\">mappingResult</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">&#125; failure:^(<span class=\"name\">RKObjectRequestOperation</span> *operation, NSError *error) &#123;</span><br><span class=\"line\">trueerrorBlock(<span class=\"name\">error</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;]<span class=\"comment\">;                                      </span></span><br></pre></td></tr></table></figure>\n<p>至此，一个基本的访问请求已经可以实现了。但是 RestKit 支持的功能还有很多没有使用到，最近公司也有个需求是要使请求发送 Gzip 数据，这就需要对 RestKit 进行一些拓展了，以后会详细说明。</p>\n<br>\n> [搭建 Restful 服务器](http://mclspace.com/2016/06/26/node-json-server/)\n> [RestKit ,一个用于更好支持RESTful风格服务器接口的iOS库](https://segmentfault.com/a/1190000003745207)","site":{"data":{}},"excerpt":"","more":"<p>最新需要使用 RestKit 框架处理网络请求，查了一下资料发现网上的资料确实不多，但还是有人翻译了一些资料的，趁此机会学习一下吧。</p>\n<!--- more --->\n<h4 id=\"服务器搭建\"><a href=\"#服务器搭建\" class=\"headerlink\" title=\"服务器搭建\"></a>服务器搭建</h4><p>使用 RestKit 框架，需要有一个支持 Restful 的网络接口，为了方便自己测试，我们可以自行搭建一个本地的 Restful 接口。方法不是很复杂可以参考 <a href=\"http://mclspace.com/2016/06/26/node-json-server/\">搭建 Restful 服务器</a>。搭建成功后访问本地 3000 端口，访问 <a href=\"http://localhost:3000/posts/1\">http://localhost:3000/posts/1</a> 可以获得返回 json。</p>\n<h4 id=\"RestKit-文档\"><a href=\"#RestKit-文档\" class=\"headerlink\" title=\"RestKit 文档\"></a>RestKit 文档</h4><p>关于使用 RestKit 的文章，可以参考<a href=\"https://segmentfault.com/a/1190000003745207\">这里</a>，十分详细我们可以参考这里的介绍来使用。</p>\n<h4 id=\"集成-RestKit\"><a href=\"#集成-RestKit\" class=\"headerlink\" title=\"集成 RestKit\"></a>集成 RestKit</h4><p>还是推荐使用 cocoapods 集成，方便管理。</p>\n<h4 id=\"创建解析-Model\"><a href=\"#创建解析-Model\" class=\"headerlink\" title=\"创建解析 Model\"></a>创建解析 Model</h4><p>RestKit 非常强大的功能就是能够对返回 json 进行映射处理。所以很多时候需要使用 <code>RKObjectMapping</code> 来管理映射对象。刚才已经成功搭建了自己的服务器，先访问一下看看 json 的格式，如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;title&quot;</span>: <span class=\"string\">&quot;json-server&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;author&quot;</span>: <span class=\"string\">&quot;typicode&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个 json 很容易理解，我们只需创建一个 ResultModel 的 class，来映射 json 即可，只需要在 .h 文件中声明 key。</p>\n<h4 id=\"URL-请求设置\"><a href=\"#URL-请求设置\" class=\"headerlink\" title=\"URL 请求设置\"></a>URL 请求设置</h4><p>在发送网络请求前，一定要明确的信息就是 URL，在使用 RestKit 前，就需要创建好 URL 的使用类。</p>\n<figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">NSURL</span> *baseUrl = [<span class=\"symbol\">NSURL</span> <span class=\"symbol\">URLWithString</span>:@<span class=\"string\">&quot;http://localhost:3000&quot;</span>];</span><br><span class=\"line\"><span class=\"symbol\">AFRKHTTPClient</span> *httpClient = [[<span class=\"symbol\">AFRKHTTPClient</span> alloc]initWithBaseURL:baseUrl];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"symbol\">RKObjectManager</span> *objectManager = [[<span class=\"symbol\">RKObjectManager</span> alloc]initWithHTTPClient:httpClient];</span><br><span class=\"line\">[objectManager setRequestSerializationMIMEType:<span class=\"symbol\">RKMIMETypeJSON</span>];</span><br><span class=\"line\">httpClient.allowsInvalidSSLCertificate = <span class=\"symbol\">YES</span>;</span><br></pre></td></tr></table></figure>\n<p>相应的一些 header 的关键信息，就可以添加到 httpClient 中，例如 <code>[httpClient setDefaultHeader:@&quot;Content-Encoding&quot; value:@&quot;gzip&quot;];</code>。</p>\n<h4 id=\"RKResponseDescriptor-设置\"><a href=\"#RKResponseDescriptor-设置\" class=\"headerlink\" title=\"RKResponseDescriptor 设置\"></a>RKResponseDescriptor 设置</h4><p>在发送请求之前，还需要的关键一步就是对返回 response 的处理，在这里设置对返回 json 的映射处理。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RKObjectMapping *mapping = [RKObjectMapping mappingForClass:[ResultModel <span class=\"keyword\">class</span>]];</span><br><span class=\"line\">[mapping addAttributeMappingsFromDictionary:@<span class=\"comment\">&#123;@&quot;id&quot;:@&quot;identifier&quot;,@&quot;title&quot;:@&quot;title&quot;,@&quot;author&quot;:@&quot;author&quot;&#125;</span>];</span><br><span class=\"line\">NSIndexSet *statusCodes = RKStatusCodeIndexSetForClass(RKStatusCodeClassSuccessful);</span><br><span class=\"line\">RKResponseDescriptor *responseDescriptor = [RKResponseDescriptor responseDescriptorWithMapping:mapping </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">method</span>:</span>RKRequestMethodGET</span><br><span class=\"line\">pathPattern:<span class=\"keyword\">nil</span> </span><br><span class=\"line\">keyPath:<span class=\"keyword\">nil</span></span><br><span class=\"line\">statusCodes:statusCodes];</span><br><span class=\"line\">[objectManager addResponseDescriptor:responseDescriptor];</span><br></pre></td></tr></table></figure>\n<h4 id=\"发送参数访问\"><a href=\"#发送参数访问\" class=\"headerlink\" title=\"发送参数访问\"></a>发送参数访问</h4><p>最后一步就是想正确的路径发送参数进行访问了，很容易理解。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[RKObjectManager.sharedManager getObject:_manager path:@<span class=\"string\">&quot;posts/1&quot;</span></span><br><span class=\"line\">parameters:nil</span><br><span class=\"line\">success:^(<span class=\"name\">RKObjectRequestOperation</span> *operation, RKMappingResult *mappingResult) &#123;</span><br><span class=\"line\">truesuccessBlock(<span class=\"name\">mappingResult</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">&#125; failure:^(<span class=\"name\">RKObjectRequestOperation</span> *operation, NSError *error) &#123;</span><br><span class=\"line\">trueerrorBlock(<span class=\"name\">error</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;]<span class=\"comment\">;                                      </span></span><br></pre></td></tr></table></figure>\n<p>至此，一个基本的访问请求已经可以实现了。但是 RestKit 支持的功能还有很多没有使用到，最近公司也有个需求是要使请求发送 Gzip 数据，这就需要对 RestKit 进行一些拓展了，以后会详细说明。</p>\n<br>\n> [搭建 Restful 服务器](http://mclspace.com/2016/06/26/node-json-server/)\n> [RestKit ,一个用于更好支持RESTful风格服务器接口的iOS库](https://segmentfault.com/a/1190000003745207)"},{"layout":"swift","title":"关于WKWebView和JS交互开发","date":"2017-11-03T01:18:58.000Z","_content":"在工作中使用到了 WKWebView 和 JS 交互开发的问题，在此留作笔记。\n<!--- more --->\n#### 引言\n关于 WKwebview 的优点就不多说了，苹果公司也推荐使用 WKWebView 来代替 UIWebView 作为网页浏览器开发。正好遇到的项目有这一部分需求，就直接使用了，也顺便学习一下，将遇到的问题记录下来。\n#### 设置WKWebView\n最简单的第一步还是需要引入头文件 `import WebKit`\n\n为了能与 JS 进行交互，需要对 WKWebView 进行设置\n\n\n```\n//创建配置\nlet config = WKWebViewConfiguration()\n// 创建UserContentController（提供JavaScript向webView发送消息的方法）\nlet userContent = WKUserContentController()\n// 添加消息处理，注意：self指代的对象需要遵守WKScriptMessageHandler协议，结束时需要移除\nuserContent.add(self, name: \"webViewApp\")\n// 将UserConttentController设置到配置文件\nconfig.userContentController = userContent\n\nlet frame = CGRect(x: 0, y: 0, width: SCREEN_WIDTH, height: SCREEN_HEIGHT - 64)\nwebView = WKWebView(frame: frame, configuration: config)\nwebView.uiDelegate = self           //WKUIDelegate\nwebView.navigationDelegate = self   //WKNavigationDelegate\n```\n注意，这里的 `userContent.add(self, name: \"webViewApp\")` 其中的 `webViewApp` 是与前端JS规定好的关键字，可以自行定义。\n\n至此，关于 WKWebView 的基本设置已经完成，我们需要实现相关的代理方法。\n#### 实现代理方法\n一些基本的代理就不做特殊说明了。\n##### WKNavigationDelegate\n之前一直使用旧的 webView 加载完成的代理方法，还奇怪怎么一直不生效。后来才发现 WKWebView 需要使用 `webView(_ webView: WKWebView, didFinish navigation: WKNavigation!)` 方法才行。加载失败的代理方法同理。\n##### WKScriptMessageHandler\n当 JS 调用 WKWebView 时需要 JS 实现 ```\nwindow.webkit.messageHandlers.webViewApp.postMessage(value);\n```\n其中 `webViewApp` 是我们在开始注册的关键字。\n\n为了接受 JS 调用必须实现这个协议和其中的代理方法 `userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage)`\n并且可以从 `message` 中获取由 JS 传递过来的 JSON 信息。\n`let dict = message.body as? Dictionary<String,String>`\n例：从dict中取值 `if let pageId = dict?[\"pageId\"] { K_CONFIGJSON.pageId = pageId }`\n后来发现用 SwiftyJson 框架处理 JSON 信息更容易些，我就换成了下面的处理方法:\n```\nlet dict = JSON(message.body)\nK_CONFIGJSON.pageId = dict[\"pageId\"].stringValue\n```\n在此方法中就可根据需求实现自定义方法。\n#### WKWebview 调用 JS 方法\n```\nDispatchQueue.main.async {\n\tlet email = K_USERMODEL.email\n\tlet password = K_USERMODEL.password\n \tself.webView.evaluateJavaScript(\"nativeCallBack('\\(email),\\(password)')\") { (item, error) in\n\t\tprint(item ?? \"没有返回\",error ?? \"没有错误\")\n\t}\n}\n```\n注意：这里调用 JS 方法一定要在主线程调用，不然有时会造成崩溃！！！\n最初我发现调用 JS 的方法如果添加了参数会导致方法失效，参数不能传递过去。通过查阅资料发现了可以通过前端更改代码来解决问题，参考资料在最后。\n\n#### 最后还有一点\n本来还想在 XCode 的调试窗口里显示出 JS 的 `console.log()` 信息，因为这个功能在 Android 上是自带的。但是发现还需要自己集成，太麻烦了。。。所以我就放弃了。不过发现了一篇关于这个的文章，就先放这里吧。\n<br>\n\n> 参考资料\n> [WK 与 JS 的那些事](http://www.jianshu.com/p/c9ceb6a824e2)\n> [实现 js 向 Swift 的传值](https://lvwenhan.com/ios/462.html)\n> [Swift-On-iOS](https://github.com/johnlui/Swift-On-iOS/tree/master/BuildYourOwnHybridDevelopmentFramework/BuildYourOwnHybridDevelopmentFramework)","source":"_posts/关于WKWevView和JS交互开发.md","raw":"---\nlayout: swift\ntitle: 关于WKWebView和JS交互开发\ndate: 2017-11-03 09:18:58\ntags:\n- Swift\ncategories:\n- Swift\n---\n在工作中使用到了 WKWebView 和 JS 交互开发的问题，在此留作笔记。\n<!--- more --->\n#### 引言\n关于 WKwebview 的优点就不多说了，苹果公司也推荐使用 WKWebView 来代替 UIWebView 作为网页浏览器开发。正好遇到的项目有这一部分需求，就直接使用了，也顺便学习一下，将遇到的问题记录下来。\n#### 设置WKWebView\n最简单的第一步还是需要引入头文件 `import WebKit`\n\n为了能与 JS 进行交互，需要对 WKWebView 进行设置\n\n\n```\n//创建配置\nlet config = WKWebViewConfiguration()\n// 创建UserContentController（提供JavaScript向webView发送消息的方法）\nlet userContent = WKUserContentController()\n// 添加消息处理，注意：self指代的对象需要遵守WKScriptMessageHandler协议，结束时需要移除\nuserContent.add(self, name: \"webViewApp\")\n// 将UserConttentController设置到配置文件\nconfig.userContentController = userContent\n\nlet frame = CGRect(x: 0, y: 0, width: SCREEN_WIDTH, height: SCREEN_HEIGHT - 64)\nwebView = WKWebView(frame: frame, configuration: config)\nwebView.uiDelegate = self           //WKUIDelegate\nwebView.navigationDelegate = self   //WKNavigationDelegate\n```\n注意，这里的 `userContent.add(self, name: \"webViewApp\")` 其中的 `webViewApp` 是与前端JS规定好的关键字，可以自行定义。\n\n至此，关于 WKWebView 的基本设置已经完成，我们需要实现相关的代理方法。\n#### 实现代理方法\n一些基本的代理就不做特殊说明了。\n##### WKNavigationDelegate\n之前一直使用旧的 webView 加载完成的代理方法，还奇怪怎么一直不生效。后来才发现 WKWebView 需要使用 `webView(_ webView: WKWebView, didFinish navigation: WKNavigation!)` 方法才行。加载失败的代理方法同理。\n##### WKScriptMessageHandler\n当 JS 调用 WKWebView 时需要 JS 实现 ```\nwindow.webkit.messageHandlers.webViewApp.postMessage(value);\n```\n其中 `webViewApp` 是我们在开始注册的关键字。\n\n为了接受 JS 调用必须实现这个协议和其中的代理方法 `userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage)`\n并且可以从 `message` 中获取由 JS 传递过来的 JSON 信息。\n`let dict = message.body as? Dictionary<String,String>`\n例：从dict中取值 `if let pageId = dict?[\"pageId\"] { K_CONFIGJSON.pageId = pageId }`\n后来发现用 SwiftyJson 框架处理 JSON 信息更容易些，我就换成了下面的处理方法:\n```\nlet dict = JSON(message.body)\nK_CONFIGJSON.pageId = dict[\"pageId\"].stringValue\n```\n在此方法中就可根据需求实现自定义方法。\n#### WKWebview 调用 JS 方法\n```\nDispatchQueue.main.async {\n\tlet email = K_USERMODEL.email\n\tlet password = K_USERMODEL.password\n \tself.webView.evaluateJavaScript(\"nativeCallBack('\\(email),\\(password)')\") { (item, error) in\n\t\tprint(item ?? \"没有返回\",error ?? \"没有错误\")\n\t}\n}\n```\n注意：这里调用 JS 方法一定要在主线程调用，不然有时会造成崩溃！！！\n最初我发现调用 JS 的方法如果添加了参数会导致方法失效，参数不能传递过去。通过查阅资料发现了可以通过前端更改代码来解决问题，参考资料在最后。\n\n#### 最后还有一点\n本来还想在 XCode 的调试窗口里显示出 JS 的 `console.log()` 信息，因为这个功能在 Android 上是自带的。但是发现还需要自己集成，太麻烦了。。。所以我就放弃了。不过发现了一篇关于这个的文章，就先放这里吧。\n<br>\n\n> 参考资料\n> [WK 与 JS 的那些事](http://www.jianshu.com/p/c9ceb6a824e2)\n> [实现 js 向 Swift 的传值](https://lvwenhan.com/ios/462.html)\n> [Swift-On-iOS](https://github.com/johnlui/Swift-On-iOS/tree/master/BuildYourOwnHybridDevelopmentFramework/BuildYourOwnHybridDevelopmentFramework)","slug":"关于WKWevView和JS交互开发","published":1,"updated":"2017-11-08T09:35:11.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyay001y7sn6h00wgncf","content":"<p>在工作中使用到了 WKWebView 和 JS 交互开发的问题，在此留作笔记。</p>\n<!--- more --->\n<h4 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h4><p>关于 WKwebview 的优点就不多说了，苹果公司也推荐使用 WKWebView 来代替 UIWebView 作为网页浏览器开发。正好遇到的项目有这一部分需求，就直接使用了，也顺便学习一下，将遇到的问题记录下来。</p>\n<h4 id=\"设置WKWebView\"><a href=\"#设置WKWebView\" class=\"headerlink\" title=\"设置WKWebView\"></a>设置WKWebView</h4><p>最简单的第一步还是需要引入头文件 <code>import WebKit</code></p>\n<p>为了能与 JS 进行交互，需要对 WKWebView 进行设置</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建配置</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> config = <span class=\"constructor\">WKWebViewConfiguration()</span></span><br><span class=\"line\"><span class=\"comment\">// 创建UserContentController（提供JavaScript向webView发送消息的方法）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> userContent = <span class=\"constructor\">WKUserContentController()</span></span><br><span class=\"line\"><span class=\"comment\">// 添加消息处理，注意：self指代的对象需要遵守WKScriptMessageHandler协议，结束时需要移除</span></span><br><span class=\"line\">userContent.add(self, name: <span class=\"string\">&quot;webViewApp&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 将UserConttentController设置到配置文件</span></span><br><span class=\"line\">config.userContentController = userContent</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> frame = <span class=\"constructor\">CGRect(<span class=\"params\">x</span>: 0, <span class=\"params\">y</span>: 0, <span class=\"params\">width</span>: SCREEN_WIDTH, <span class=\"params\">height</span>: SCREEN_HEIGHT - 64)</span></span><br><span class=\"line\">webView = <span class=\"constructor\">WKWebView(<span class=\"params\">frame</span>: <span class=\"params\">frame</span>, <span class=\"params\">configuration</span>: <span class=\"params\">config</span>)</span></span><br><span class=\"line\">webView.uiDelegate = self           <span class=\"comment\">//WKUIDelegate</span></span><br><span class=\"line\">webView.navigationDelegate = self   <span class=\"comment\">//WKNavigationDelegate</span></span><br></pre></td></tr></table></figure>\n<p>注意，这里的 <code>userContent.add(self, name: &quot;webViewApp&quot;)</code> 其中的 <code>webViewApp</code> 是与前端JS规定好的关键字，可以自行定义。</p>\n<p>至此，关于 WKWebView 的基本设置已经完成，我们需要实现相关的代理方法。</p>\n<h4 id=\"实现代理方法\"><a href=\"#实现代理方法\" class=\"headerlink\" title=\"实现代理方法\"></a>实现代理方法</h4><p>一些基本的代理就不做特殊说明了。</p>\n<h5 id=\"WKNavigationDelegate\"><a href=\"#WKNavigationDelegate\" class=\"headerlink\" title=\"WKNavigationDelegate\"></a>WKNavigationDelegate</h5><p>之前一直使用旧的 webView 加载完成的代理方法，还奇怪怎么一直不生效。后来才发现 WKWebView 需要使用 <code>webView(_ webView: WKWebView, didFinish navigation: WKNavigation!)</code> 方法才行。加载失败的代理方法同理。</p>\n<h5 id=\"WKScriptMessageHandler\"><a href=\"#WKScriptMessageHandler\" class=\"headerlink\" title=\"WKScriptMessageHandler\"></a>WKScriptMessageHandler</h5><p>当 JS 调用 WKWebView 时需要 JS 实现 ```<br>window.webkit.messageHandlers.webViewApp.postMessage(value);</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中 `webViewApp` 是我们在开始注册的关键字。</span><br><span class=\"line\"></span><br><span class=\"line\">为了接受 <span class=\"keyword\">JS </span>调用必须实现这个协议和其中的代理方法 `userContentController(_ userContentController: WKUserContentController, <span class=\"keyword\">didReceive </span>message: WKScriptMessage)`</span><br><span class=\"line\">并且可以从 `message` 中获取由 <span class=\"keyword\">JS </span>传递过来的 <span class=\"keyword\">JSON </span>信息。</span><br><span class=\"line\">`let <span class=\"keyword\">dict </span>= message.<span class=\"keyword\">body </span>as? <span class=\"keyword\">Dictionary&lt;String,String&gt;`</span></span><br><span class=\"line\"><span class=\"keyword\"></span>例：从<span class=\"keyword\">dict中取值 </span>`if let pageId = <span class=\"keyword\">dict?[&quot;pageId&quot;] </span>&#123; K_CONFIGJSON.pageId = pageId &#125;`</span><br><span class=\"line\">后来发现用 <span class=\"keyword\">SwiftyJson </span>框架处理 <span class=\"keyword\">JSON </span>信息更容易些，我就换成了下面的处理方法:</span><br></pre></td></tr></table></figure>\n<p>let dict = JSON(message.body)<br>K_CONFIGJSON.pageId = dict[“pageId”].stringValue</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在此方法中就可根据需求实现自定义方法。</span><br><span class=\"line\">#### WKWebview 调用 JS 方法</span><br></pre></td></tr></table></figure>\n<p>DispatchQueue.main.async {<br>    let email = K_USERMODEL.email<br>    let password = K_USERMODEL.password<br>     self.webView.evaluateJavaScript(“nativeCallBack(‘(email),(password)’)”) { (item, error) in<br>        print(item ?? “没有返回”,error ?? “没有错误”)<br>    }<br>}</p>\n<p>```<br>注意：这里调用 JS 方法一定要在主线程调用，不然有时会造成崩溃！！！<br>最初我发现调用 JS 的方法如果添加了参数会导致方法失效，参数不能传递过去。通过查阅资料发现了可以通过前端更改代码来解决问题，参考资料在最后。</p>\n<h4 id=\"最后还有一点\"><a href=\"#最后还有一点\" class=\"headerlink\" title=\"最后还有一点\"></a>最后还有一点</h4><p>本来还想在 XCode 的调试窗口里显示出 JS 的 <code>console.log()</code> 信息，因为这个功能在 Android 上是自带的。但是发现还需要自己集成，太麻烦了。。。所以我就放弃了。不过发现了一篇关于这个的文章，就先放这里吧。<br><br></p>\n<blockquote>\n<p>参考资料<br><a href=\"http://www.jianshu.com/p/c9ceb6a824e2\">WK 与 JS 的那些事</a><br><a href=\"https://lvwenhan.com/ios/462.html\">实现 js 向 Swift 的传值</a><br><a href=\"https://github.com/johnlui/Swift-On-iOS/tree/master/BuildYourOwnHybridDevelopmentFramework/BuildYourOwnHybridDevelopmentFramework\">Swift-On-iOS</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>在工作中使用到了 WKWebView 和 JS 交互开发的问题，在此留作笔记。</p>\n<!--- more --->\n<h4 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h4><p>关于 WKwebview 的优点就不多说了，苹果公司也推荐使用 WKWebView 来代替 UIWebView 作为网页浏览器开发。正好遇到的项目有这一部分需求，就直接使用了，也顺便学习一下，将遇到的问题记录下来。</p>\n<h4 id=\"设置WKWebView\"><a href=\"#设置WKWebView\" class=\"headerlink\" title=\"设置WKWebView\"></a>设置WKWebView</h4><p>最简单的第一步还是需要引入头文件 <code>import WebKit</code></p>\n<p>为了能与 JS 进行交互，需要对 WKWebView 进行设置</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建配置</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> config = <span class=\"constructor\">WKWebViewConfiguration()</span></span><br><span class=\"line\"><span class=\"comment\">// 创建UserContentController（提供JavaScript向webView发送消息的方法）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> userContent = <span class=\"constructor\">WKUserContentController()</span></span><br><span class=\"line\"><span class=\"comment\">// 添加消息处理，注意：self指代的对象需要遵守WKScriptMessageHandler协议，结束时需要移除</span></span><br><span class=\"line\">userContent.add(self, name: <span class=\"string\">&quot;webViewApp&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 将UserConttentController设置到配置文件</span></span><br><span class=\"line\">config.userContentController = userContent</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> frame = <span class=\"constructor\">CGRect(<span class=\"params\">x</span>: 0, <span class=\"params\">y</span>: 0, <span class=\"params\">width</span>: SCREEN_WIDTH, <span class=\"params\">height</span>: SCREEN_HEIGHT - 64)</span></span><br><span class=\"line\">webView = <span class=\"constructor\">WKWebView(<span class=\"params\">frame</span>: <span class=\"params\">frame</span>, <span class=\"params\">configuration</span>: <span class=\"params\">config</span>)</span></span><br><span class=\"line\">webView.uiDelegate = self           <span class=\"comment\">//WKUIDelegate</span></span><br><span class=\"line\">webView.navigationDelegate = self   <span class=\"comment\">//WKNavigationDelegate</span></span><br></pre></td></tr></table></figure>\n<p>注意，这里的 <code>userContent.add(self, name: &quot;webViewApp&quot;)</code> 其中的 <code>webViewApp</code> 是与前端JS规定好的关键字，可以自行定义。</p>\n<p>至此，关于 WKWebView 的基本设置已经完成，我们需要实现相关的代理方法。</p>\n<h4 id=\"实现代理方法\"><a href=\"#实现代理方法\" class=\"headerlink\" title=\"实现代理方法\"></a>实现代理方法</h4><p>一些基本的代理就不做特殊说明了。</p>\n<h5 id=\"WKNavigationDelegate\"><a href=\"#WKNavigationDelegate\" class=\"headerlink\" title=\"WKNavigationDelegate\"></a>WKNavigationDelegate</h5><p>之前一直使用旧的 webView 加载完成的代理方法，还奇怪怎么一直不生效。后来才发现 WKWebView 需要使用 <code>webView(_ webView: WKWebView, didFinish navigation: WKNavigation!)</code> 方法才行。加载失败的代理方法同理。</p>\n<h5 id=\"WKScriptMessageHandler\"><a href=\"#WKScriptMessageHandler\" class=\"headerlink\" title=\"WKScriptMessageHandler\"></a>WKScriptMessageHandler</h5><p>当 JS 调用 WKWebView 时需要 JS 实现 ```<br>window.webkit.messageHandlers.webViewApp.postMessage(value);</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中 `webViewApp` 是我们在开始注册的关键字。</span><br><span class=\"line\"></span><br><span class=\"line\">为了接受 <span class=\"keyword\">JS </span>调用必须实现这个协议和其中的代理方法 `userContentController(_ userContentController: WKUserContentController, <span class=\"keyword\">didReceive </span>message: WKScriptMessage)`</span><br><span class=\"line\">并且可以从 `message` 中获取由 <span class=\"keyword\">JS </span>传递过来的 <span class=\"keyword\">JSON </span>信息。</span><br><span class=\"line\">`let <span class=\"keyword\">dict </span>= message.<span class=\"keyword\">body </span>as? <span class=\"keyword\">Dictionary&lt;String,String&gt;`</span></span><br><span class=\"line\"><span class=\"keyword\"></span>例：从<span class=\"keyword\">dict中取值 </span>`if let pageId = <span class=\"keyword\">dict?[&quot;pageId&quot;] </span>&#123; K_CONFIGJSON.pageId = pageId &#125;`</span><br><span class=\"line\">后来发现用 <span class=\"keyword\">SwiftyJson </span>框架处理 <span class=\"keyword\">JSON </span>信息更容易些，我就换成了下面的处理方法:</span><br></pre></td></tr></table></figure>\n<p>let dict = JSON(message.body)<br>K_CONFIGJSON.pageId = dict[“pageId”].stringValue</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在此方法中就可根据需求实现自定义方法。</span><br><span class=\"line\">#### WKWebview 调用 JS 方法</span><br></pre></td></tr></table></figure>\n<p>DispatchQueue.main.async {<br>    let email = K_USERMODEL.email<br>    let password = K_USERMODEL.password<br>     self.webView.evaluateJavaScript(“nativeCallBack(‘(email),(password)’)”) { (item, error) in<br>        print(item ?? “没有返回”,error ?? “没有错误”)<br>    }<br>}</p>\n<p>```<br>注意：这里调用 JS 方法一定要在主线程调用，不然有时会造成崩溃！！！<br>最初我发现调用 JS 的方法如果添加了参数会导致方法失效，参数不能传递过去。通过查阅资料发现了可以通过前端更改代码来解决问题，参考资料在最后。</p>\n<h4 id=\"最后还有一点\"><a href=\"#最后还有一点\" class=\"headerlink\" title=\"最后还有一点\"></a>最后还有一点</h4><p>本来还想在 XCode 的调试窗口里显示出 JS 的 <code>console.log()</code> 信息，因为这个功能在 Android 上是自带的。但是发现还需要自己集成，太麻烦了。。。所以我就放弃了。不过发现了一篇关于这个的文章，就先放这里吧。<br><br></p>\n<blockquote>\n<p>参考资料<br><a href=\"http://www.jianshu.com/p/c9ceb6a824e2\">WK 与 JS 的那些事</a><br><a href=\"https://lvwenhan.com/ios/462.html\">实现 js 向 Swift 的传值</a><br><a href=\"https://github.com/johnlui/Swift-On-iOS/tree/master/BuildYourOwnHybridDevelopmentFramework/BuildYourOwnHybridDevelopmentFramework\">Swift-On-iOS</a></p>\n</blockquote>\n"},{"layout":"swift","title":"回顾Swift设计模式","date":"2017-11-07T02:22:22.000Z","_content":"《Swift 设计模式》已经看过一遍了，不过大多时候也是看完就忘记了，这里重新再看一遍并记录一下。\n<!--- more --->\n#### 对象模板模式\n> 其实这个设计模式就是我们通常概念的 <font color=#d13f28>**面向对象**</font> 编程。使用 **类** 或者 **结构体** 作为数据类型及其逻辑的规范。创建对象时使用 **模板**，并在初始化是完成数据赋值。赋值时，要么使用模板中的 **默认值**，要么使用类或者结构体的 **构造器** 提供数值。\n  \n技巧：有时候可以通过添加计算属性来保护不希望被随意修改的属性\n```\nprivate var inValue = 0\n  var outValue: Int {\n      get {\n          return inValue\n      }\n      set {\n          inValue = max(0, newValue)\n      }\n  }\n  \nproClass.outValue = 10  // 10\nproClass.outValue = -10 // 0\n```\n#### 原型模式\n\n> 原型模式通过克隆已有的对象来创建新的对象，已有的对象即为原型\n\n组件若想通过模板创建新的对象，必须掌握以下三个信息。\n- 与所需创建的对象相关的模板\n- 必须调用的初始化器\n- 初始化器的参数名称和类型\n\n> 将一个值赋给变量时，Swift会自动使用原型模式。值类型是使用结构体定义，而且所有Swift内置类型的底层都是用结构图实现。\n\n换句话说: Swift 只会为 <font color=#d13f28>**值类型(结构体)**</font> 创建默认的<font color=#d13f28>**初始化器**</font>。而**不会**为 <font color=#d13f28>**引用类型(类)**</font> 创建<font color=#d13f28>**初始化器**</font>。这就会导致创建完原型对象后，之后再创建任意多个同类对象，使用 **结构体** 模板创建的对象不会带来内存开销问题，而使用 **类** 模板创建的对象会有内存指向的问题。(2个变量会指向同一个对象。)\n为了解决这个问题可以实现 NSCopying 协议，来支持克隆对象，实现深复制。\n```\nclass Appointment: NSObject, NSCopying {\n\tvar name: String\n\tvar day: String\n\tinit(name: String, day: String) {\n\t\tself.name = name\n\t\tself.day  = day\n\t}\n\t// 在实现\n\tfunc copy(with zone: NSZone? = nil) -> Any {\n        return AppointmentClass(name: self.name, day: self.day)\n    }\n}\nvar b1 = Appointment(name: \"Bob\",day: \"1\")\nvar w1 = b1.copy() as! Appointment\nw1.name = \"Ali\"\nw1.day  = \"2\"\n// 此时使用 copy() 创建的 w1 此时就不会对 b1 产生印象\n```\nTips: 只有类才可以实现 NSCopying 协议，结构体不可以。因为结构体本身实现了深复制。\n\n#### 单例模式\n> 单例模式能够确保某个类型的对象在应用中只存一个实例。\n\n创建单例模式可以像 Objective-C 一样创建一个单线程进行初始化。但是在 Swift 有更好的方法。\n```\nfinal class Single: NSObject {\n    public static let shared = Single()\n    private override init() {}\n    \n    var title: String = \"\"\n    var number: Int = 0\n}\n```\nTips:这里遇到一个问题，如果创建单例模式的类不引用 NSOject 继承的话，就会报错。\n问题找到了，由于在 `init()` 方法引用了关键字 `override` 导致了单例类一定要继承 NSObject 才有 `init()` 方法，所以编译器报错，去掉 `override` 就可以了。\n##### 并发处理\n如果在多线程应用中使用单例，那就需要仔细考虑一个问题：当有不同的组件同时操作单例对象时，会产生哪些后果。\nTips: Swift 数组并不是线程安全的。也就是说两个或更多线程同时调用数组的 `append` 方法，会同一个数组进行操作，会破坏数据的结构。\n> 注意：高效的并发编程需要谨慎的思考和丰富的经验。有时初衷也许是很好的，但是最终开发出来的应用可能会很慢，甚至出现卡死的现象。\n\n操作 Swift 数组的内容不是一个线程安全的操作，单例对象在使用数组时需要并发保护。为了解决这个问题，可以使用 <font color=d13f28>**串行访问**</font> 确保同一时刻只允许一个 block 调用数组的 `append` 方法。\n```\nfinal class Single: NSObject {\n    // 创建出一个线程用来对数组进行操作\n    let array = [String]()\n    private let arrayQ = DispatchQueue(label: \"arrayQ\")\n    // 创建出一个方法专门对 array 进行操作\n    func backup(item: String) {\n        arrayQ.sync { self.array.append(item) }\n    }\n}    \n```\nTips: Swift 3 以后使用这种方式调用 `dipatch_barrier`\n\n```\nlet wirte = DispatchWorkItem(flags: .barrier) { \n    // write data\n}\nlet dataQueue = DispatchQueue(label: \"data\", attributes: .concurrent)\ndataQueue.async(execute: wirte)\n```\n#### 对象池模式\n> 对象池模式是单例模式的一种变体，它可以为组件提供多个完全相同的对象，而非单个对象。对象池模式一般来管理一组可重用的对象，\n \n 此模式解决的问题：需要限制某个类型对象的数量，但允许多个个对象的存在。例如图书管理系统，需要管理某本书，但是又是多本存在。常见情况:UITableviewCell 的重用\n\n利用范式创造一个对象池\n\n```\nclass Pool<T> {\n    private var data = [T]()\n    private let arrayQ = DispatchQueue(label: \"arrayQ\")\n    ///创建GCD信号源\n    private let semaphore: DispatchSemaphore\n    \n    init(items:[T]) {\n        data.reserveCapacity(data.count)\n        semaphore = DispatchSemaphore(value: items.count)\n\n        items.forEach{\n            data.append($0)\n        }\n    }\n    \n    func getFromPool() -> T? {\n        var result: T?\n        if semaphore.wait(timeout: .distantFuture) == .success {\n            arrayQ.sync {\n                result = self.data.remove(at: 0)\n            }\n        }\n        return result\n    }\n    \n    func returnToPool(item: T) {\n        arrayQ.sync {\n            self.data.append(item)\n            semaphore.signal()\n        }\n    }\n}\n```\n> 注释: reserveCapacity 这个方法非常有趣。数组类型的元素并不一定需要是连续的（除非你使用 ContiguousArray），但是它们大部分都是连续的。正因如此，我们常常分配一段内存空间，用来存储我们的数组——特别是当我们知道数组的大致大小时。例如，`map()` 方法总是会返回和调用该方法的序列一样大小的一个数组。所以，`map()` 方法在填充数组之前，应该会使用 `reserveCapacity`。这一点可能不容易理解。`map()` 作用于 SequenceType 类型，不仅仅是 CollectionType 类型。Sequence 类型并没有 count 属性——那么如何才能得到序列的长度呢？即使它有 count 属性，CollectionType 类型的该属性，应该返回 Index.Distance，而对于 `reserveCapacity` 来说，需要一个 Int 类型。\n\n##### 使用信号量解决并发问题\n创建一个信号量 `private let semaphore: DispatchSemaphore` 并且在初始化的时候初始化它。\n\n```\nclass Pool<T> {\n\tinit(items: [T]) {\n\t\t// 为信号源创建一个计数器\n\t\tsemaphore = DispatchSemaphore(value: items.count)\n\t}\n\tfunc getFromPool() -> T? {\n\t\t// 每次调用 semaphore.wait 都会使计数器的值减一 \n\t\tif semaphore.wait(timeout: .distantFuture) == .success {\n\t\t\t//确保在分线程执行操作 如果再主线程操作 整个 APP 就会冻住\n\t\t\tarrayQ.sync {\n\t\t\t}\n\t\t}\n\t}\n\tfunc returnToPool(item: T) {\n\t\tarrayQ.sync {\n\t\t\t//\n\t\t\tsemaphore.singal()\n\t\t}\n\t}\n}\n```\n\n#### 工厂方法模式\n> 工厂方法模式通过选取相关的实现类来满足调用组件的请求，调用组件无需了解这些实现类的细节以及它们之间的关系。当存在多个类共同实现一个协议或者共同继承一个基类时，就可以使用工厂方法模式。\n\n实现工厂方法模式最简单的方式是定义一个全局函数。由于全局函数可以在整个应用内调用，因此调用组件可以方便地定位和调用全局函数。\n\n```\nfunc createRentalCar(passengers: Int) -> RentalCar? {\n    var car: RentalCar?\n    switch passengers {\n    case 0...1:\n        car = Sports()\n    case 2...3:\n        car = Compact()\n    case 4...8:\n        car = SUV()\n    default:\n        car = nil\n    }\n    return car\n}\n```\n\n创建通用协议，使创建的工厂类遵循同一个协议。\n\n```\nprotocol RentalCar {\n    var name: String { get }\n    var passengers: Int { get }\n    var pricePerDay: Float { get }\n}\n\nclass Compact: RentalCar {\n    var name = \"Golf\"\n    var passengers = 3\n    var pricePerDay: Float = 20\n}\n\nclass Sports: RentalCar {\n    var name = \"Sport\"\n    var passengers = 1\n    var pricePerDay: Float = 100\n}\n\nclass SUV: RentalCar {\n    var name = \"SUV\"\n    var passengers = 8\n    var pricePerDay: Float = 75\n}\n```\n\n最后，就能够在类中调用工厂方法创建对象，而不需要了解对象的详细情况。\n\n```\nclass CarSelector {\n    class func selectCar(passengers: Int) -> String? {\n        return createRentalCar(passengers: passengers)?.name\n   }\n}\n```\n\n#### 建造者模式\n> 使用建造者模式可以将创建对象所需的逻辑和默认配置值放入一个建造者类中，这样调用组件只需了解少量配置数据即可创建对象，并且无需了解创建对象所需的默认数据值。\n\n建造者模式实际上在开发中很常用，是指很多时候都没有意识到自己已经使用了建造者模式。说白了就是在创建对象方法和创建对象之间添加了一个中间层。只需在创建对象的时候添加修改的参数，而中间层添加默认参数，从而创建出对象。Swift 中已经很好的能够通过给方法参数添加默认值来实现初始化方法。所以可以很轻松的使用建造者模式。例如：`init(name: String, age: Int = 24, sex: Bool = true)`。\n\n#### 适配器模式\n> 适配器模式通过引入适配器对两个组件进行适配的方式，可以让两个 API 不兼容的组件写作。\n\n适配器模式通过对不同类的 API 进行适配，将应用使用的 API 映射到组件提供的 API 方式，使得两个不兼容的类可以相互协作。\n \n实现适配器模式最优雅的方式是使用 Swift extension。使用 extension 可以为无法修改源码的类增加功能。\n\n其实适配模式的精髓就是让不同的类都**遵循相同的协议**。让不同的类实现好同一个方法\n\n#### 桥接模式\n> 桥接模式通过分离应用的抽象部分与实现部分，使得他们可以独立的变化。为了更高的解决层级爆炸的问题,分离应用的抽象部分与实现部分,使他们可以独立的变化.\n\n从表面上看,桥接模式与适配器模式甚是相似。毕竟桥接模式的功能就是充当依赖某个协议的类与另外协议之间的适配器。虽然桥接模式和适配器模式相似，但是它们的应用场景并不相同。当需要集成无法修改源码的组件时(比如第三方组件),可以使用适配器模式。当你能够修改组件源代码及其运行方式时，便可使用桥接模式。使用桥接模式不只是创建一个桥接类这么简单，还需要最组件代码进行重构，以分离通用的代码和平台相关代码。\n\n假定现在有2个不同的协议，且协议拥有各自的实现方法。\n\n```\nprotocol ClearMessageChannel {\n    func send(message: String)\n}\n\nprotocol SecureMessageChannel {\n   func sendEncryptedMessage(encryptedText: String)\n}\n```\n现在需要通过一个类来实现这2个协议的方法，就需要通过桥接的方式来实现。\n创建一个桥接的类，类中属性遵守不同的协议，并为属性创建协议能够调用的方法\n\n```\nclass Communicator {\n    private let clearChannel: ClearMessageChannel\n    private let secureChannel: SecureMessageChannel\n    private let priorityChannel: PriorityMessageChannel\n\n    init(clearChannel: ClearMessageChannel, secureChannel: SecureMessageChannel ) {\n        self.secureChannel = secureChannel\n        self.clearChannel = clearChannel\n    }\n\n    func sendCleartextMessage(mesage: String) {\n        self.clearChannel.send(message: mesage)\n    }\n\n    func sendSecureMessage(message: String) {\n        self.secureChannel.sendEncryptedMessage(encryptedText: message)\n    }\n}\n```\n接下里，需要创建出不同的类来遵循上述协议并实现协议方法\n\n```\nclass Landline: ClearMessageChannel {\n    func send(message: String) {\n        print(\"Landline\",message)\n    }\n}\n\nclass SecureLandLine: SecureMessageChannel {\n    func sendEncryptedMessage(encryptedText: String) {\n            print(\"Secure\", encryptedText)\n    }\n}\n```\n最后,通过就能够通过创建桥接对象来实现协议方法。\n\n```\nvar comms = Communicator(clearChannel: Landline(), secureChannel: SecureLandLine())\n\ncomms.sendCleartextMessage(mesage: \"CLEAR\")\ncomms.sendSecureMessage(message: \"Sercure\")\n```\n\n#### 装饰器模式\n\n> 此模式在处理无法修改的类时能发挥强大的功能。可以在不修改对象所属的类或对象的使用者情况下，修改单个对象的行为。\n\n为了实现装饰器模式，需要继承那个无法修改的类，以创建一个拥有该类所有方法和属性的类，这样才可以实现无缝替换原来的那个类。但是 **Swift 不建议使用继承**。尽量还是避免使用这种模式。\n\n#### 组合模式\n\n> 组合模式能够将对象以树形结构组织起来，使得外界对单个对象和组合对象的使用具有一致性。\n\n组合模式的实现主要是通过让不同的 类 都**遵循统一的协议**，这样就能够实现一个管理类统一处理不同对象。\n![](https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.jpg?raw=true)\n\n#### 外观模式\n\n> 外观模式可以简化复杂的常见任务 API的使用\n\n#### 享元模式\n\n> 享元模式可以在多个调用组件之间共享数据\n \n享元模式不会修改外部数据，也不允许调用组件修改外部数据。这是享元模式非常重要的特征，允许对外部数据进行修改也是人们在实现享元模式时常犯的一个错误。\n\n#### 代理模式\n\n> 代理模式的核心是一个对象--代理对象，此对象可以用于代表其他资源，此对象可以用于代表其他资源。\n\n#### 责任链模式\n\n> 责任链模式负责组织管理一序列能够对调用组件的请求做出响应的对象。这里所说的对象序列被称为责任链，责任链中的每个对象都可能被用于处理某个请求。请求在这个链上传递，知道链上的某一个对象处理此请求，或者到达链的尾部。\n \n当多个对象可以响应一个请求，而又不想将这些对象的细节暴露给调用组件时，便可以使用责任链模式。下面举例说明一下责任链模式。\n创建一种消息类型 Message，包括发送者、接收者和消息内容:\n\n```\nstruct Message {\n    let from: String\n    let to:   String\n    let subject: String\n}\n```\n\n现在需要创建一条责任链，作用是处理 Message，判断这条消息是内部消息(from 和 to 的邮箱是同一个)、外部消息(from 和 to 不是同一个邮箱)还是私密消息(subject 的内容是 Priority 开头)。\n\n```\nclass Transmitter {\n    var nextLinke: Transmitter?\n    \n    required init() { }\n    \n    func sendMessage(_ message: Message) {\n        if (nextLinke != nil) {\n            nextLinke?.sendMessage(message)\n        } else {\n            print(\"责任链到达底端，消息不再发送。\")\n        }\n    }\n    \n    class func matchEmailSuffix(message: Message) -> Bool {\n        // 判断收和发的邮箱是否是同一个\n        if let index = message.from.index(of: \"@\"){\n            let sub = String(message.from[index...])\n            return message.to.hasSuffix(sub)\n        }\n        return false\n    }\n    // 创建一条责任链\n    class func createChain() -> Transmitter? {\n        let transmitterClasses: [Transmitter.Type] = [\n            PriorityTransmitter.self,\n            LocalTransmitter.self,\n            RemoteTransmitter.self]\n        \n        var link: Transmitter?\n        \n        transmitterClasses.reversed().forEach {\n            let existingLink = link\n            link = $0.init()\n            link?.nextLinke =  existingLink\n        }\n        return link\n    }\n}\n```\n\n接下来就需要将责任链中不同的责任类进行实现，他们都需要集成责任链的类，并重写 sendMessage 的方法，然后在 sendMessage 的方法中分别实现自己的需求。\n\n```\nclass LocalTransmitter: Transmitter {\n    override func sendMessage(_ message: Message)  {\n        if (Transmitter.matchEmailSuffix(message: message)) {\n            print(\"\\(message.from) 发送的内部消息\")\n        } else {\n            super.sendMessage(message)\n        }\n    }\n}\n\nclass RemoteTransmitter: Transmitter {\n    override func sendMessage(_ message: Message) {\n        if (!Transmitter.matchEmailSuffix(message: message)) {\n            print(\"\\(message.from) 发送外部消息\")\n        } else {\n            super.sendMessage(message)\n        }\n    }\n}\n\nclass PriorityTransmitter: Transmitter {\n    override func sendMessage(_ message: Message) {\n        if (message.subject.hasPrefix(\"Priority\")) {\n            print(\"\\(message.from) 发送 私人消息\")\n        } else {\n            super.sendMessage(message)\n        }\n    }\n}\n```\n\n最后在创建的责任链中注意实现 sendMessage 方法:\n\n```\nlet message = [Message(from: \"bob@163.com\", to: \"joe@qq.com\", subject: \"午饭吃啥？\"),\n               Message(from: \"joe@qq.com\", to: \"ali@qq.com\", subject: \"你吃啥？\"),\n               Message(from: \"pet@2\", to: \"all@2\", subject: \"Priority: 这是私密消息！\")]\n\nif let chain = Transmitter.createChain()  {\n    message.forEach {\n        chain.sendMessage($0)\n    }\n}\n// bob@163.com 发送外部消息\n// joe@qq.com 发送的内部消息\n// pet@2 发送 私人消息\n```\n\n#### 命令模式\n> 命令模式提供了一种封装方法调用的机制，基于这种机制我们可以实现延迟方法调用或替换调用该方法的组用。命令模式的核心是 **命令对象**。在其内部实现中，接受对象持有一个命令 **接收者对象** 的引用，并知道如何调用接收者的相关方法。接收者和调用指令是命令私有的，不应允许使用命令的调用组件去访问。命令对象唯一的可供公开访问的是 execution 方法。当调用组件需要执行相关命令时，直接调用 execution 即可。\n","source":"_posts/回顾Swift设计模式.md","raw":"---\nlayout: swift\ntitle: 回顾Swift设计模式\ndate: 2017-11-07 10:22:22\ntags: \n- Swift\ncategories: \n- Swift\n---\n《Swift 设计模式》已经看过一遍了，不过大多时候也是看完就忘记了，这里重新再看一遍并记录一下。\n<!--- more --->\n#### 对象模板模式\n> 其实这个设计模式就是我们通常概念的 <font color=#d13f28>**面向对象**</font> 编程。使用 **类** 或者 **结构体** 作为数据类型及其逻辑的规范。创建对象时使用 **模板**，并在初始化是完成数据赋值。赋值时，要么使用模板中的 **默认值**，要么使用类或者结构体的 **构造器** 提供数值。\n  \n技巧：有时候可以通过添加计算属性来保护不希望被随意修改的属性\n```\nprivate var inValue = 0\n  var outValue: Int {\n      get {\n          return inValue\n      }\n      set {\n          inValue = max(0, newValue)\n      }\n  }\n  \nproClass.outValue = 10  // 10\nproClass.outValue = -10 // 0\n```\n#### 原型模式\n\n> 原型模式通过克隆已有的对象来创建新的对象，已有的对象即为原型\n\n组件若想通过模板创建新的对象，必须掌握以下三个信息。\n- 与所需创建的对象相关的模板\n- 必须调用的初始化器\n- 初始化器的参数名称和类型\n\n> 将一个值赋给变量时，Swift会自动使用原型模式。值类型是使用结构体定义，而且所有Swift内置类型的底层都是用结构图实现。\n\n换句话说: Swift 只会为 <font color=#d13f28>**值类型(结构体)**</font> 创建默认的<font color=#d13f28>**初始化器**</font>。而**不会**为 <font color=#d13f28>**引用类型(类)**</font> 创建<font color=#d13f28>**初始化器**</font>。这就会导致创建完原型对象后，之后再创建任意多个同类对象，使用 **结构体** 模板创建的对象不会带来内存开销问题，而使用 **类** 模板创建的对象会有内存指向的问题。(2个变量会指向同一个对象。)\n为了解决这个问题可以实现 NSCopying 协议，来支持克隆对象，实现深复制。\n```\nclass Appointment: NSObject, NSCopying {\n\tvar name: String\n\tvar day: String\n\tinit(name: String, day: String) {\n\t\tself.name = name\n\t\tself.day  = day\n\t}\n\t// 在实现\n\tfunc copy(with zone: NSZone? = nil) -> Any {\n        return AppointmentClass(name: self.name, day: self.day)\n    }\n}\nvar b1 = Appointment(name: \"Bob\",day: \"1\")\nvar w1 = b1.copy() as! Appointment\nw1.name = \"Ali\"\nw1.day  = \"2\"\n// 此时使用 copy() 创建的 w1 此时就不会对 b1 产生印象\n```\nTips: 只有类才可以实现 NSCopying 协议，结构体不可以。因为结构体本身实现了深复制。\n\n#### 单例模式\n> 单例模式能够确保某个类型的对象在应用中只存一个实例。\n\n创建单例模式可以像 Objective-C 一样创建一个单线程进行初始化。但是在 Swift 有更好的方法。\n```\nfinal class Single: NSObject {\n    public static let shared = Single()\n    private override init() {}\n    \n    var title: String = \"\"\n    var number: Int = 0\n}\n```\nTips:这里遇到一个问题，如果创建单例模式的类不引用 NSOject 继承的话，就会报错。\n问题找到了，由于在 `init()` 方法引用了关键字 `override` 导致了单例类一定要继承 NSObject 才有 `init()` 方法，所以编译器报错，去掉 `override` 就可以了。\n##### 并发处理\n如果在多线程应用中使用单例，那就需要仔细考虑一个问题：当有不同的组件同时操作单例对象时，会产生哪些后果。\nTips: Swift 数组并不是线程安全的。也就是说两个或更多线程同时调用数组的 `append` 方法，会同一个数组进行操作，会破坏数据的结构。\n> 注意：高效的并发编程需要谨慎的思考和丰富的经验。有时初衷也许是很好的，但是最终开发出来的应用可能会很慢，甚至出现卡死的现象。\n\n操作 Swift 数组的内容不是一个线程安全的操作，单例对象在使用数组时需要并发保护。为了解决这个问题，可以使用 <font color=d13f28>**串行访问**</font> 确保同一时刻只允许一个 block 调用数组的 `append` 方法。\n```\nfinal class Single: NSObject {\n    // 创建出一个线程用来对数组进行操作\n    let array = [String]()\n    private let arrayQ = DispatchQueue(label: \"arrayQ\")\n    // 创建出一个方法专门对 array 进行操作\n    func backup(item: String) {\n        arrayQ.sync { self.array.append(item) }\n    }\n}    \n```\nTips: Swift 3 以后使用这种方式调用 `dipatch_barrier`\n\n```\nlet wirte = DispatchWorkItem(flags: .barrier) { \n    // write data\n}\nlet dataQueue = DispatchQueue(label: \"data\", attributes: .concurrent)\ndataQueue.async(execute: wirte)\n```\n#### 对象池模式\n> 对象池模式是单例模式的一种变体，它可以为组件提供多个完全相同的对象，而非单个对象。对象池模式一般来管理一组可重用的对象，\n \n 此模式解决的问题：需要限制某个类型对象的数量，但允许多个个对象的存在。例如图书管理系统，需要管理某本书，但是又是多本存在。常见情况:UITableviewCell 的重用\n\n利用范式创造一个对象池\n\n```\nclass Pool<T> {\n    private var data = [T]()\n    private let arrayQ = DispatchQueue(label: \"arrayQ\")\n    ///创建GCD信号源\n    private let semaphore: DispatchSemaphore\n    \n    init(items:[T]) {\n        data.reserveCapacity(data.count)\n        semaphore = DispatchSemaphore(value: items.count)\n\n        items.forEach{\n            data.append($0)\n        }\n    }\n    \n    func getFromPool() -> T? {\n        var result: T?\n        if semaphore.wait(timeout: .distantFuture) == .success {\n            arrayQ.sync {\n                result = self.data.remove(at: 0)\n            }\n        }\n        return result\n    }\n    \n    func returnToPool(item: T) {\n        arrayQ.sync {\n            self.data.append(item)\n            semaphore.signal()\n        }\n    }\n}\n```\n> 注释: reserveCapacity 这个方法非常有趣。数组类型的元素并不一定需要是连续的（除非你使用 ContiguousArray），但是它们大部分都是连续的。正因如此，我们常常分配一段内存空间，用来存储我们的数组——特别是当我们知道数组的大致大小时。例如，`map()` 方法总是会返回和调用该方法的序列一样大小的一个数组。所以，`map()` 方法在填充数组之前，应该会使用 `reserveCapacity`。这一点可能不容易理解。`map()` 作用于 SequenceType 类型，不仅仅是 CollectionType 类型。Sequence 类型并没有 count 属性——那么如何才能得到序列的长度呢？即使它有 count 属性，CollectionType 类型的该属性，应该返回 Index.Distance，而对于 `reserveCapacity` 来说，需要一个 Int 类型。\n\n##### 使用信号量解决并发问题\n创建一个信号量 `private let semaphore: DispatchSemaphore` 并且在初始化的时候初始化它。\n\n```\nclass Pool<T> {\n\tinit(items: [T]) {\n\t\t// 为信号源创建一个计数器\n\t\tsemaphore = DispatchSemaphore(value: items.count)\n\t}\n\tfunc getFromPool() -> T? {\n\t\t// 每次调用 semaphore.wait 都会使计数器的值减一 \n\t\tif semaphore.wait(timeout: .distantFuture) == .success {\n\t\t\t//确保在分线程执行操作 如果再主线程操作 整个 APP 就会冻住\n\t\t\tarrayQ.sync {\n\t\t\t}\n\t\t}\n\t}\n\tfunc returnToPool(item: T) {\n\t\tarrayQ.sync {\n\t\t\t//\n\t\t\tsemaphore.singal()\n\t\t}\n\t}\n}\n```\n\n#### 工厂方法模式\n> 工厂方法模式通过选取相关的实现类来满足调用组件的请求，调用组件无需了解这些实现类的细节以及它们之间的关系。当存在多个类共同实现一个协议或者共同继承一个基类时，就可以使用工厂方法模式。\n\n实现工厂方法模式最简单的方式是定义一个全局函数。由于全局函数可以在整个应用内调用，因此调用组件可以方便地定位和调用全局函数。\n\n```\nfunc createRentalCar(passengers: Int) -> RentalCar? {\n    var car: RentalCar?\n    switch passengers {\n    case 0...1:\n        car = Sports()\n    case 2...3:\n        car = Compact()\n    case 4...8:\n        car = SUV()\n    default:\n        car = nil\n    }\n    return car\n}\n```\n\n创建通用协议，使创建的工厂类遵循同一个协议。\n\n```\nprotocol RentalCar {\n    var name: String { get }\n    var passengers: Int { get }\n    var pricePerDay: Float { get }\n}\n\nclass Compact: RentalCar {\n    var name = \"Golf\"\n    var passengers = 3\n    var pricePerDay: Float = 20\n}\n\nclass Sports: RentalCar {\n    var name = \"Sport\"\n    var passengers = 1\n    var pricePerDay: Float = 100\n}\n\nclass SUV: RentalCar {\n    var name = \"SUV\"\n    var passengers = 8\n    var pricePerDay: Float = 75\n}\n```\n\n最后，就能够在类中调用工厂方法创建对象，而不需要了解对象的详细情况。\n\n```\nclass CarSelector {\n    class func selectCar(passengers: Int) -> String? {\n        return createRentalCar(passengers: passengers)?.name\n   }\n}\n```\n\n#### 建造者模式\n> 使用建造者模式可以将创建对象所需的逻辑和默认配置值放入一个建造者类中，这样调用组件只需了解少量配置数据即可创建对象，并且无需了解创建对象所需的默认数据值。\n\n建造者模式实际上在开发中很常用，是指很多时候都没有意识到自己已经使用了建造者模式。说白了就是在创建对象方法和创建对象之间添加了一个中间层。只需在创建对象的时候添加修改的参数，而中间层添加默认参数，从而创建出对象。Swift 中已经很好的能够通过给方法参数添加默认值来实现初始化方法。所以可以很轻松的使用建造者模式。例如：`init(name: String, age: Int = 24, sex: Bool = true)`。\n\n#### 适配器模式\n> 适配器模式通过引入适配器对两个组件进行适配的方式，可以让两个 API 不兼容的组件写作。\n\n适配器模式通过对不同类的 API 进行适配，将应用使用的 API 映射到组件提供的 API 方式，使得两个不兼容的类可以相互协作。\n \n实现适配器模式最优雅的方式是使用 Swift extension。使用 extension 可以为无法修改源码的类增加功能。\n\n其实适配模式的精髓就是让不同的类都**遵循相同的协议**。让不同的类实现好同一个方法\n\n#### 桥接模式\n> 桥接模式通过分离应用的抽象部分与实现部分，使得他们可以独立的变化。为了更高的解决层级爆炸的问题,分离应用的抽象部分与实现部分,使他们可以独立的变化.\n\n从表面上看,桥接模式与适配器模式甚是相似。毕竟桥接模式的功能就是充当依赖某个协议的类与另外协议之间的适配器。虽然桥接模式和适配器模式相似，但是它们的应用场景并不相同。当需要集成无法修改源码的组件时(比如第三方组件),可以使用适配器模式。当你能够修改组件源代码及其运行方式时，便可使用桥接模式。使用桥接模式不只是创建一个桥接类这么简单，还需要最组件代码进行重构，以分离通用的代码和平台相关代码。\n\n假定现在有2个不同的协议，且协议拥有各自的实现方法。\n\n```\nprotocol ClearMessageChannel {\n    func send(message: String)\n}\n\nprotocol SecureMessageChannel {\n   func sendEncryptedMessage(encryptedText: String)\n}\n```\n现在需要通过一个类来实现这2个协议的方法，就需要通过桥接的方式来实现。\n创建一个桥接的类，类中属性遵守不同的协议，并为属性创建协议能够调用的方法\n\n```\nclass Communicator {\n    private let clearChannel: ClearMessageChannel\n    private let secureChannel: SecureMessageChannel\n    private let priorityChannel: PriorityMessageChannel\n\n    init(clearChannel: ClearMessageChannel, secureChannel: SecureMessageChannel ) {\n        self.secureChannel = secureChannel\n        self.clearChannel = clearChannel\n    }\n\n    func sendCleartextMessage(mesage: String) {\n        self.clearChannel.send(message: mesage)\n    }\n\n    func sendSecureMessage(message: String) {\n        self.secureChannel.sendEncryptedMessage(encryptedText: message)\n    }\n}\n```\n接下里，需要创建出不同的类来遵循上述协议并实现协议方法\n\n```\nclass Landline: ClearMessageChannel {\n    func send(message: String) {\n        print(\"Landline\",message)\n    }\n}\n\nclass SecureLandLine: SecureMessageChannel {\n    func sendEncryptedMessage(encryptedText: String) {\n            print(\"Secure\", encryptedText)\n    }\n}\n```\n最后,通过就能够通过创建桥接对象来实现协议方法。\n\n```\nvar comms = Communicator(clearChannel: Landline(), secureChannel: SecureLandLine())\n\ncomms.sendCleartextMessage(mesage: \"CLEAR\")\ncomms.sendSecureMessage(message: \"Sercure\")\n```\n\n#### 装饰器模式\n\n> 此模式在处理无法修改的类时能发挥强大的功能。可以在不修改对象所属的类或对象的使用者情况下，修改单个对象的行为。\n\n为了实现装饰器模式，需要继承那个无法修改的类，以创建一个拥有该类所有方法和属性的类，这样才可以实现无缝替换原来的那个类。但是 **Swift 不建议使用继承**。尽量还是避免使用这种模式。\n\n#### 组合模式\n\n> 组合模式能够将对象以树形结构组织起来，使得外界对单个对象和组合对象的使用具有一致性。\n\n组合模式的实现主要是通过让不同的 类 都**遵循统一的协议**，这样就能够实现一个管理类统一处理不同对象。\n![](https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.jpg?raw=true)\n\n#### 外观模式\n\n> 外观模式可以简化复杂的常见任务 API的使用\n\n#### 享元模式\n\n> 享元模式可以在多个调用组件之间共享数据\n \n享元模式不会修改外部数据，也不允许调用组件修改外部数据。这是享元模式非常重要的特征，允许对外部数据进行修改也是人们在实现享元模式时常犯的一个错误。\n\n#### 代理模式\n\n> 代理模式的核心是一个对象--代理对象，此对象可以用于代表其他资源，此对象可以用于代表其他资源。\n\n#### 责任链模式\n\n> 责任链模式负责组织管理一序列能够对调用组件的请求做出响应的对象。这里所说的对象序列被称为责任链，责任链中的每个对象都可能被用于处理某个请求。请求在这个链上传递，知道链上的某一个对象处理此请求，或者到达链的尾部。\n \n当多个对象可以响应一个请求，而又不想将这些对象的细节暴露给调用组件时，便可以使用责任链模式。下面举例说明一下责任链模式。\n创建一种消息类型 Message，包括发送者、接收者和消息内容:\n\n```\nstruct Message {\n    let from: String\n    let to:   String\n    let subject: String\n}\n```\n\n现在需要创建一条责任链，作用是处理 Message，判断这条消息是内部消息(from 和 to 的邮箱是同一个)、外部消息(from 和 to 不是同一个邮箱)还是私密消息(subject 的内容是 Priority 开头)。\n\n```\nclass Transmitter {\n    var nextLinke: Transmitter?\n    \n    required init() { }\n    \n    func sendMessage(_ message: Message) {\n        if (nextLinke != nil) {\n            nextLinke?.sendMessage(message)\n        } else {\n            print(\"责任链到达底端，消息不再发送。\")\n        }\n    }\n    \n    class func matchEmailSuffix(message: Message) -> Bool {\n        // 判断收和发的邮箱是否是同一个\n        if let index = message.from.index(of: \"@\"){\n            let sub = String(message.from[index...])\n            return message.to.hasSuffix(sub)\n        }\n        return false\n    }\n    // 创建一条责任链\n    class func createChain() -> Transmitter? {\n        let transmitterClasses: [Transmitter.Type] = [\n            PriorityTransmitter.self,\n            LocalTransmitter.self,\n            RemoteTransmitter.self]\n        \n        var link: Transmitter?\n        \n        transmitterClasses.reversed().forEach {\n            let existingLink = link\n            link = $0.init()\n            link?.nextLinke =  existingLink\n        }\n        return link\n    }\n}\n```\n\n接下来就需要将责任链中不同的责任类进行实现，他们都需要集成责任链的类，并重写 sendMessage 的方法，然后在 sendMessage 的方法中分别实现自己的需求。\n\n```\nclass LocalTransmitter: Transmitter {\n    override func sendMessage(_ message: Message)  {\n        if (Transmitter.matchEmailSuffix(message: message)) {\n            print(\"\\(message.from) 发送的内部消息\")\n        } else {\n            super.sendMessage(message)\n        }\n    }\n}\n\nclass RemoteTransmitter: Transmitter {\n    override func sendMessage(_ message: Message) {\n        if (!Transmitter.matchEmailSuffix(message: message)) {\n            print(\"\\(message.from) 发送外部消息\")\n        } else {\n            super.sendMessage(message)\n        }\n    }\n}\n\nclass PriorityTransmitter: Transmitter {\n    override func sendMessage(_ message: Message) {\n        if (message.subject.hasPrefix(\"Priority\")) {\n            print(\"\\(message.from) 发送 私人消息\")\n        } else {\n            super.sendMessage(message)\n        }\n    }\n}\n```\n\n最后在创建的责任链中注意实现 sendMessage 方法:\n\n```\nlet message = [Message(from: \"bob@163.com\", to: \"joe@qq.com\", subject: \"午饭吃啥？\"),\n               Message(from: \"joe@qq.com\", to: \"ali@qq.com\", subject: \"你吃啥？\"),\n               Message(from: \"pet@2\", to: \"all@2\", subject: \"Priority: 这是私密消息！\")]\n\nif let chain = Transmitter.createChain()  {\n    message.forEach {\n        chain.sendMessage($0)\n    }\n}\n// bob@163.com 发送外部消息\n// joe@qq.com 发送的内部消息\n// pet@2 发送 私人消息\n```\n\n#### 命令模式\n> 命令模式提供了一种封装方法调用的机制，基于这种机制我们可以实现延迟方法调用或替换调用该方法的组用。命令模式的核心是 **命令对象**。在其内部实现中，接受对象持有一个命令 **接收者对象** 的引用，并知道如何调用接收者的相关方法。接收者和调用指令是命令私有的，不应允许使用命令的调用组件去访问。命令对象唯一的可供公开访问的是 execution 方法。当调用组件需要执行相关命令时，直接调用 execution 即可。\n","slug":"回顾Swift设计模式","published":1,"updated":"2018-01-17T09:36:11.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyb100217sn6d7dq1pc9","content":"<p>《Swift 设计模式》已经看过一遍了，不过大多时候也是看完就忘记了，这里重新再看一遍并记录一下。</p>\n<!--- more --->\n<h4 id=\"对象模板模式\"><a href=\"#对象模板模式\" class=\"headerlink\" title=\"对象模板模式\"></a>对象模板模式</h4><blockquote>\n<p>其实这个设计模式就是我们通常概念的 <font color=#d13f28><strong>面向对象</strong></font> 编程。使用 <strong>类</strong> 或者 <strong>结构体</strong> 作为数据类型及其逻辑的规范。创建对象时使用 <strong>模板</strong>，并在初始化是完成数据赋值。赋值时，要么使用模板中的 <strong>默认值</strong>，要么使用类或者结构体的 <strong>构造器</strong> 提供数值。</p>\n</blockquote>\n<p>技巧：有时候可以通过添加计算属性来保护不希望被随意修改的属性</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> inValue = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> outValue: <span class=\"type\">Int </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> inValue</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">          inValue = max(<span class=\"number\">0</span>, <span class=\"keyword\">new</span><span class=\"type\">Value</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">proClass.outValue = <span class=\"number\">10</span>  <span class=\"comment\">// 10</span></span><br><span class=\"line\">proClass.outValue = <span class=\"number\">-10</span> <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h4><blockquote>\n<p>原型模式通过克隆已有的对象来创建新的对象，已有的对象即为原型</p>\n</blockquote>\n<p>组件若想通过模板创建新的对象，必须掌握以下三个信息。</p>\n<ul>\n<li>与所需创建的对象相关的模板</li>\n<li>必须调用的初始化器</li>\n<li>初始化器的参数名称和类型</li>\n</ul>\n<blockquote>\n<p>将一个值赋给变量时，Swift会自动使用原型模式。值类型是使用结构体定义，而且所有Swift内置类型的底层都是用结构图实现。</p>\n</blockquote>\n<p>换句话说: Swift 只会为 <font color=#d13f28><strong>值类型(结构体)</strong></font> 创建默认的<font color=#d13f28><strong>初始化器</strong></font>。而<strong>不会</strong>为 <font color=#d13f28><strong>引用类型(类)</strong></font> 创建<font color=#d13f28><strong>初始化器</strong></font>。这就会导致创建完原型对象后，之后再创建任意多个同类对象，使用 <strong>结构体</strong> 模板创建的对象不会带来内存开销问题，而使用 <strong>类</strong> 模板创建的对象会有内存指向的问题。(2个变量会指向同一个对象。)<br>为了解决这个问题可以实现 NSCopying 协议，来支持克隆对象，实现深复制。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Appointment</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">NSCopying</span> </span>&#123;</span><br><span class=\"line\">true<span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">true<span class=\"keyword\">var</span> day: <span class=\"type\">String</span></span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>, <span class=\"params\">day</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">truetrue<span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">truetrue<span class=\"keyword\">self</span>.day  <span class=\"operator\">=</span> day</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">true<span class=\"comment\">// 在实现</span></span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">copy</span>(<span class=\"params\">with</span> <span class=\"params\">zone</span>: <span class=\"type\">NSZone</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> -&gt; <span class=\"keyword\">Any</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">AppointmentClass</span>(name: <span class=\"keyword\">self</span>.name, day: <span class=\"keyword\">self</span>.day)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 <span class=\"operator\">=</span> <span class=\"type\">Appointment</span>(name: <span class=\"string\">&quot;Bob&quot;</span>,day: <span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> w1 <span class=\"operator\">=</span> b1.copy() <span class=\"keyword\">as!</span> <span class=\"type\">Appointment</span></span><br><span class=\"line\">w1.name <span class=\"operator\">=</span> <span class=\"string\">&quot;Ali&quot;</span></span><br><span class=\"line\">w1.day  <span class=\"operator\">=</span> <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 此时使用 copy() 创建的 w1 此时就不会对 b1 产生印象</span></span><br></pre></td></tr></table></figure>\n<p>Tips: 只有类才可以实现 NSCopying 协议，结构体不可以。因为结构体本身实现了深复制。</p>\n<h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><blockquote>\n<p>单例模式能够确保某个类型的对象在应用中只存一个实例。</p>\n</blockquote>\n<p>创建单例模式可以像 Objective-C 一样创建一个单线程进行初始化。但是在 Swift 有更好的方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span>: <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> shared <span class=\"operator\">=</span> <span class=\"type\">Single</span>()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">init</span>()</span> &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> title: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> number: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tips:这里遇到一个问题，如果创建单例模式的类不引用 NSOject 继承的话，就会报错。<br>问题找到了，由于在 <code>init()</code> 方法引用了关键字 <code>override</code> 导致了单例类一定要继承 NSObject 才有 <code>init()</code> 方法，所以编译器报错，去掉 <code>override</code> 就可以了。</p>\n<h5 id=\"并发处理\"><a href=\"#并发处理\" class=\"headerlink\" title=\"并发处理\"></a>并发处理</h5><p>如果在多线程应用中使用单例，那就需要仔细考虑一个问题：当有不同的组件同时操作单例对象时，会产生哪些后果。<br>Tips: Swift 数组并不是线程安全的。也就是说两个或更多线程同时调用数组的 <code>append</code> 方法，会同一个数组进行操作，会破坏数据的结构。</p>\n<blockquote>\n<p>注意：高效的并发编程需要谨慎的思考和丰富的经验。有时初衷也许是很好的，但是最终开发出来的应用可能会很慢，甚至出现卡死的现象。</p>\n</blockquote>\n<p>操作 Swift 数组的内容不是一个线程安全的操作，单例对象在使用数组时需要并发保护。为了解决这个问题，可以使用 <font color=d13f28><strong>串行访问</strong></font> 确保同一时刻只允许一个 block 调用数组的 <code>append</code> 方法。</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final class Single: NSObject &#123;</span><br><span class=\"line\">    // 创建出一个线程用来对数组进行操作</span><br><span class=\"line\">    let<span class=\"built_in\"> array </span>= [String]()</span><br><span class=\"line\">   <span class=\"keyword\"> private</span> let arrayQ = DispatchQueue(label: <span class=\"string\">&quot;arrayQ&quot;</span>)</span><br><span class=\"line\">    // 创建出一个方法专门对<span class=\"built_in\"> array </span>进行操作</span><br><span class=\"line\">    func backup(item: String) &#123;</span><br><span class=\"line\">        arrayQ.sync &#123; self.array.append(item) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<p>Tips: Swift 3 以后使用这种方式调用 <code>dipatch_barrier</code></p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> wirte = <span class=\"constructor\">DispatchWorkItem(<span class=\"params\">flags</span>: .<span class=\"params\">barrier</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"comment\">// write data</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dataQueue = <span class=\"constructor\">DispatchQueue(<span class=\"params\">label</span>: <span class=\"string\">&quot;data&quot;</span>, <span class=\"params\">attributes</span>: .<span class=\"params\">concurrent</span>)</span></span><br><span class=\"line\">dataQueue.async(execute: wirte)</span><br></pre></td></tr></table></figure>\n<h4 id=\"对象池模式\"><a href=\"#对象池模式\" class=\"headerlink\" title=\"对象池模式\"></a>对象池模式</h4><blockquote>\n<p>对象池模式是单例模式的一种变体，它可以为组件提供多个完全相同的对象，而非单个对象。对象池模式一般来管理一组可重用的对象，</p>\n</blockquote>\n<p> 此模式解决的问题：需要限制某个类型对象的数量，但允许多个个对象的存在。例如图书管理系统，需要管理某本书，但是又是多本存在。常见情况:UITableviewCell 的重用</p>\n<p>利用范式创造一个对象池</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pool</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> data <span class=\"operator\">=</span> [<span class=\"type\">T</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> arrayQ <span class=\"operator\">=</span> <span class=\"type\">DispatchQueue</span>(label: <span class=\"string\">&quot;arrayQ&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">///创建GCD信号源</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> semaphore: <span class=\"type\">DispatchSemaphore</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">items</span>:[<span class=\"type\">T</span>])</span> &#123;</span><br><span class=\"line\">        data.reserveCapacity(data.count)</span><br><span class=\"line\">        semaphore <span class=\"operator\">=</span> <span class=\"type\">DispatchSemaphore</span>(value: items.count)</span><br><span class=\"line\"></span><br><span class=\"line\">        items.forEach&#123;</span><br><span class=\"line\">            data.append(<span class=\"variable\">$0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFromPool</span>()</span> -&gt; <span class=\"type\">T</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result: <span class=\"type\">T</span>?</span><br><span class=\"line\">        <span class=\"keyword\">if</span> semaphore.wait(timeout: .distantFuture) <span class=\"operator\">==</span> .success &#123;</span><br><span class=\"line\">            arrayQ.sync &#123;</span><br><span class=\"line\">                result <span class=\"operator\">=</span> <span class=\"keyword\">self</span>.data.remove(at: <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">returnToPool</span>(<span class=\"params\">item</span>: <span class=\"type\">T</span>)</span> &#123;</span><br><span class=\"line\">        arrayQ.sync &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.data.append(item)</span><br><span class=\"line\">            semaphore.signal()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注释: reserveCapacity 这个方法非常有趣。数组类型的元素并不一定需要是连续的（除非你使用 ContiguousArray），但是它们大部分都是连续的。正因如此，我们常常分配一段内存空间，用来存储我们的数组——特别是当我们知道数组的大致大小时。例如，<code>map()</code> 方法总是会返回和调用该方法的序列一样大小的一个数组。所以，<code>map()</code> 方法在填充数组之前，应该会使用 <code>reserveCapacity</code>。这一点可能不容易理解。<code>map()</code> 作用于 SequenceType 类型，不仅仅是 CollectionType 类型。Sequence 类型并没有 count 属性——那么如何才能得到序列的长度呢？即使它有 count 属性，CollectionType 类型的该属性，应该返回 Index.Distance，而对于 <code>reserveCapacity</code> 来说，需要一个 Int 类型。</p>\n</blockquote>\n<h5 id=\"使用信号量解决并发问题\"><a href=\"#使用信号量解决并发问题\" class=\"headerlink\" title=\"使用信号量解决并发问题\"></a>使用信号量解决并发问题</h5><p>创建一个信号量 <code>private let semaphore: DispatchSemaphore</code> 并且在初始化的时候初始化它。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pool</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">items</span>: [<span class=\"type\">T</span>])</span> &#123;</span><br><span class=\"line\">truetrue<span class=\"comment\">// 为信号源创建一个计数器</span></span><br><span class=\"line\">truetruesemaphore <span class=\"operator\">=</span> <span class=\"type\">DispatchSemaphore</span>(value: items.count)</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFromPool</span>()</span> -&gt; <span class=\"type\">T</span>? &#123;</span><br><span class=\"line\">truetrue<span class=\"comment\">// 每次调用 semaphore.wait 都会使计数器的值减一 </span></span><br><span class=\"line\">truetrue<span class=\"keyword\">if</span> semaphore.wait(timeout: .distantFuture) <span class=\"operator\">==</span> .success &#123;</span><br><span class=\"line\">truetruetrue<span class=\"comment\">//确保在分线程执行操作 如果再主线程操作 整个 APP 就会冻住</span></span><br><span class=\"line\">truetruetruearrayQ.sync &#123;</span><br><span class=\"line\">truetruetrue&#125;</span><br><span class=\"line\">truetrue&#125;</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">returnToPool</span>(<span class=\"params\">item</span>: <span class=\"type\">T</span>)</span> &#123;</span><br><span class=\"line\">truetruearrayQ.sync &#123;</span><br><span class=\"line\">truetruetrue<span class=\"comment\">//</span></span><br><span class=\"line\">truetruetruesemaphore.singal()</span><br><span class=\"line\">truetrue&#125;</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h4><blockquote>\n<p>工厂方法模式通过选取相关的实现类来满足调用组件的请求，调用组件无需了解这些实现类的细节以及它们之间的关系。当存在多个类共同实现一个协议或者共同继承一个基类时，就可以使用工厂方法模式。</p>\n</blockquote>\n<p>实现工厂方法模式最简单的方式是定义一个全局函数。由于全局函数可以在整个应用内调用，因此调用组件可以方便地定位和调用全局函数。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createRentalCar</span>(<span class=\"params\">passengers</span>: <span class=\"type\">Int</span>)</span> -&gt; <span class=\"type\">RentalCar</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> car: <span class=\"type\">RentalCar</span>?</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> passengers &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span><span class=\"operator\">...</span><span class=\"number\">1</span>:</span><br><span class=\"line\">        car <span class=\"operator\">=</span> <span class=\"type\">Sports</span>()</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span><span class=\"operator\">...</span><span class=\"number\">3</span>:</span><br><span class=\"line\">        car <span class=\"operator\">=</span> <span class=\"type\">Compact</span>()</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">4</span><span class=\"operator\">...</span><span class=\"number\">8</span>:</span><br><span class=\"line\">        car <span class=\"operator\">=</span> <span class=\"type\">SUV</span>()</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        car <span class=\"operator\">=</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> car</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建通用协议，使创建的工厂类遵循同一个协议。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protocol RentalCar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> passengers: <span class=\"built_in\">Int</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pricePerDay: <span class=\"built_in\">Float</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Compact</span>: <span class=\"type\">RentalCar &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;Golf&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> passengers = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> pricePerDay: <span class=\"built_in\">Float</span> = <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span>: <span class=\"type\">RentalCar &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;Sport&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> passengers = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> pricePerDay: <span class=\"built_in\">Float</span> = <span class=\"number\">100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SUV</span>: <span class=\"type\">RentalCar &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;SUV&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> passengers = <span class=\"number\">8</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> pricePerDay: <span class=\"built_in\">Float</span> = <span class=\"number\">75</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，就能够在类中调用工厂方法创建对象，而不需要了解对象的详细情况。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> CarSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> func select<span class=\"constructor\">Car(<span class=\"params\">passengers</span>: Int)</span> -&gt; String? &#123;</span><br><span class=\"line\">        return create<span class=\"constructor\">RentalCar(<span class=\"params\">passengers</span>: <span class=\"params\">passengers</span>)</span>?.name</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h4><blockquote>\n<p>使用建造者模式可以将创建对象所需的逻辑和默认配置值放入一个建造者类中，这样调用组件只需了解少量配置数据即可创建对象，并且无需了解创建对象所需的默认数据值。</p>\n</blockquote>\n<p>建造者模式实际上在开发中很常用，是指很多时候都没有意识到自己已经使用了建造者模式。说白了就是在创建对象方法和创建对象之间添加了一个中间层。只需在创建对象的时候添加修改的参数，而中间层添加默认参数，从而创建出对象。Swift 中已经很好的能够通过给方法参数添加默认值来实现初始化方法。所以可以很轻松的使用建造者模式。例如：<code>init(name: String, age: Int = 24, sex: Bool = true)</code>。</p>\n<h4 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h4><blockquote>\n<p>适配器模式通过引入适配器对两个组件进行适配的方式，可以让两个 API 不兼容的组件写作。</p>\n</blockquote>\n<p>适配器模式通过对不同类的 API 进行适配，将应用使用的 API 映射到组件提供的 API 方式，使得两个不兼容的类可以相互协作。</p>\n<p>实现适配器模式最优雅的方式是使用 Swift extension。使用 extension 可以为无法修改源码的类增加功能。</p>\n<p>其实适配模式的精髓就是让不同的类都<strong>遵循相同的协议</strong>。让不同的类实现好同一个方法</p>\n<h4 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h4><blockquote>\n<p>桥接模式通过分离应用的抽象部分与实现部分，使得他们可以独立的变化。为了更高的解决层级爆炸的问题,分离应用的抽象部分与实现部分,使他们可以独立的变化.</p>\n</blockquote>\n<p>从表面上看,桥接模式与适配器模式甚是相似。毕竟桥接模式的功能就是充当依赖某个协议的类与另外协议之间的适配器。虽然桥接模式和适配器模式相似，但是它们的应用场景并不相同。当需要集成无法修改源码的组件时(比如第三方组件),可以使用适配器模式。当你能够修改组件源代码及其运行方式时，便可使用桥接模式。使用桥接模式不只是创建一个桥接类这么简单，还需要最组件代码进行重构，以分离通用的代码和平台相关代码。</p>\n<p>假定现在有2个不同的协议，且协议拥有各自的实现方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">ClearMessageChannel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span>(<span class=\"params\">message</span>: <span class=\"type\">String</span>)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SecureMessageChannel</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendEncryptedMessage</span>(<span class=\"params\">encryptedText</span>: <span class=\"type\">String</span>)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在需要通过一个类来实现这2个协议的方法，就需要通过桥接的方式来实现。<br>创建一个桥接的类，类中属性遵守不同的协议，并为属性创建协议能够调用的方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Communicator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> clearChannel: <span class=\"type\">ClearMessageChannel</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> secureChannel: <span class=\"type\">SecureMessageChannel</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> priorityChannel: <span class=\"type\">PriorityMessageChannel</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">clearChannel</span>: <span class=\"type\">ClearMessageChannel</span>, <span class=\"params\">secureChannel</span>: <span class=\"type\">SecureMessageChannel</span> )</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.secureChannel <span class=\"operator\">=</span> secureChannel</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.clearChannel <span class=\"operator\">=</span> clearChannel</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendCleartextMessage</span>(<span class=\"params\">mesage</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.clearChannel.send(message: mesage)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendSecureMessage</span>(<span class=\"params\">message</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.secureChannel.sendEncryptedMessage(encryptedText: message)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下里，需要创建出不同的类来遵循上述协议并实现协议方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Landline</span>: <span class=\"title\">ClearMessageChannel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span>(<span class=\"params\">message</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Landline&quot;</span>,message)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecureLandLine</span>: <span class=\"title\">SecureMessageChannel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendEncryptedMessage</span>(<span class=\"params\">encryptedText</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Secure&quot;</span>, encryptedText)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后,通过就能够通过创建桥接对象来实现协议方法。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var comms = <span class=\"constructor\">Communicator(<span class=\"params\">clearChannel</span>: Landline()</span>, secureChannel: <span class=\"constructor\">SecureLandLine()</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">comms.send<span class=\"constructor\">CleartextMessage(<span class=\"params\">mesage</span>: <span class=\"string\">&quot;CLEAR&quot;</span>)</span></span><br><span class=\"line\">comms.send<span class=\"constructor\">SecureMessage(<span class=\"params\">message</span>: <span class=\"string\">&quot;Sercure&quot;</span>)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h4><blockquote>\n<p>此模式在处理无法修改的类时能发挥强大的功能。可以在不修改对象所属的类或对象的使用者情况下，修改单个对象的行为。</p>\n</blockquote>\n<p>为了实现装饰器模式，需要继承那个无法修改的类，以创建一个拥有该类所有方法和属性的类，这样才可以实现无缝替换原来的那个类。但是 <strong>Swift 不建议使用继承</strong>。尽量还是避免使用这种模式。</p>\n<h4 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h4><blockquote>\n<p>组合模式能够将对象以树形结构组织起来，使得外界对单个对象和组合对象的使用具有一致性。</p>\n</blockquote>\n<p>组合模式的实现主要是通过让不同的 类 都<strong>遵循统一的协议</strong>，这样就能够实现一个管理类统一处理不同对象。<br><img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.jpg?raw=true\"></p>\n<h4 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h4><blockquote>\n<p>外观模式可以简化复杂的常见任务 API的使用</p>\n</blockquote>\n<h4 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h4><blockquote>\n<p>享元模式可以在多个调用组件之间共享数据</p>\n</blockquote>\n<p>享元模式不会修改外部数据，也不允许调用组件修改外部数据。这是享元模式非常重要的特征，允许对外部数据进行修改也是人们在实现享元模式时常犯的一个错误。</p>\n<h4 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h4><blockquote>\n<p>代理模式的核心是一个对象–代理对象，此对象可以用于代表其他资源，此对象可以用于代表其他资源。</p>\n</blockquote>\n<h4 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h4><blockquote>\n<p>责任链模式负责组织管理一序列能够对调用组件的请求做出响应的对象。这里所说的对象序列被称为责任链，责任链中的每个对象都可能被用于处理某个请求。请求在这个链上传递，知道链上的某一个对象处理此请求，或者到达链的尾部。</p>\n</blockquote>\n<p>当多个对象可以响应一个请求，而又不想将这些对象的细节暴露给调用组件时，便可以使用责任链模式。下面举例说明一下责任链模式。<br>创建一种消息类型 Message，包括发送者、接收者和消息内容:</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"type\">Message</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> from: <span class=\"keyword\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> to:   <span class=\"keyword\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> subject: <span class=\"keyword\">String</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在需要创建一条责任链，作用是处理 Message，判断这条消息是内部消息(from 和 to 的邮箱是同一个)、外部消息(from 和 to 不是同一个邮箱)还是私密消息(subject 的内容是 Priority 开头)。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transmitter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextLinke: <span class=\"type\">Transmitter</span>?</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"function\"><span class=\"keyword\">init</span>()</span> &#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendMessage</span>(<span class=\"keyword\">_</span> <span class=\"params\">message</span>: <span class=\"type\">Message</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextLinke <span class=\"operator\">!=</span> <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">            nextLinke<span class=\"operator\">?</span>.sendMessage(message)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;责任链到达底端，消息不再发送。&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">matchEmailSuffix</span>(<span class=\"title\">message</span>: <span class=\"title\">Message</span>) -&gt; <span class=\"title\">Bool</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断收和发的邮箱是否是同一个</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> index <span class=\"operator\">=</span> message.from.index(of: <span class=\"string\">&quot;@&quot;</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> sub <span class=\"operator\">=</span> <span class=\"type\">String</span>(message.from[index<span class=\"operator\">...</span>])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> message.to.hasSuffix(sub)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一条责任链</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">createChain</span>() -&gt; <span class=\"title\">Transmitter</span>? </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> transmitterClasses: [<span class=\"type\">Transmitter</span>.<span class=\"keyword\">Type</span>] <span class=\"operator\">=</span> [</span><br><span class=\"line\">            <span class=\"type\">PriorityTransmitter</span>.<span class=\"keyword\">self</span>,</span><br><span class=\"line\">            <span class=\"type\">LocalTransmitter</span>.<span class=\"keyword\">self</span>,</span><br><span class=\"line\">            <span class=\"type\">RemoteTransmitter</span>.<span class=\"keyword\">self</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> link: <span class=\"type\">Transmitter</span>?</span><br><span class=\"line\">        </span><br><span class=\"line\">        transmitterClasses.reversed().forEach &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> existingLink <span class=\"operator\">=</span> link</span><br><span class=\"line\">            link <span class=\"operator\">=</span> <span class=\"variable\">$0</span>.<span class=\"keyword\">init</span>()</span><br><span class=\"line\">            link<span class=\"operator\">?</span>.nextLinke <span class=\"operator\">=</span>  existingLink</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> link</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就需要将责任链中不同的责任类进行实现，他们都需要集成责任链的类，并重写 sendMessage 的方法，然后在 sendMessage 的方法中分别实现自己的需求。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> LocalTransmitter: Transmitter &#123;</span><br><span class=\"line\">    override func send<span class=\"constructor\">Message(<span class=\"params\">_</span> <span class=\"params\">message</span>: Message)</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Transmitter</span>.</span></span><span class=\"keyword\">match</span><span class=\"constructor\">EmailSuffix(<span class=\"params\">message</span>: <span class=\"params\">message</span>)</span>) &#123;</span><br><span class=\"line\">            print(<span class=\"string\">&quot;\\(message.from) 发送的内部消息&quot;</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            super.send<span class=\"constructor\">Message(<span class=\"params\">message</span>)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> RemoteTransmitter: Transmitter &#123;</span><br><span class=\"line\">    override func send<span class=\"constructor\">Message(<span class=\"params\">_</span> <span class=\"params\">message</span>: Message)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Transmitter</span>.</span></span><span class=\"keyword\">match</span><span class=\"constructor\">EmailSuffix(<span class=\"params\">message</span>: <span class=\"params\">message</span>)</span>) &#123;</span><br><span class=\"line\">            print(<span class=\"string\">&quot;\\(message.from) 发送外部消息&quot;</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            super.send<span class=\"constructor\">Message(<span class=\"params\">message</span>)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> PriorityTransmitter: Transmitter &#123;</span><br><span class=\"line\">    override func send<span class=\"constructor\">Message(<span class=\"params\">_</span> <span class=\"params\">message</span>: Message)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (message.subject.has<span class=\"constructor\">Prefix(<span class=\"string\">&quot;Priority&quot;</span>)</span>) &#123;</span><br><span class=\"line\">            print(<span class=\"string\">&quot;\\(message.from) 发送 私人消息&quot;</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            super.send<span class=\"constructor\">Message(<span class=\"params\">message</span>)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后在创建的责任链中注意实现 sendMessage 方法:</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let message = [Message(from: <span class=\"string\">&quot;bob@163.com&quot;</span>, to: <span class=\"string\">&quot;joe@qq.com&quot;</span>, subject: <span class=\"string\">&quot;午饭吃啥？&quot;</span>),</span><br><span class=\"line\">               Message(from: <span class=\"string\">&quot;joe@qq.com&quot;</span>, to: <span class=\"string\">&quot;ali@qq.com&quot;</span>, subject: <span class=\"string\">&quot;你吃啥？&quot;</span>),</span><br><span class=\"line\">               Message(from: <span class=\"string\">&quot;pet@2&quot;</span>, to: <span class=\"string\">&quot;all@2&quot;</span>, subject: <span class=\"string\">&quot;Priority: 这是私密消息！&quot;</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> let chain = Transmitter.createChain()  &#123;</span><br><span class=\"line\">    message.forEach &#123;</span><br><span class=\"line\">        chain.sendMessage($0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bob@163.com 发送外部消息</span><br><span class=\"line\">// joe@qq.com 发送的内部消息</span><br><span class=\"line\">// pet@2 发送 私人消息</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h4><blockquote>\n<p>命令模式提供了一种封装方法调用的机制，基于这种机制我们可以实现延迟方法调用或替换调用该方法的组用。命令模式的核心是 <strong>命令对象</strong>。在其内部实现中，接受对象持有一个命令 <strong>接收者对象</strong> 的引用，并知道如何调用接收者的相关方法。接收者和调用指令是命令私有的，不应允许使用命令的调用组件去访问。命令对象唯一的可供公开访问的是 execution 方法。当调用组件需要执行相关命令时，直接调用 execution 即可。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>《Swift 设计模式》已经看过一遍了，不过大多时候也是看完就忘记了，这里重新再看一遍并记录一下。</p>\n<!--- more --->\n<h4 id=\"对象模板模式\"><a href=\"#对象模板模式\" class=\"headerlink\" title=\"对象模板模式\"></a>对象模板模式</h4><blockquote>\n<p>其实这个设计模式就是我们通常概念的 <font color=#d13f28><strong>面向对象</strong></font> 编程。使用 <strong>类</strong> 或者 <strong>结构体</strong> 作为数据类型及其逻辑的规范。创建对象时使用 <strong>模板</strong>，并在初始化是完成数据赋值。赋值时，要么使用模板中的 <strong>默认值</strong>，要么使用类或者结构体的 <strong>构造器</strong> 提供数值。</p>\n</blockquote>\n<p>技巧：有时候可以通过添加计算属性来保护不希望被随意修改的属性</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> inValue = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> outValue: <span class=\"type\">Int </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> inValue</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">          inValue = max(<span class=\"number\">0</span>, <span class=\"keyword\">new</span><span class=\"type\">Value</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">proClass.outValue = <span class=\"number\">10</span>  <span class=\"comment\">// 10</span></span><br><span class=\"line\">proClass.outValue = <span class=\"number\">-10</span> <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h4><blockquote>\n<p>原型模式通过克隆已有的对象来创建新的对象，已有的对象即为原型</p>\n</blockquote>\n<p>组件若想通过模板创建新的对象，必须掌握以下三个信息。</p>\n<ul>\n<li>与所需创建的对象相关的模板</li>\n<li>必须调用的初始化器</li>\n<li>初始化器的参数名称和类型</li>\n</ul>\n<blockquote>\n<p>将一个值赋给变量时，Swift会自动使用原型模式。值类型是使用结构体定义，而且所有Swift内置类型的底层都是用结构图实现。</p>\n</blockquote>\n<p>换句话说: Swift 只会为 <font color=#d13f28><strong>值类型(结构体)</strong></font> 创建默认的<font color=#d13f28><strong>初始化器</strong></font>。而<strong>不会</strong>为 <font color=#d13f28><strong>引用类型(类)</strong></font> 创建<font color=#d13f28><strong>初始化器</strong></font>。这就会导致创建完原型对象后，之后再创建任意多个同类对象，使用 <strong>结构体</strong> 模板创建的对象不会带来内存开销问题，而使用 <strong>类</strong> 模板创建的对象会有内存指向的问题。(2个变量会指向同一个对象。)<br>为了解决这个问题可以实现 NSCopying 协议，来支持克隆对象，实现深复制。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Appointment</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">NSCopying</span> </span>&#123;</span><br><span class=\"line\">true<span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">true<span class=\"keyword\">var</span> day: <span class=\"type\">String</span></span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>, <span class=\"params\">day</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">truetrue<span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">truetrue<span class=\"keyword\">self</span>.day  <span class=\"operator\">=</span> day</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">true<span class=\"comment\">// 在实现</span></span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">copy</span>(<span class=\"params\">with</span> <span class=\"params\">zone</span>: <span class=\"type\">NSZone</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> -&gt; <span class=\"keyword\">Any</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">AppointmentClass</span>(name: <span class=\"keyword\">self</span>.name, day: <span class=\"keyword\">self</span>.day)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 <span class=\"operator\">=</span> <span class=\"type\">Appointment</span>(name: <span class=\"string\">&quot;Bob&quot;</span>,day: <span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> w1 <span class=\"operator\">=</span> b1.copy() <span class=\"keyword\">as!</span> <span class=\"type\">Appointment</span></span><br><span class=\"line\">w1.name <span class=\"operator\">=</span> <span class=\"string\">&quot;Ali&quot;</span></span><br><span class=\"line\">w1.day  <span class=\"operator\">=</span> <span class=\"string\">&quot;2&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 此时使用 copy() 创建的 w1 此时就不会对 b1 产生印象</span></span><br></pre></td></tr></table></figure>\n<p>Tips: 只有类才可以实现 NSCopying 协议，结构体不可以。因为结构体本身实现了深复制。</p>\n<h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><blockquote>\n<p>单例模式能够确保某个类型的对象在应用中只存一个实例。</p>\n</blockquote>\n<p>创建单例模式可以像 Objective-C 一样创建一个单线程进行初始化。但是在 Swift 有更好的方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Single</span>: <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> shared <span class=\"operator\">=</span> <span class=\"type\">Single</span>()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">init</span>()</span> &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> title: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> number: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tips:这里遇到一个问题，如果创建单例模式的类不引用 NSOject 继承的话，就会报错。<br>问题找到了，由于在 <code>init()</code> 方法引用了关键字 <code>override</code> 导致了单例类一定要继承 NSObject 才有 <code>init()</code> 方法，所以编译器报错，去掉 <code>override</code> 就可以了。</p>\n<h5 id=\"并发处理\"><a href=\"#并发处理\" class=\"headerlink\" title=\"并发处理\"></a>并发处理</h5><p>如果在多线程应用中使用单例，那就需要仔细考虑一个问题：当有不同的组件同时操作单例对象时，会产生哪些后果。<br>Tips: Swift 数组并不是线程安全的。也就是说两个或更多线程同时调用数组的 <code>append</code> 方法，会同一个数组进行操作，会破坏数据的结构。</p>\n<blockquote>\n<p>注意：高效的并发编程需要谨慎的思考和丰富的经验。有时初衷也许是很好的，但是最终开发出来的应用可能会很慢，甚至出现卡死的现象。</p>\n</blockquote>\n<p>操作 Swift 数组的内容不是一个线程安全的操作，单例对象在使用数组时需要并发保护。为了解决这个问题，可以使用 <font color=d13f28><strong>串行访问</strong></font> 确保同一时刻只允许一个 block 调用数组的 <code>append</code> 方法。</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final class Single: NSObject &#123;</span><br><span class=\"line\">    // 创建出一个线程用来对数组进行操作</span><br><span class=\"line\">    let<span class=\"built_in\"> array </span>= [String]()</span><br><span class=\"line\">   <span class=\"keyword\"> private</span> let arrayQ = DispatchQueue(label: <span class=\"string\">&quot;arrayQ&quot;</span>)</span><br><span class=\"line\">    // 创建出一个方法专门对<span class=\"built_in\"> array </span>进行操作</span><br><span class=\"line\">    func backup(item: String) &#123;</span><br><span class=\"line\">        arrayQ.sync &#123; self.array.append(item) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure>\n<p>Tips: Swift 3 以后使用这种方式调用 <code>dipatch_barrier</code></p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> wirte = <span class=\"constructor\">DispatchWorkItem(<span class=\"params\">flags</span>: .<span class=\"params\">barrier</span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"comment\">// write data</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dataQueue = <span class=\"constructor\">DispatchQueue(<span class=\"params\">label</span>: <span class=\"string\">&quot;data&quot;</span>, <span class=\"params\">attributes</span>: .<span class=\"params\">concurrent</span>)</span></span><br><span class=\"line\">dataQueue.async(execute: wirte)</span><br></pre></td></tr></table></figure>\n<h4 id=\"对象池模式\"><a href=\"#对象池模式\" class=\"headerlink\" title=\"对象池模式\"></a>对象池模式</h4><blockquote>\n<p>对象池模式是单例模式的一种变体，它可以为组件提供多个完全相同的对象，而非单个对象。对象池模式一般来管理一组可重用的对象，</p>\n</blockquote>\n<p> 此模式解决的问题：需要限制某个类型对象的数量，但允许多个个对象的存在。例如图书管理系统，需要管理某本书，但是又是多本存在。常见情况:UITableviewCell 的重用</p>\n<p>利用范式创造一个对象池</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pool</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> data <span class=\"operator\">=</span> [<span class=\"type\">T</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> arrayQ <span class=\"operator\">=</span> <span class=\"type\">DispatchQueue</span>(label: <span class=\"string\">&quot;arrayQ&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">///创建GCD信号源</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> semaphore: <span class=\"type\">DispatchSemaphore</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">items</span>:[<span class=\"type\">T</span>])</span> &#123;</span><br><span class=\"line\">        data.reserveCapacity(data.count)</span><br><span class=\"line\">        semaphore <span class=\"operator\">=</span> <span class=\"type\">DispatchSemaphore</span>(value: items.count)</span><br><span class=\"line\"></span><br><span class=\"line\">        items.forEach&#123;</span><br><span class=\"line\">            data.append(<span class=\"variable\">$0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFromPool</span>()</span> -&gt; <span class=\"type\">T</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result: <span class=\"type\">T</span>?</span><br><span class=\"line\">        <span class=\"keyword\">if</span> semaphore.wait(timeout: .distantFuture) <span class=\"operator\">==</span> .success &#123;</span><br><span class=\"line\">            arrayQ.sync &#123;</span><br><span class=\"line\">                result <span class=\"operator\">=</span> <span class=\"keyword\">self</span>.data.remove(at: <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">returnToPool</span>(<span class=\"params\">item</span>: <span class=\"type\">T</span>)</span> &#123;</span><br><span class=\"line\">        arrayQ.sync &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.data.append(item)</span><br><span class=\"line\">            semaphore.signal()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注释: reserveCapacity 这个方法非常有趣。数组类型的元素并不一定需要是连续的（除非你使用 ContiguousArray），但是它们大部分都是连续的。正因如此，我们常常分配一段内存空间，用来存储我们的数组——特别是当我们知道数组的大致大小时。例如，<code>map()</code> 方法总是会返回和调用该方法的序列一样大小的一个数组。所以，<code>map()</code> 方法在填充数组之前，应该会使用 <code>reserveCapacity</code>。这一点可能不容易理解。<code>map()</code> 作用于 SequenceType 类型，不仅仅是 CollectionType 类型。Sequence 类型并没有 count 属性——那么如何才能得到序列的长度呢？即使它有 count 属性，CollectionType 类型的该属性，应该返回 Index.Distance，而对于 <code>reserveCapacity</code> 来说，需要一个 Int 类型。</p>\n</blockquote>\n<h5 id=\"使用信号量解决并发问题\"><a href=\"#使用信号量解决并发问题\" class=\"headerlink\" title=\"使用信号量解决并发问题\"></a>使用信号量解决并发问题</h5><p>创建一个信号量 <code>private let semaphore: DispatchSemaphore</code> 并且在初始化的时候初始化它。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pool</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">items</span>: [<span class=\"type\">T</span>])</span> &#123;</span><br><span class=\"line\">truetrue<span class=\"comment\">// 为信号源创建一个计数器</span></span><br><span class=\"line\">truetruesemaphore <span class=\"operator\">=</span> <span class=\"type\">DispatchSemaphore</span>(value: items.count)</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFromPool</span>()</span> -&gt; <span class=\"type\">T</span>? &#123;</span><br><span class=\"line\">truetrue<span class=\"comment\">// 每次调用 semaphore.wait 都会使计数器的值减一 </span></span><br><span class=\"line\">truetrue<span class=\"keyword\">if</span> semaphore.wait(timeout: .distantFuture) <span class=\"operator\">==</span> .success &#123;</span><br><span class=\"line\">truetruetrue<span class=\"comment\">//确保在分线程执行操作 如果再主线程操作 整个 APP 就会冻住</span></span><br><span class=\"line\">truetruetruearrayQ.sync &#123;</span><br><span class=\"line\">truetruetrue&#125;</span><br><span class=\"line\">truetrue&#125;</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">returnToPool</span>(<span class=\"params\">item</span>: <span class=\"type\">T</span>)</span> &#123;</span><br><span class=\"line\">truetruearrayQ.sync &#123;</span><br><span class=\"line\">truetruetrue<span class=\"comment\">//</span></span><br><span class=\"line\">truetruetruesemaphore.singal()</span><br><span class=\"line\">truetrue&#125;</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h4><blockquote>\n<p>工厂方法模式通过选取相关的实现类来满足调用组件的请求，调用组件无需了解这些实现类的细节以及它们之间的关系。当存在多个类共同实现一个协议或者共同继承一个基类时，就可以使用工厂方法模式。</p>\n</blockquote>\n<p>实现工厂方法模式最简单的方式是定义一个全局函数。由于全局函数可以在整个应用内调用，因此调用组件可以方便地定位和调用全局函数。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createRentalCar</span>(<span class=\"params\">passengers</span>: <span class=\"type\">Int</span>)</span> -&gt; <span class=\"type\">RentalCar</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> car: <span class=\"type\">RentalCar</span>?</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> passengers &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span><span class=\"operator\">...</span><span class=\"number\">1</span>:</span><br><span class=\"line\">        car <span class=\"operator\">=</span> <span class=\"type\">Sports</span>()</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span><span class=\"operator\">...</span><span class=\"number\">3</span>:</span><br><span class=\"line\">        car <span class=\"operator\">=</span> <span class=\"type\">Compact</span>()</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">4</span><span class=\"operator\">...</span><span class=\"number\">8</span>:</span><br><span class=\"line\">        car <span class=\"operator\">=</span> <span class=\"type\">SUV</span>()</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        car <span class=\"operator\">=</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> car</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建通用协议，使创建的工厂类遵循同一个协议。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protocol RentalCar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: String &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> passengers: <span class=\"built_in\">Int</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pricePerDay: <span class=\"built_in\">Float</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Compact</span>: <span class=\"type\">RentalCar &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;Golf&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> passengers = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> pricePerDay: <span class=\"built_in\">Float</span> = <span class=\"number\">20</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sports</span>: <span class=\"type\">RentalCar &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;Sport&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> passengers = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> pricePerDay: <span class=\"built_in\">Float</span> = <span class=\"number\">100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SUV</span>: <span class=\"type\">RentalCar &#123;</span></span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">&quot;SUV&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> passengers = <span class=\"number\">8</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> pricePerDay: <span class=\"built_in\">Float</span> = <span class=\"number\">75</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，就能够在类中调用工厂方法创建对象，而不需要了解对象的详细情况。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> CarSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> func select<span class=\"constructor\">Car(<span class=\"params\">passengers</span>: Int)</span> -&gt; String? &#123;</span><br><span class=\"line\">        return create<span class=\"constructor\">RentalCar(<span class=\"params\">passengers</span>: <span class=\"params\">passengers</span>)</span>?.name</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h4><blockquote>\n<p>使用建造者模式可以将创建对象所需的逻辑和默认配置值放入一个建造者类中，这样调用组件只需了解少量配置数据即可创建对象，并且无需了解创建对象所需的默认数据值。</p>\n</blockquote>\n<p>建造者模式实际上在开发中很常用，是指很多时候都没有意识到自己已经使用了建造者模式。说白了就是在创建对象方法和创建对象之间添加了一个中间层。只需在创建对象的时候添加修改的参数，而中间层添加默认参数，从而创建出对象。Swift 中已经很好的能够通过给方法参数添加默认值来实现初始化方法。所以可以很轻松的使用建造者模式。例如：<code>init(name: String, age: Int = 24, sex: Bool = true)</code>。</p>\n<h4 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h4><blockquote>\n<p>适配器模式通过引入适配器对两个组件进行适配的方式，可以让两个 API 不兼容的组件写作。</p>\n</blockquote>\n<p>适配器模式通过对不同类的 API 进行适配，将应用使用的 API 映射到组件提供的 API 方式，使得两个不兼容的类可以相互协作。</p>\n<p>实现适配器模式最优雅的方式是使用 Swift extension。使用 extension 可以为无法修改源码的类增加功能。</p>\n<p>其实适配模式的精髓就是让不同的类都<strong>遵循相同的协议</strong>。让不同的类实现好同一个方法</p>\n<h4 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h4><blockquote>\n<p>桥接模式通过分离应用的抽象部分与实现部分，使得他们可以独立的变化。为了更高的解决层级爆炸的问题,分离应用的抽象部分与实现部分,使他们可以独立的变化.</p>\n</blockquote>\n<p>从表面上看,桥接模式与适配器模式甚是相似。毕竟桥接模式的功能就是充当依赖某个协议的类与另外协议之间的适配器。虽然桥接模式和适配器模式相似，但是它们的应用场景并不相同。当需要集成无法修改源码的组件时(比如第三方组件),可以使用适配器模式。当你能够修改组件源代码及其运行方式时，便可使用桥接模式。使用桥接模式不只是创建一个桥接类这么简单，还需要最组件代码进行重构，以分离通用的代码和平台相关代码。</p>\n<p>假定现在有2个不同的协议，且协议拥有各自的实现方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">ClearMessageChannel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span>(<span class=\"params\">message</span>: <span class=\"type\">String</span>)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SecureMessageChannel</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendEncryptedMessage</span>(<span class=\"params\">encryptedText</span>: <span class=\"type\">String</span>)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在需要通过一个类来实现这2个协议的方法，就需要通过桥接的方式来实现。<br>创建一个桥接的类，类中属性遵守不同的协议，并为属性创建协议能够调用的方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Communicator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> clearChannel: <span class=\"type\">ClearMessageChannel</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> secureChannel: <span class=\"type\">SecureMessageChannel</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">let</span> priorityChannel: <span class=\"type\">PriorityMessageChannel</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">clearChannel</span>: <span class=\"type\">ClearMessageChannel</span>, <span class=\"params\">secureChannel</span>: <span class=\"type\">SecureMessageChannel</span> )</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.secureChannel <span class=\"operator\">=</span> secureChannel</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.clearChannel <span class=\"operator\">=</span> clearChannel</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendCleartextMessage</span>(<span class=\"params\">mesage</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.clearChannel.send(message: mesage)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendSecureMessage</span>(<span class=\"params\">message</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.secureChannel.sendEncryptedMessage(encryptedText: message)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下里，需要创建出不同的类来遵循上述协议并实现协议方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Landline</span>: <span class=\"title\">ClearMessageChannel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span>(<span class=\"params\">message</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Landline&quot;</span>,message)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecureLandLine</span>: <span class=\"title\">SecureMessageChannel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendEncryptedMessage</span>(<span class=\"params\">encryptedText</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Secure&quot;</span>, encryptedText)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后,通过就能够通过创建桥接对象来实现协议方法。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var comms = <span class=\"constructor\">Communicator(<span class=\"params\">clearChannel</span>: Landline()</span>, secureChannel: <span class=\"constructor\">SecureLandLine()</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">comms.send<span class=\"constructor\">CleartextMessage(<span class=\"params\">mesage</span>: <span class=\"string\">&quot;CLEAR&quot;</span>)</span></span><br><span class=\"line\">comms.send<span class=\"constructor\">SecureMessage(<span class=\"params\">message</span>: <span class=\"string\">&quot;Sercure&quot;</span>)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h4><blockquote>\n<p>此模式在处理无法修改的类时能发挥强大的功能。可以在不修改对象所属的类或对象的使用者情况下，修改单个对象的行为。</p>\n</blockquote>\n<p>为了实现装饰器模式，需要继承那个无法修改的类，以创建一个拥有该类所有方法和属性的类，这样才可以实现无缝替换原来的那个类。但是 <strong>Swift 不建议使用继承</strong>。尽量还是避免使用这种模式。</p>\n<h4 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h4><blockquote>\n<p>组合模式能够将对象以树形结构组织起来，使得外界对单个对象和组合对象的使用具有一致性。</p>\n</blockquote>\n<p>组合模式的实现主要是通过让不同的 类 都<strong>遵循统一的协议</strong>，这样就能够实现一个管理类统一处理不同对象。<br><img src=\"https://github.com/hGhostD/MarkDownPhotos/blob/master/Swift%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.jpg?raw=true\"></p>\n<h4 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h4><blockquote>\n<p>外观模式可以简化复杂的常见任务 API的使用</p>\n</blockquote>\n<h4 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h4><blockquote>\n<p>享元模式可以在多个调用组件之间共享数据</p>\n</blockquote>\n<p>享元模式不会修改外部数据，也不允许调用组件修改外部数据。这是享元模式非常重要的特征，允许对外部数据进行修改也是人们在实现享元模式时常犯的一个错误。</p>\n<h4 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h4><blockquote>\n<p>代理模式的核心是一个对象–代理对象，此对象可以用于代表其他资源，此对象可以用于代表其他资源。</p>\n</blockquote>\n<h4 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h4><blockquote>\n<p>责任链模式负责组织管理一序列能够对调用组件的请求做出响应的对象。这里所说的对象序列被称为责任链，责任链中的每个对象都可能被用于处理某个请求。请求在这个链上传递，知道链上的某一个对象处理此请求，或者到达链的尾部。</p>\n</blockquote>\n<p>当多个对象可以响应一个请求，而又不想将这些对象的细节暴露给调用组件时，便可以使用责任链模式。下面举例说明一下责任链模式。<br>创建一种消息类型 Message，包括发送者、接收者和消息内容:</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"type\">Message</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> from: <span class=\"keyword\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> to:   <span class=\"keyword\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> subject: <span class=\"keyword\">String</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在需要创建一条责任链，作用是处理 Message，判断这条消息是内部消息(from 和 to 的邮箱是同一个)、外部消息(from 和 to 不是同一个邮箱)还是私密消息(subject 的内容是 Priority 开头)。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transmitter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextLinke: <span class=\"type\">Transmitter</span>?</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"function\"><span class=\"keyword\">init</span>()</span> &#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sendMessage</span>(<span class=\"keyword\">_</span> <span class=\"params\">message</span>: <span class=\"type\">Message</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextLinke <span class=\"operator\">!=</span> <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">            nextLinke<span class=\"operator\">?</span>.sendMessage(message)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;责任链到达底端，消息不再发送。&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">matchEmailSuffix</span>(<span class=\"title\">message</span>: <span class=\"title\">Message</span>) -&gt; <span class=\"title\">Bool</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断收和发的邮箱是否是同一个</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> index <span class=\"operator\">=</span> message.from.index(of: <span class=\"string\">&quot;@&quot;</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> sub <span class=\"operator\">=</span> <span class=\"type\">String</span>(message.from[index<span class=\"operator\">...</span>])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> message.to.hasSuffix(sub)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一条责任链</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">createChain</span>() -&gt; <span class=\"title\">Transmitter</span>? </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> transmitterClasses: [<span class=\"type\">Transmitter</span>.<span class=\"keyword\">Type</span>] <span class=\"operator\">=</span> [</span><br><span class=\"line\">            <span class=\"type\">PriorityTransmitter</span>.<span class=\"keyword\">self</span>,</span><br><span class=\"line\">            <span class=\"type\">LocalTransmitter</span>.<span class=\"keyword\">self</span>,</span><br><span class=\"line\">            <span class=\"type\">RemoteTransmitter</span>.<span class=\"keyword\">self</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> link: <span class=\"type\">Transmitter</span>?</span><br><span class=\"line\">        </span><br><span class=\"line\">        transmitterClasses.reversed().forEach &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> existingLink <span class=\"operator\">=</span> link</span><br><span class=\"line\">            link <span class=\"operator\">=</span> <span class=\"variable\">$0</span>.<span class=\"keyword\">init</span>()</span><br><span class=\"line\">            link<span class=\"operator\">?</span>.nextLinke <span class=\"operator\">=</span>  existingLink</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> link</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来就需要将责任链中不同的责任类进行实现，他们都需要集成责任链的类，并重写 sendMessage 的方法，然后在 sendMessage 的方法中分别实现自己的需求。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> LocalTransmitter: Transmitter &#123;</span><br><span class=\"line\">    override func send<span class=\"constructor\">Message(<span class=\"params\">_</span> <span class=\"params\">message</span>: Message)</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Transmitter</span>.</span></span><span class=\"keyword\">match</span><span class=\"constructor\">EmailSuffix(<span class=\"params\">message</span>: <span class=\"params\">message</span>)</span>) &#123;</span><br><span class=\"line\">            print(<span class=\"string\">&quot;\\(message.from) 发送的内部消息&quot;</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            super.send<span class=\"constructor\">Message(<span class=\"params\">message</span>)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> RemoteTransmitter: Transmitter &#123;</span><br><span class=\"line\">    override func send<span class=\"constructor\">Message(<span class=\"params\">_</span> <span class=\"params\">message</span>: Message)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Transmitter</span>.</span></span><span class=\"keyword\">match</span><span class=\"constructor\">EmailSuffix(<span class=\"params\">message</span>: <span class=\"params\">message</span>)</span>) &#123;</span><br><span class=\"line\">            print(<span class=\"string\">&quot;\\(message.from) 发送外部消息&quot;</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            super.send<span class=\"constructor\">Message(<span class=\"params\">message</span>)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> PriorityTransmitter: Transmitter &#123;</span><br><span class=\"line\">    override func send<span class=\"constructor\">Message(<span class=\"params\">_</span> <span class=\"params\">message</span>: Message)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (message.subject.has<span class=\"constructor\">Prefix(<span class=\"string\">&quot;Priority&quot;</span>)</span>) &#123;</span><br><span class=\"line\">            print(<span class=\"string\">&quot;\\(message.from) 发送 私人消息&quot;</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            super.send<span class=\"constructor\">Message(<span class=\"params\">message</span>)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后在创建的责任链中注意实现 sendMessage 方法:</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let message = [Message(from: <span class=\"string\">&quot;bob@163.com&quot;</span>, to: <span class=\"string\">&quot;joe@qq.com&quot;</span>, subject: <span class=\"string\">&quot;午饭吃啥？&quot;</span>),</span><br><span class=\"line\">               Message(from: <span class=\"string\">&quot;joe@qq.com&quot;</span>, to: <span class=\"string\">&quot;ali@qq.com&quot;</span>, subject: <span class=\"string\">&quot;你吃啥？&quot;</span>),</span><br><span class=\"line\">               Message(from: <span class=\"string\">&quot;pet@2&quot;</span>, to: <span class=\"string\">&quot;all@2&quot;</span>, subject: <span class=\"string\">&quot;Priority: 这是私密消息！&quot;</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> let chain = Transmitter.createChain()  &#123;</span><br><span class=\"line\">    message.forEach &#123;</span><br><span class=\"line\">        chain.sendMessage($0)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bob@163.com 发送外部消息</span><br><span class=\"line\">// joe@qq.com 发送的内部消息</span><br><span class=\"line\">// pet@2 发送 私人消息</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h4><blockquote>\n<p>命令模式提供了一种封装方法调用的机制，基于这种机制我们可以实现延迟方法调用或替换调用该方法的组用。命令模式的核心是 <strong>命令对象</strong>。在其内部实现中，接受对象持有一个命令 <strong>接收者对象</strong> 的引用，并知道如何调用接收者的相关方法。接收者和调用指令是命令私有的，不应允许使用命令的调用组件去访问。命令对象唯一的可供公开访问的是 execution 方法。当调用组件需要执行相关命令时，直接调用 execution 即可。</p>\n</blockquote>\n"},{"layout":"日记","title":"当当买的书到了","date":"2017-11-03T00:52:35.000Z","_content":"今天在当当买的书到了 挑一本慢慢看吧 \n<!--- more --->\n嗯。。。今天突然又决定练字了，哈哈。不知道能坚持多久。就当写着玩吧。练习的时候学到了一招 **横长竖短**！这样写才好看！以后多注意！\n\n今天还看了一下日剧《逃避可耻但有用》新垣结衣真好看啊！！！\n\n明天开始整理一下blog吧。把计划、学习的内容都规划上。\n今天看个视频，现在突然想学习滑滑板。哈哈。原来还突然想学手鼓的呢。。。还有口琴。。。都没坚持下去。。。算了，先记着，都写到计划上去！！！","source":"_posts/当当的书到了.md","raw":"---\nlayout: 日记\ntitle: 当当买的书到了\ndate: 2017-11-03 08:52:35\ntags:\n- 日记\n- 随笔\ncategories:\n- 日记\n---\n今天在当当买的书到了 挑一本慢慢看吧 \n<!--- more --->\n嗯。。。今天突然又决定练字了，哈哈。不知道能坚持多久。就当写着玩吧。练习的时候学到了一招 **横长竖短**！这样写才好看！以后多注意！\n\n今天还看了一下日剧《逃避可耻但有用》新垣结衣真好看啊！！！\n\n明天开始整理一下blog吧。把计划、学习的内容都规划上。\n今天看个视频，现在突然想学习滑滑板。哈哈。原来还突然想学手鼓的呢。。。还有口琴。。。都没坚持下去。。。算了，先记着，都写到计划上去！！！","slug":"当当的书到了","published":1,"updated":"2017-11-08T02:39:38.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyb400267sn6bzzyee19","content":"<p>今天在当当买的书到了 挑一本慢慢看吧 </p>\n<!--- more --->\n<p>嗯。。。今天突然又决定练字了，哈哈。不知道能坚持多久。就当写着玩吧。练习的时候学到了一招 <strong>横长竖短</strong>！这样写才好看！以后多注意！</p>\n<p>今天还看了一下日剧《逃避可耻但有用》新垣结衣真好看啊！！！</p>\n<p>明天开始整理一下blog吧。把计划、学习的内容都规划上。<br>今天看个视频，现在突然想学习滑滑板。哈哈。原来还突然想学手鼓的呢。。。还有口琴。。。都没坚持下去。。。算了，先记着，都写到计划上去！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天在当当买的书到了 挑一本慢慢看吧 </p>\n<!--- more --->\n<p>嗯。。。今天突然又决定练字了，哈哈。不知道能坚持多久。就当写着玩吧。练习的时候学到了一招 <strong>横长竖短</strong>！这样写才好看！以后多注意！</p>\n<p>今天还看了一下日剧《逃避可耻但有用》新垣结衣真好看啊！！！</p>\n<p>明天开始整理一下blog吧。把计划、学习的内容都规划上。<br>今天看个视频，现在突然想学习滑滑板。哈哈。原来还突然想学手鼓的呢。。。还有口琴。。。都没坚持下去。。。算了，先记着，都写到计划上去！！！</p>\n"},{"layout":"swift","title":"第一篇Swift","date":"2017-11-02T00:48:40.000Z","_content":"### 记录遇到的有关Swift的问题\n在这里记录遇到的问题吧，不论大小，总要留下来痕迹。\n\n<!--- more --->\n\n第一次写些技术的文章，可能很多都不是什么新的技术。只是把工作学习时候遇到的问题做一个整理吧。\n\n顺便学习一下 MarkDown 的用法吧。","source":"_posts/第一篇Swift.md","raw":"---\nlayout: swift\ntitle: 第一篇Swift\ndate: 2017-11-02 08:48:40\ntags: \n- Swift\ncategories: \n- Swift\n---\n### 记录遇到的有关Swift的问题\n在这里记录遇到的问题吧，不论大小，总要留下来痕迹。\n\n<!--- more --->\n\n第一次写些技术的文章，可能很多都不是什么新的技术。只是把工作学习时候遇到的问题做一个整理吧。\n\n顺便学习一下 MarkDown 的用法吧。","slug":"第一篇Swift","published":1,"updated":"2017-11-03T06:33:43.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyb500297sn6eikq1bm8","content":"<h3 id=\"记录遇到的有关Swift的问题\"><a href=\"#记录遇到的有关Swift的问题\" class=\"headerlink\" title=\"记录遇到的有关Swift的问题\"></a>记录遇到的有关Swift的问题</h3><p>在这里记录遇到的问题吧，不论大小，总要留下来痕迹。</p>\n<!--- more --->\n\n<p>第一次写些技术的文章，可能很多都不是什么新的技术。只是把工作学习时候遇到的问题做一个整理吧。</p>\n<p>顺便学习一下 MarkDown 的用法吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"记录遇到的有关Swift的问题\"><a href=\"#记录遇到的有关Swift的问题\" class=\"headerlink\" title=\"记录遇到的有关Swift的问题\"></a>记录遇到的有关Swift的问题</h3><p>在这里记录遇到的问题吧，不论大小，总要留下来痕迹。</p>\n<!--- more --->\n\n<p>第一次写些技术的文章，可能很多都不是什么新的技术。只是把工作学习时候遇到的问题做一个整理吧。</p>\n<p>顺便学习一下 MarkDown 的用法吧。</p>\n"},{"layout":"日记","title":"第一篇日记","date":"2017-11-02T02:51:11.000Z","_content":"### 今天终于有了自己的blog\n不容易啊 弄了很久 终于成功了！！！\n<!--- more --->\n\n经过了大概3天的学习和尝试，终于成功的使用 [github](http://github.com) 和 [hexo](https://hexo.io/zh-cn/index.html) 搭建起来了！\n\n\n虽然希望使用 [VPS](https://www.vultr.com/) 和自己的域名进行搭建，但是自己所掌握的知识还是太少，光学习 hexo 的配置就已经花费了很多的时间，索性就直接用这样的吧。\n\n搭建自己的blog的目的其实更多的是为了给自己在网上留下一些自己的痕迹吧。毕竟也已经已经毕业了一段时间，技术也还是不上不下的。从此刻起好好记录整理一下自己的变化吧。\n\n争取坚持每天都记录一些东西吧，不知道能坚持多久~\n<br>\n\n>参考资料\n>[hexo](https://hexo.io/zh-cn/)\n>[Next的配置文档](http://theme-next.iissnan.com/theme-settings.html#categories-page)\n>[简单的搭建和分类blog](http://www.cnblogs.com/sun-haiyu/p/7027093.html)\n>","source":"_posts/第一篇日记.md","raw":"---\nlayout: 日记\ntitle: 第一篇日记\ndate: 2017-11-02 10:51:11\ntags:\n- 日记\n- 随笔\ncategories:\n- 日记\n---\n### 今天终于有了自己的blog\n不容易啊 弄了很久 终于成功了！！！\n<!--- more --->\n\n经过了大概3天的学习和尝试，终于成功的使用 [github](http://github.com) 和 [hexo](https://hexo.io/zh-cn/index.html) 搭建起来了！\n\n\n虽然希望使用 [VPS](https://www.vultr.com/) 和自己的域名进行搭建，但是自己所掌握的知识还是太少，光学习 hexo 的配置就已经花费了很多的时间，索性就直接用这样的吧。\n\n搭建自己的blog的目的其实更多的是为了给自己在网上留下一些自己的痕迹吧。毕竟也已经已经毕业了一段时间，技术也还是不上不下的。从此刻起好好记录整理一下自己的变化吧。\n\n争取坚持每天都记录一些东西吧，不知道能坚持多久~\n<br>\n\n>参考资料\n>[hexo](https://hexo.io/zh-cn/)\n>[Next的配置文档](http://theme-next.iissnan.com/theme-settings.html#categories-page)\n>[简单的搭建和分类blog](http://www.cnblogs.com/sun-haiyu/p/7027093.html)\n>","slug":"第一篇日记","published":1,"updated":"2017-11-08T09:39:26.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyb7002d7sn6bse0g4bn","content":"<h3 id=\"今天终于有了自己的blog\"><a href=\"#今天终于有了自己的blog\" class=\"headerlink\" title=\"今天终于有了自己的blog\"></a>今天终于有了自己的blog</h3><p>不容易啊 弄了很久 终于成功了！！！</p>\n<!--- more --->\n\n<p>经过了大概3天的学习和尝试，终于成功的使用 <a href=\"http://github.com/\">github</a> 和 <a href=\"https://hexo.io/zh-cn/index.html\">hexo</a> 搭建起来了！</p>\n<p>虽然希望使用 <a href=\"https://www.vultr.com/\">VPS</a> 和自己的域名进行搭建，但是自己所掌握的知识还是太少，光学习 hexo 的配置就已经花费了很多的时间，索性就直接用这样的吧。</p>\n<p>搭建自己的blog的目的其实更多的是为了给自己在网上留下一些自己的痕迹吧。毕竟也已经已经毕业了一段时间，技术也还是不上不下的。从此刻起好好记录整理一下自己的变化吧。</p>\n<p>争取坚持每天都记录一些东西吧，不知道能坚持多久~<br><br></p>\n<blockquote>\n<p>参考资料<br><a href=\"https://hexo.io/zh-cn/\">hexo</a><br><a href=\"http://theme-next.iissnan.com/theme-settings.html#categories-page\">Next的配置文档</a><br><a href=\"http://www.cnblogs.com/sun-haiyu/p/7027093.html\">简单的搭建和分类blog</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"今天终于有了自己的blog\"><a href=\"#今天终于有了自己的blog\" class=\"headerlink\" title=\"今天终于有了自己的blog\"></a>今天终于有了自己的blog</h3><p>不容易啊 弄了很久 终于成功了！！！</p>\n<!--- more --->\n\n<p>经过了大概3天的学习和尝试，终于成功的使用 <a href=\"http://github.com/\">github</a> 和 <a href=\"https://hexo.io/zh-cn/index.html\">hexo</a> 搭建起来了！</p>\n<p>虽然希望使用 <a href=\"https://www.vultr.com/\">VPS</a> 和自己的域名进行搭建，但是自己所掌握的知识还是太少，光学习 hexo 的配置就已经花费了很多的时间，索性就直接用这样的吧。</p>\n<p>搭建自己的blog的目的其实更多的是为了给自己在网上留下一些自己的痕迹吧。毕竟也已经已经毕业了一段时间，技术也还是不上不下的。从此刻起好好记录整理一下自己的变化吧。</p>\n<p>争取坚持每天都记录一些东西吧，不知道能坚持多久~<br><br></p>\n<blockquote>\n<p>参考资料<br><a href=\"https://hexo.io/zh-cn/\">hexo</a><br><a href=\"http://theme-next.iissnan.com/theme-settings.html#categories-page\">Next的配置文档</a><br><a href=\"http://www.cnblogs.com/sun-haiyu/p/7027093.html\">简单的搭建和分类blog</a></p>\n</blockquote>\n"},{"layout":"读书","title":"第一篇读书","date":"2017-11-02T00:48:40.000Z","_content":"### 又要开始写读书笔记了\n一直都想写读书笔记，最后总是不了了之。。。\n<!--- more --->\n\n这是第一篇笔记，那就随便写一些吧。\n读了很多书，但是大部分的已经忘记了。只是偶尔脑海中浮现出一两句记得特别清楚句子。有人说读那么多书又忘记了，那有什么用呢？我一直觉得这句话说的很对，也因此沮丧了很久。直到有一天我在知乎看到了这个问题，有一个回答特别好。\n\n**当我还是个孩子时，我吃过很多的食物，现在已经记不起来吃过什么。但可以很肯定的是，它们中的一部分已经长成我的骨头和肉。\n** \n\n看到这句话时候，我突然就释怀了，感觉自己总算找到即便读书之后也完全记不得的借口了。haha~\n <br>\n \n >[读了很多书，但是都忘掉了，读书的意义在哪里？](https://www.zhihu.com/question/22456239/answer/94652171)","source":"_posts/第一篇读书.md","raw":"---\nlayout: 读书\ntitle: 第一篇读书\ndate: 2017-11-02 08:48:40\ntags: \n- 读书\ncategories: \n- 读书\n---\n### 又要开始写读书笔记了\n一直都想写读书笔记，最后总是不了了之。。。\n<!--- more --->\n\n这是第一篇笔记，那就随便写一些吧。\n读了很多书，但是大部分的已经忘记了。只是偶尔脑海中浮现出一两句记得特别清楚句子。有人说读那么多书又忘记了，那有什么用呢？我一直觉得这句话说的很对，也因此沮丧了很久。直到有一天我在知乎看到了这个问题，有一个回答特别好。\n\n**当我还是个孩子时，我吃过很多的食物，现在已经记不起来吃过什么。但可以很肯定的是，它们中的一部分已经长成我的骨头和肉。\n** \n\n看到这句话时候，我突然就释怀了，感觉自己总算找到即便读书之后也完全记不得的借口了。haha~\n <br>\n \n >[读了很多书，但是都忘掉了，读书的意义在哪里？](https://www.zhihu.com/question/22456239/answer/94652171)","slug":"第一篇读书","published":1,"updated":"2017-11-08T09:37:09.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfyb9002g7sn6flk49k2f","content":"<h3 id=\"又要开始写读书笔记了\"><a href=\"#又要开始写读书笔记了\" class=\"headerlink\" title=\"又要开始写读书笔记了\"></a>又要开始写读书笔记了</h3><p>一直都想写读书笔记，最后总是不了了之。。。</p>\n<!--- more --->\n\n<p>这是第一篇笔记，那就随便写一些吧。<br>读了很多书，但是大部分的已经忘记了。只是偶尔脑海中浮现出一两句记得特别清楚句子。有人说读那么多书又忘记了，那有什么用呢？我一直觉得这句话说的很对，也因此沮丧了很久。直到有一天我在知乎看到了这个问题，有一个回答特别好。</p>\n<p>**当我还是个孩子时，我吃过很多的食物，现在已经记不起来吃过什么。但可以很肯定的是，它们中的一部分已经长成我的骨头和肉。<br>** </p>\n<p>看到这句话时候，我突然就释怀了，感觉自己总算找到即便读书之后也完全记不得的借口了。haha~<br> <br></p>\n<blockquote>\n<p><a href=\"https://www.zhihu.com/question/22456239/answer/94652171\">读了很多书，但是都忘掉了，读书的意义在哪里？</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"又要开始写读书笔记了\"><a href=\"#又要开始写读书笔记了\" class=\"headerlink\" title=\"又要开始写读书笔记了\"></a>又要开始写读书笔记了</h3><p>一直都想写读书笔记，最后总是不了了之。。。</p>\n<!--- more --->\n\n<p>这是第一篇笔记，那就随便写一些吧。<br>读了很多书，但是大部分的已经忘记了。只是偶尔脑海中浮现出一两句记得特别清楚句子。有人说读那么多书又忘记了，那有什么用呢？我一直觉得这句话说的很对，也因此沮丧了很久。直到有一天我在知乎看到了这个问题，有一个回答特别好。</p>\n<p>**当我还是个孩子时，我吃过很多的食物，现在已经记不起来吃过什么。但可以很肯定的是，它们中的一部分已经长成我的骨头和肉。<br>** </p>\n<p>看到这句话时候，我突然就释怀了，感觉自己总算找到即便读书之后也完全记不得的借口了。haha~<br> <br></p>\n<blockquote>\n<p><a href=\"https://www.zhihu.com/question/22456239/answer/94652171\">读了很多书，但是都忘掉了，读书的意义在哪里？</a></p>\n</blockquote>\n"},{"layout":"待续","title":"这是一篇待续","date":"2017-11-02T00:48:40.000Z","_content":"### 在这就记录一些琐事吧，还有很多未完的事情\n这个分类和日记有些像吧 这里是记录接下来想做的事情\n<!--- more --->\n\n规划了很久的内容，但是有很多时候实现起来太难了，总是抵挡不住自己的懒惰吧。\n\n总有很多想做未做的事情，看看以后能不能做完吧。\n\n---\n2017年11月09日09:19:36\n开始整理泊学网上的视频学习情况。争取每天一篇。","source":"_posts/这是一篇待续.md","raw":"---\nlayout: 待续\ntitle: 这是一篇待续\ndate: 2017-11-02 08:48:40\ntags: \n- 待续\ncategories: \n- 待续\n---\n### 在这就记录一些琐事吧，还有很多未完的事情\n这个分类和日记有些像吧 这里是记录接下来想做的事情\n<!--- more --->\n\n规划了很久的内容，但是有很多时候实现起来太难了，总是抵挡不住自己的懒惰吧。\n\n总有很多想做未做的事情，看看以后能不能做完吧。\n\n---\n2017年11月09日09:19:36\n开始整理泊学网上的视频学习情况。争取每天一篇。","slug":"这是一篇待续","published":1,"updated":"2017-11-09T01:22:54.000Z","comments":1,"photos":[],"link":"","_id":"ckt8qfybb002k7sn6gi8nec7z","content":"<h3 id=\"在这就记录一些琐事吧，还有很多未完的事情\"><a href=\"#在这就记录一些琐事吧，还有很多未完的事情\" class=\"headerlink\" title=\"在这就记录一些琐事吧，还有很多未完的事情\"></a>在这就记录一些琐事吧，还有很多未完的事情</h3><p>这个分类和日记有些像吧 这里是记录接下来想做的事情</p>\n<!--- more --->\n\n<p>规划了很久的内容，但是有很多时候实现起来太难了，总是抵挡不住自己的懒惰吧。</p>\n<p>总有很多想做未做的事情，看看以后能不能做完吧。</p>\n<hr>\n<p>2017年11月09日09:19:36<br>开始整理泊学网上的视频学习情况。争取每天一篇。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"在这就记录一些琐事吧，还有很多未完的事情\"><a href=\"#在这就记录一些琐事吧，还有很多未完的事情\" class=\"headerlink\" title=\"在这就记录一些琐事吧，还有很多未完的事情\"></a>在这就记录一些琐事吧，还有很多未完的事情</h3><p>这个分类和日记有些像吧 这里是记录接下来想做的事情</p>\n<!--- more --->\n\n<p>规划了很久的内容，但是有很多时候实现起来太难了，总是抵挡不住自己的懒惰吧。</p>\n<p>总有很多想做未做的事情，看看以后能不能做完吧。</p>\n<hr>\n<p>2017年11月09日09:19:36<br>开始整理泊学网上的视频学习情况。争取每天一篇。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckt8qfy9800017sn63slu8c2z","category_id":"ckt8qfy9h00047sn61x99arw7","_id":"ckt8qfy9x000h7sn64fs73582"},{"post_id":"ckt8qfy9d00037sn6btqwfydt","category_id":"ckt8qfy9h00047sn61x99arw7","_id":"ckt8qfya3000m7sn64n627uqi"},{"post_id":"ckt8qfy9y000j7sn6d5zfe9wp","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfya8000s7sn60u871h2l"},{"post_id":"ckt8qfy9l00077sn64wd6aqxo","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfyab000w7sn6do2a4zf6"},{"post_id":"ckt8qfya1000l7sn6fwziegu8","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfyad000z7sn65dttgpga"},{"post_id":"ckt8qfya5000q7sn6587938hl","category_id":"ckt8qfy9h00047sn61x99arw7","_id":"ckt8qfyag00147sn63twy82pl"},{"post_id":"ckt8qfy9o00097sn6feag30r5","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfyai00177sn62q0m646k"},{"post_id":"ckt8qfya7000r7sn6dzxdgh0p","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfyal001c7sn6bhhq5emr"},{"post_id":"ckt8qfyaa000v7sn6as007cow","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfyan001f7sn643ho77qy"},{"post_id":"ckt8qfy9q000b7sn6g4he2qnj","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfyap001j7sn6asfbbbw8"},{"post_id":"ckt8qfyaf00137sn66gr61iax","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfyaq001m7sn61ns0cetk"},{"post_id":"ckt8qfy9t000e7sn6eadw10rp","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfyav001r7sn694m2hg2l"},{"post_id":"ckt8qfyak001b7sn60azfhybw","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfyaw001u7sn6h0h45q0l"},{"post_id":"ckt8qfy9v000f7sn617br57og","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfyaz001z7sn6g4tigjzl"},{"post_id":"ckt8qfyao001i7sn68t75gfsz","category_id":"ckt8qfy9h00047sn61x99arw7","_id":"ckt8qfyb100227sn6cq2z7r4w"},{"post_id":"ckt8qfyac000y7sn66ynhdqte","category_id":"ckt8qfyan001g7sn6f2tcewff","_id":"ckt8qfyb400277sn690vl3tbd"},{"post_id":"ckt8qfyaq001l7sn6b4vhhzyu","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfyb6002a7sn67n3qb21h"},{"post_id":"ckt8qfyau001q7sn6em5xfmiy","category_id":"ckt8qfyan001g7sn6f2tcewff","_id":"ckt8qfyb8002e7sn6eosybpgh"},{"post_id":"ckt8qfyah00167sn698ed2zz1","category_id":"ckt8qfyar001n7sn6appf82ge","_id":"ckt8qfyb9002h7sn6cf0197o0"},{"post_id":"ckt8qfyay001y7sn6h00wgncf","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfybc002l7sn68vfmer04"},{"post_id":"ckt8qfyal001e7sn61jvh3pnl","category_id":"ckt8qfyar001n7sn6appf82ge","_id":"ckt8qfybd002n7sn6h35dggrj"},{"post_id":"ckt8qfyb100217sn6d7dq1pc9","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfybg002q7sn6dhym8xif"},{"post_id":"ckt8qfyb400267sn6bzzyee19","category_id":"ckt8qfy9h00047sn61x99arw7","_id":"ckt8qfybh002s7sn6ga8n4mdq"},{"post_id":"ckt8qfyb500297sn6eikq1bm8","category_id":"ckt8qfy9w000g7sn6fyh3g6z5","_id":"ckt8qfybh002u7sn6f0b44n8l"},{"post_id":"ckt8qfyav001t7sn681jk82k0","category_id":"ckt8qfyb300257sn66sm78l9o","_id":"ckt8qfybj002x7sn6fi9a005d"},{"post_id":"ckt8qfyb7002d7sn6bse0g4bn","category_id":"ckt8qfy9h00047sn61x99arw7","_id":"ckt8qfybj002z7sn6gxzp7t3y"},{"post_id":"ckt8qfyb9002g7sn6flk49k2f","category_id":"ckt8qfyar001n7sn6appf82ge","_id":"ckt8qfybk00327sn69hxe392j"},{"post_id":"ckt8qfybb002k7sn6gi8nec7z","category_id":"ckt8qfyan001g7sn6f2tcewff","_id":"ckt8qfybk00347sn6c9bhczj7"}],"PostTag":[{"post_id":"ckt8qfy9800017sn63slu8c2z","tag_id":"ckt8qfy9j00057sn6hynigazw","_id":"ckt8qfya1000k7sn6aq33bpxl"},{"post_id":"ckt8qfy9800017sn63slu8c2z","tag_id":"ckt8qfy9r000d7sn6dx8bd06u","_id":"ckt8qfya3000n7sn6a4wg5lit"},{"post_id":"ckt8qfy9d00037sn6btqwfydt","tag_id":"ckt8qfy9j00057sn6hynigazw","_id":"ckt8qfyab000x7sn66sf2bdy4"},{"post_id":"ckt8qfy9d00037sn6btqwfydt","tag_id":"ckt8qfy9r000d7sn6dx8bd06u","_id":"ckt8qfyad00107sn6fdf7a8sq"},{"post_id":"ckt8qfyaa000v7sn6as007cow","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfyag00157sn6dbns1o0y"},{"post_id":"ckt8qfy9l00077sn64wd6aqxo","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfyai00187sn6g2zj4rdb"},{"post_id":"ckt8qfy9o00097sn6feag30r5","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfyal001d7sn6dihm5ufv"},{"post_id":"ckt8qfy9q000b7sn6g4he2qnj","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfyap001k7sn6fpa3gtlx"},{"post_id":"ckt8qfyao001i7sn68t75gfsz","tag_id":"ckt8qfy9j00057sn6hynigazw","_id":"ckt8qfyas001p7sn6bco810hm"},{"post_id":"ckt8qfyao001i7sn68t75gfsz","tag_id":"ckt8qfy9r000d7sn6dx8bd06u","_id":"ckt8qfyav001s7sn64vy1hvsi"},{"post_id":"ckt8qfy9t000e7sn6eadw10rp","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfyax001w7sn61u167qdr"},{"post_id":"ckt8qfyaq001l7sn6b4vhhzyu","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfyb000207sn6eioo1u19"},{"post_id":"ckt8qfy9v000f7sn617br57og","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfyb200247sn6cc107v1l"},{"post_id":"ckt8qfyay001y7sn6h00wgncf","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfyb500287sn6e60i93b5"},{"post_id":"ckt8qfy9y000j7sn6d5zfe9wp","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfyb7002c7sn6668ggvnt"},{"post_id":"ckt8qfyb100217sn6d7dq1pc9","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfyb8002f7sn63hao8wel"},{"post_id":"ckt8qfyb400267sn6bzzyee19","tag_id":"ckt8qfy9j00057sn6hynigazw","_id":"ckt8qfyba002i7sn6fhpy3gpj"},{"post_id":"ckt8qfyb400267sn6bzzyee19","tag_id":"ckt8qfy9r000d7sn6dx8bd06u","_id":"ckt8qfybc002m7sn655wfg223"},{"post_id":"ckt8qfya1000l7sn6fwziegu8","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfybd002o7sn67obm51oh"},{"post_id":"ckt8qfyb500297sn6eikq1bm8","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfybg002r7sn6fok3fosg"},{"post_id":"ckt8qfyb7002d7sn6bse0g4bn","tag_id":"ckt8qfy9j00057sn6hynigazw","_id":"ckt8qfybh002t7sn6hwzb132j"},{"post_id":"ckt8qfyb7002d7sn6bse0g4bn","tag_id":"ckt8qfy9r000d7sn6dx8bd06u","_id":"ckt8qfybi002w7sn6g00w32vy"},{"post_id":"ckt8qfya5000q7sn6587938hl","tag_id":"ckt8qfy9j00057sn6hynigazw","_id":"ckt8qfybj002y7sn640c44gzg"},{"post_id":"ckt8qfya5000q7sn6587938hl","tag_id":"ckt8qfyb6002b7sn62zzl4qtj","_id":"ckt8qfybk00317sn60ia5gdea"},{"post_id":"ckt8qfya7000r7sn6dzxdgh0p","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfybk00337sn6aw3i0zuh"},{"post_id":"ckt8qfyac000y7sn66ynhdqte","tag_id":"ckt8qfybd002p7sn6h25i4rts","_id":"ckt8qfybl00367sn64j36d8o1"},{"post_id":"ckt8qfyaf00137sn66gr61iax","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfybl00377sn61m7m5bp4"},{"post_id":"ckt8qfyaf00137sn66gr61iax","tag_id":"ckt8qfybh002v7sn69jrcdhq0","_id":"ckt8qfybm00397sn64w3u9syd"},{"post_id":"ckt8qfyah00167sn698ed2zz1","tag_id":"ckt8qfybh002v7sn69jrcdhq0","_id":"ckt8qfybm003a7sn69a0b1iko"},{"post_id":"ckt8qfyak001b7sn60azfhybw","tag_id":"ckt8qfya8000u7sn6gv1270zi","_id":"ckt8qfybn003c7sn64u0p1h0b"},{"post_id":"ckt8qfyak001b7sn60azfhybw","tag_id":"ckt8qfybh002v7sn69jrcdhq0","_id":"ckt8qfybn003d7sn601kt5ei7"},{"post_id":"ckt8qfyal001e7sn61jvh3pnl","tag_id":"ckt8qfybh002v7sn69jrcdhq0","_id":"ckt8qfybo003f7sn6h481g7ts"},{"post_id":"ckt8qfyau001q7sn6em5xfmiy","tag_id":"ckt8qfybd002p7sn6h25i4rts","_id":"ckt8qfybo003g7sn6blk8b3ch"},{"post_id":"ckt8qfyav001t7sn681jk82k0","tag_id":"ckt8qfybo003e7sn69vo75px4","_id":"ckt8qfybq003i7sn6ek1i6tzh"},{"post_id":"ckt8qfyb9002g7sn6flk49k2f","tag_id":"ckt8qfybh002v7sn69jrcdhq0","_id":"ckt8qfybr003k7sn64npd4srv"},{"post_id":"ckt8qfybb002k7sn6gi8nec7z","tag_id":"ckt8qfybd002p7sn6h25i4rts","_id":"ckt8qfybs003l7sn669mgfowr"}],"Tag":[{"name":"日记","_id":"ckt8qfy9j00057sn6hynigazw"},{"name":"随笔","_id":"ckt8qfy9r000d7sn6dx8bd06u"},{"name":"Swift","_id":"ckt8qfya8000u7sn6gv1270zi"},{"name":"Vim","_id":"ckt8qfyb6002b7sn62zzl4qtj"},{"name":"待续","_id":"ckt8qfybd002p7sn6h25i4rts"},{"name":"读书","_id":"ckt8qfybh002v7sn69jrcdhq0"},{"name":"Objective-C","_id":"ckt8qfybo003e7sn69vo75px4"}]}}